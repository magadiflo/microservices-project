# Secci√≥n 11: Trazabilidad distribuida con Micrometer Tracing y Zipkin

---

## Introducci√≥n a la trazabilidad distribuida

En 2016, el equipo de `Spring Cloud` cre√≥ una biblioteca de rastreo que podr√≠a ser de gran ayuda para muchos
desarrolladores. Se llam√≥ `Spring Cloud Sleuth`. El equipo de `Spring` se dio cuenta de que el rastreo pod√≠a
separarse de `Spring Cloud` y cre√≥ el proyecto `Micrometer Tracing`, que es, esencialmente, una copia de
`Spring Cloud Sleuth` independiente de `Spring`. `Micrometer Tracing` se lanz√≥ con su versi√≥n 1.0.0 GA en
noviembre de 2022 y ha mejorado constantemente desde entonces.

### ¬øQu√© es Micrometer?

`Micrometer` es una `facade (fachada) para m√©tricas` en aplicaciones Java. Es la biblioteca de m√©tricas integrada por
defecto en `Spring Boot 2+`, y permite recolectar y exportar m√©tricas hacia distintos sistemas como `Prometheus`,
`Datadog`, `New Relic`, entre otros.

Desde `Spring Boot 3`, `Micrometer` tambi√©n incluye soporte para trazabilidad distribuida a trav√©s de su m√≥dulo llamado
`Micrometer Tracing`, que reemplaza al antiguo `spring-cloud-sleuth`.

### Funciones clave de Micrometer Tracing:

- Generaci√≥n autom√°tica de `trazas (traces)` y `spans` para cada solicitud entrante y saliente.
- `Propagaci√≥n de contexto` entre microservicios, incluso cuando se usan tecnolog√≠as reactivas como `WebFlux`.
- Soporte para `exportaci√≥n de trazas` hacia sistemas como `Zipkin` o `OpenTelemetry`.
- Integraci√≥n fluida con `Spring Cloud Gateway`, `RestTemplate`, `WebClient`, `Feign`, etc.

### ¬øQu√© es Zipkin?

`Zipkin` es una herramienta de trazabilidad distribuida desarrollada por Twitter. Su prop√≥sito es recoger, almacenar y
visualizar trazas de solicitudes que fluyen entre los diferentes servicios de una arquitectura distribuida (como los
microservicios).

### Funcionalidades principales:

- Visualizaci√≥n de `todo el recorrido de una solicitud` a trav√©s de m√∫ltiples microservicios.
- An√°lisis de `latencia`, cuellos de botella, y puntos de fallo.
- Muestra de cada `span` (segmento de una operaci√≥n) con detalles como duraci√≥n, nombre del servicio, etiquetas
  personalizadas, etc.

### ¬øC√≥mo se conecta con Micrometer?

`Micrometer Tracing` puede usar un reporter para enviar las trazas recolectadas a `Zipkin`. As√≠, `Zipkin` se convierte
en el backend de visualizaci√≥n de las trazas generadas por tu aplicaci√≥n.

### Relaci√≥n entre Micrometer y Zipkin

| Componente           | Rol                                       |
|----------------------|-------------------------------------------|
| `Micrometer Tracing` | Genera y gestiona trazas/spans en la app. |
| `Zipkin`             | Recibe, almacena y visualiza las trazas.  |

### ¬øQu√© son el `traceId` y el `spanId`?

En un sistema de `trazabilidad distribuida`, como el que se implementa con `Micrometer Tracing` y `Zipkin`, se utiliza
una estructura jer√°rquica para rastrear c√≥mo una solicitud fluye a trav√©s de varios servicios.

1. üìç `traceId` (ID de traza)

- Es un `identificador √∫nico` que representa una `√∫nica solicitud de extremo a extremo` a trav√©s de todo el sistema
  distribuido.
- Todos los `spans` (segmentos) relacionados con esa solicitud comparten el mismo `traceId`.
- Permite reconstruir toda la cadena de eventos y llamadas que ocurrieron desde el inicio hasta el final de la petici√≥n.

  > üß† `Ejemplo`: Una solicitud HTTP que entra por el `gateway-server` y luego pasa a `item-service` y despu√©s a
  > `product-service`, tendr√° el mismo `traceId` en todos esos servicios.

2. üìç `spanId` (ID de segmento)

- Es un `identificador √∫nico` para una `operaci√≥n individual dentro del sistema`.
- Cada vez que un servicio realiza una operaci√≥n (como llamar a otro servicio, acceder a una base de datos, etc.), se
  crea un nuevo `span` con su propio `spanId`.
- Un `span` puede tener un `parentSpanId`, que indica qui√©n lo invoc√≥.

  > üß† `Ejemplo`: El `gateway-server` recibe una solicitud y genera un `spanId`. Luego, cuando llama al `item-service`,
  > se genera otro `spanId` con el `spanId` del `gateway` como padre.

Imaginemos la siguiente estructura de llamada:

````
traceId: abc123
‚îî‚îÄ‚îÄ spanId: 001 (Gateway)
    ‚îú‚îÄ‚îÄ spanId: 002 (Llamada a item-service)
    ‚îî‚îÄ‚îÄ spanId: 003 (Llamada a product-service)
````

- Todos los `spanId` est√°n relacionados al mismo `traceId` porque son parte de la misma solicitud.
- Pero cada operaci√≥n tiene su propio `spanId`, lo que permite saber qu√© parte de la solicitud tom√≥ cu√°nto tiempo y
  d√≥nde se ejecut√≥.

## Agregando Dependencia de Micrometer Tracing

En este apartado nos guiaremos de la
[documentaci√≥n oficial de Micrometer Tracing](https://docs.micrometer.io/tracing/reference/tracers.html) para obtener
la dependencia que agregaremos a nuestros proyectos.

Agregamos las siguientes dependencias en el `pom.xml` de los siguientes microservicios:

- item-service
- product-service
- user-service
- gateway-server
- authorization-server

````xml

<dependencies>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-actuator</artifactId>
    </dependency>
    <dependency>
        <groupId>io.micrometer</groupId>
        <artifactId>micrometer-tracing-bridge-brave</artifactId>
    </dependency>
</dependencies>
````

**Nota**
> La dependencia `micrometer-tracing-bridge-brave` incluye transitivamente la dependencia `micrometer-tracing`, por lo
> que `no es necesario declararla por separado`.
>
> Se utiliza la dependencia `spring-boot-starter-actuator` para habilitar los endpoints de `observabilidad` y `salud`
> del sistema.

### 1. ‚úÖ micrometer-tracing

- Esta es la `API base de trazabilidad distribuida` proporcionada por `Micrometer`.
- Define las interfaces gen√©ricas como `Tracer`, `Span`, `ContextPropagator`, etc.
- No contiene implementaci√≥n espec√≠fica: `no genera ni reporta trazas por s√≠ sola`.
- Es √∫til si est√°s creando algo muy personalizado o si est√°s haciendo una librer√≠a que no debe acoplarse a una
  implementaci√≥n en particular (como `Brave` u `OpenTelemetry`).

### 2. ‚úÖ micrometer-tracing-bridge-brave

- Esta es la `implementaci√≥n que conecta Micrometer con Brave`, el motor de trazabilidad desarrollado originalmente por
  Twitter (y usado por Zipkin).
- Al incluir esta dependencia:
    - Se implementan las interfaces de `micrometer-tracing`.
    - Se integra autom√°ticamente con `Spring Boot`.
    - Se activa el trazado y la `propagaci√≥n de contexto` con `Brave`.

## Configurando trazabilidad

Agregamos las siguientes configuraciones en el `application.yml` de los siguientes microservicios:

- item-service
- product-service
- user-service
- gateway-server
- authorization-server

````yml
management:
  tracing:
    sampling:
      probability: 1.0
````

La configuraci√≥n anterior define `cu√°ntas trazas se van a capturar` en tu aplicaci√≥n.

- Es una probabilidad de muestreo entre `0.0` y `1.0`.
- `1.0` ‚Üí se capturan todas las trazas (100% de las solicitudes).
- `0.5` ‚Üí se capturan el `50%` de las solicitudes de forma aleatoria.
- `0.0` ‚Üí no se captura ninguna traza.

> ‚úÖ Esto es `muy √∫til en desarrollo`, porque te permite ver todo el flujo de las peticiones entre microservicios.<br>
> ‚ö†Ô∏è En producci√≥n, a veces se recomienda bajar esta probabilidad (por ejemplo, a 0.1) para no sobrecargar tu sistema
> de observabilidad.

## A√±adiendo Logs en nuestros microservicios para agregarlos a Micrometer Tracing

Como ya estamos usando el `@Slf4j` en las clases de nuestros servicios, podemos hacer uso directo de `log.info(...)`,
`log.warn(...)`, `log.error(...)`, etc. El detalle es saber d√≥nde y c√≥mo agregar logs en las clases para aprovechar el
`traceId` y `spanId`, y facilitar el seguimiento distribuido.

En nuestro caso, agregaremos logs en algunos de los microservicios como el `item-service`, `product-service` y
`user-service`.

1. `Entradas de m√©todos p√∫blicos`, agrega `log.info(...)` al inicio de cada m√©todo para registrar que la operaci√≥n fue
   invocada. Esto ayuda a tener una traza clara en `Zipkin`.
    ````java
    
    @Override
    public List<UserResponse> findUsers() {
        log.info("Buscando todos los usuarios");
        return this.userRepository.findAll().stream()
                .map(this.userMapper::toUserResponse)
                .toList();
    }
    ````

2. `Par√°metros importantes`, loguea valores relevantes, como `IDs`, `usernames` o `par√°metros` que te ayuden a
   identificar la llamada.
    ````java
    
    @Override
    public UserResponse findUser(Long userId) {
        log.info("Buscando usuario por id: {}", userId);
        return this.userRepository.findById(userId)
                .map(this.userMapper::toUserResponse)
                .orElseThrow(() -> {
                    log.warn("No se encontr√≥ el usuario con id: {}", userId);
                    return new NoSuchElementException(UserConstant.NO_SUCH_ELEMENT_MESSAGE.formatted(userId));
                });
    }
    ````

3. `Acciones de escritura (save, update, delete)`, loguea el tipo de acci√≥n y datos relevantes (como userId, nombre de
   usuario, etc.).
    ````java
    
    @Override
    @Transactional
    public UserResponse saveUser(UserRequest userRequest) {
        log.info("Guardando nuevo usuario con username: {}", userRequest.username());
        User userToSave = this.userMapper.toUser(userRequest);
        String role = userRequest.isAdmin() != null && userRequest.isAdmin() ? Roles.ROLE_ADMIN.name() : Roles.ROLE_USER.name();
        Optional<Role> roleOptional = this.roleRepository.findByName(role);
        if (roleOptional.isPresent()) {
            log.info("Asignando el rol {} al usuario {}", roleOptional.get(), userRequest.username());
            Set<Role> roles = new HashSet<>();
            roles.add(roleOptional.get());
            userToSave.setRoles(roles);
        }
        User userDB = this.userRepository.save(userToSave);
        log.info("Usuario creado con √©xito: {}", userDB.getId());
        return this.userMapper.toUserResponse(userDB);
    }
    ````

4. `Errores y condiciones especiales`, usa `log.warn` o `log.error` para condiciones an√≥malas, como roles inv√°lidos.
    ````java
    
    @Override
    @Transactional
    public UserResponse updateUserRoles(Long userId, Set<String> roleNames) {
        log.info("Actualizando roles para el usuario con id: {}", userId);
        boolean invalidRoleExists = roleNames.stream()
                .anyMatch(roleName -> !Roles.exists(roleName));
    
        if (invalidRoleExists) {
            log.warn("Se intent√≥ asignar uno o m√°s roles inv√°lidos: {}", roleNames);
            throw new IllegalStateException(UserConstant.ILLEGAL_STATE_ROLE_EXCEPTION);
        }
    
        Set<Role> rolesDB = this.roleRepository.findAllByNameIn(roleNames);
    
        return this.userRepository.findById(userId)
                .map(userDB -> this.userMapper.toUpdateUserRoles(userDB, rolesDB))
                .map(this.userRepository::save)
                .map(this.userMapper::toUserResponse)
                .orElseThrow(() -> new NoSuchElementException(UserConstant.NO_SUCH_ELEMENT_MESSAGE.formatted(userId)));
    }
    ````

5. `Confirmaciones o trazas adicionales`, puedes agregar logs finales opcionales si quieres marcar el √©xito de una
   operaci√≥n importante.
    ````bash
    log.info("Usuario actualizado con √©xito: {}", userId);
    ````

## Propagaci√≥n autom√°tica del contexto reactivo para trazabilidad (traceId, spanId)

En aplicaciones `reactivas` (como `Spring Cloud Gateway`), los contextos como `traceId` y `spanId` no se propagan
autom√°ticamente entre hilos o entre operadores `Mono/Flux`. Esto ocasiona que:

- No se registre la traza correctamente en los logs (`traceId`, `spanId` aparecen como vac√≠os).
- No se transmitan los datos del contexto en subprocesos as√≠ncronos.
- Los logs de trazabilidad en filtros globales (como `GlobalFilter`) no muestren el `ID de traza`, incluso si
  `Micrometer` y `Spring Sleuth/OpenTelemetry` est√°n correctamente configurados.

En aplicaciones `reactivas`, como las que usan `Reactor (Project Reactor)`, el contexto (como `traceId`, `spanId`,
`Authentication`, etc.) no viaja autom√°ticamente a trav√©s de hilos como en aplicaciones imperativas. Por eso,
los valores que esperamos ver en los logs, como los de trazabilidad, desaparecen al cambiar de hilo.

Por ejemplo, si vemos en ejecuci√≥n el log de nuestro `gateway-server` sin haber realizado alguna configuraci√≥n de
contexto, observamos que el `traceId` y el `spanId` no se muestran.

````bash
INFO 18240 --- [gateway-server] [     parallel-1] [                                                 ] d.m.g.s.app.filter.SampleGlobalFilter    : Global: ejecutando filtro request PRE
INFO 18240 --- [gateway-server] [ctor-http-nio-4] [                                                 ] d.m.g.s.app.filter.SampleGlobalFilter    : Global: ejecutando filtro response POST
````

Para solucionar ese problema agregamos el `Hooks.enableAutomaticContextPropagation()` en el m√©todo main de la clase
principal de la aplicaci√≥n `gateway-server`.

````java

@SpringBootApplication
public class GatewayServerApplication {

    public static void main(String[] args) {
        // Habilita la propagaci√≥n autom√°tica del contexto de Reactor (incluyendo traceId y spanId) 
        // antes de que se inicialice el contexto de Spring. 
        // Esto permite que los logs muestren trazabilidad autom√°ticamente.
        Hooks.enableAutomaticContextPropagation();

        SpringApplication.run(GatewayServerApplication.class, args);
    }
}
````

**¬øQu√© es lo que hace?**

- Habilita la `propagaci√≥n autom√°tica del contexto` de Reactor.
- Garantiza que el contexto de seguimiento se propague autom√°ticamente entre subprocesos y l√≠mites as√≠ncronos dentro de
  flujos reactivos.
- Esto es crucial para mantener un seguimiento consistente en toda la aplicaci√≥n, incluso cuando la ejecuci√≥n salta
  entre subprocesos o implica operaciones no bloqueantes.
- Esto permite que el `ContextView` (que es donde se guardan esos datos de trazabilidad) se `inyecte` correctamente
  en los hilos donde haces logs, incluso despu√©s de cambios de hilo.

**¬øPor qu√© debe colocarse en el `main()`?**

- `Hooks.enableAutomaticContextPropagation()` debe ejecutarse antes de que se construya el `ApplicationContext` de
  `Spring` para garantizar que la propagaci√≥n del contexto est√© activa desde el inicio.
- Esto asegura que todos los componentes que usan Reactor (`Mono`, `Flux`) est√©n correctamente envueltos con la l√≥gica
  de propagaci√≥n de contexto.

Ahora que hemos agregado `Hooks.enableAutomaticContextPropagation()` en nuestra clase principal del `gateway-server`
vemos en ejecuci√≥n los logs generados. ¬°Ya se muestra el `traceId` y el `spanId`!

````bash
INFO 18108 --- [gateway-server] [     parallel-1] [680805d8e0b37fc3d0a5c91e06508d17-98f7338e37a8c76a] d.m.g.s.app.filter.SampleGlobalFilter    : Global: ejecutando filtro request PRE
INFO 18108 --- [gateway-server] [ctor-http-nio-4] [680805d8e0b37fc3d0a5c91e06508d17-98f7338e37a8c76a] d.m.g.s.app.filter.SampleGlobalFilter    : Global: ejecutando filtro response POST
````

### Nota

La siguiente configuraci√≥n es equivalente funcionalmente a llamar a `Hooks.enableAutomaticContextPropagation()`.
Esta propiedad le indica a `Spring Boot 3+` (cuando usas `Micrometer Tracing y Reactor`) que habilite autom√°ticamente
la propagaci√≥n del contexto reactivo, incluyendo cosas como `traceId`, `spanId`, `MDC`, etc., sin necesidad de llamar
manualmente a `Hooks.enableAutomaticContextPropagation()`.

````yml
spring:
  reactor:
    context-propagation: auto
````

En mi caso optar√© por seguir usando el `Hooks.enableAutomaticContextPropagation()`.

## Revisando trazas generadas

Ejecutamos las aplicaciones en el siguiente orden:

- config-server
- discovery-server
- authorization-server
- product-service, item-service, user-service
- gateway-server

Realizamos la siguiente petici√≥n. Esto ir√° primero al `gateway-server`, luego al `item-service` y finalmente al
`product-service`.

````bash
$ curl -v http://localhost:8090/api/v1/items | jq
>
< HTTP/1.1 200 OK
< transfer-encoding: chunked
< Content-Type: application/json
< Date: Tue, 22 Apr 2025 21:31:57 GMT
< token-response: 123456
< X-Response-color: green
< Cache-Control: no-cache, no-store, max-age=0, must-revalidate
< Pragma: no-cache
< Expires: 0
< X-Content-Type-Options: nosniff
< X-Frame-Options: DENY
< X-XSS-Protection: 0
< Referrer-Policy: no-referrer
< set-cookie: color=red
<
[
  {
    "product": {
      "id": 1,
      "name": "Panasonic",
      "price": 800.00,
      "createAt": "2025-04-22T15:05:22",
      "port": 62091
    },
    "quantity": 1,
    "total": 800.00
  },
  {...},
  {
    "product": {
      "id": 9,
      "name": "Reebok",
      "price": 300.00,
      "createAt": "2025-04-22T15:05:22",
      "port": 62091
    },
    "quantity": 1,
    "total": 300.00
  }
]
````

- ### Logs del Gateway Server
    ````bash
    INFO 21948 --- [gateway-server] [     parallel-3] [68080acd1650d3de7130b5db0b629e5f-3514862aa0a44e20] d.m.g.s.app.filter.SampleGlobalFilter    : Global: ejecutando filtro request PRE
    INFO 21948 --- [gateway-server] [ctor-http-nio-6] [68080acd1650d3de7130b5db0b629e5f-3514862aa0a44e20] d.m.g.s.app.filter.SampleGlobalFilter    : Global: ejecutando filtro response POST
    ````
  En los logs del `gateway-server` se est√°n viendo correctamente la trazabilidad:.

    - `traceId`: 68080acd1650d3de7130b5db0b629e5f
    - `spanId`: 3514862aa0a44e20

- ### Logs del Item Service
    ````bash
    INFO 5544 --- [item-service] [nio-8085-exec-3] [68080acd1650d3de7130b5db0b629e5f-2bd00b470ed9fe8a] .m.i.a.s.i.ItemServiceWithRestClientImpl : Obteniendo productos desde el product-service
    INFO 5544 --- [item-service] [nio-8085-exec-3] [68080acd1650d3de7130b5db0b629e5f-2bd00b470ed9fe8a] .m.i.a.s.i.ItemServiceWithRestClientImpl : Productos recuperados desde el product-service: 9
    INFO 5544 --- [item-service] [nio-8085-exec-3] [68080acd1650d3de7130b5db0b629e5f-2bd00b470ed9fe8a] .m.i.a.s.i.ItemServiceWithRestClientImpl : Generando items a partir de los productos recuperados
    ````
  En los logs del `item-service` tambi√©n se mantiene el mismo `traceId` (`68080acd1650d3de7130b5db0b629e5f`), lo
  cual confirma que `la trazabilidad se est√° propagando correctamente` desde el `gateway-server` hacia el
  `item-service`.

- ### Logs del Product Service
    ````bash
    INFO 13504 --- [product-service] [o-auto-1-exec-5] [68080acd121e7b6f72ebe7f8e27075de-72ebe7f8e27075de] d.m.p.a.service.impl.ProductServiceImpl  : Buscando todos los productos
    DEBUG 13504 --- [product-service] [o-auto-1-exec-5] [68080acd121e7b6f72ebe7f8e27075de-72ebe7f8e27075de] org.hibernate.SQL                        : 
        select
            p1_0.id,
            p1_0.create_at,
            p1_0.name,
            p1_0.price 
        from
            products p1_0
    INFO 13504 --- [product-service] [o-auto-1-exec-5] [68080acd121e7b6f72ebe7f8e27075de-72ebe7f8e27075de] d.m.p.a.service.impl.ProductServiceImpl  : Obteniendo el puerto donde se ejecuta este microservicio
    INFO 13504 --- [product-service] [o-auto-1-exec-5] [68080acd121e7b6f72ebe7f8e27075de-72ebe7f8e27075de] d.m.p.a.service.impl.ProductServiceImpl  : Obteniendo el puerto donde se ejecuta este microservicio
    INFO 13504 --- [product-service] [o-auto-1-exec-5] [68080acd121e7b6f72ebe7f8e27075de-72ebe7f8e27075de] d.m.p.a.service.impl.ProductServiceImpl  : Obteniendo el puerto donde se ejecuta este microservicio
    INFO 13504 --- [product-service] [o-auto-1-exec-5] [68080acd121e7b6f72ebe7f8e27075de-72ebe7f8e27075de] d.m.p.a.service.impl.ProductServiceImpl  : Obteniendo el puerto donde se ejecuta este microservicio
    INFO 13504 --- [product-service] [o-auto-1-exec-5] [68080acd121e7b6f72ebe7f8e27075de-72ebe7f8e27075de] d.m.p.a.service.impl.ProductServiceImpl  : Obteniendo el puerto donde se ejecuta este microservicio
    INFO 13504 --- [product-service] [o-auto-1-exec-5] [68080acd121e7b6f72ebe7f8e27075de-72ebe7f8e27075de] d.m.p.a.service.impl.ProductServiceImpl  : Obteniendo el puerto donde se ejecuta este microservicio
    INFO 13504 --- [product-service] [o-auto-1-exec-5] [68080acd121e7b6f72ebe7f8e27075de-72ebe7f8e27075de] d.m.p.a.service.impl.ProductServiceImpl  : Obteniendo el puerto donde se ejecuta este microservicio
    INFO 13504 --- [product-service] [o-auto-1-exec-5] [68080acd121e7b6f72ebe7f8e27075de-72ebe7f8e27075de] d.m.p.a.service.impl.ProductServiceImpl  : Obteniendo el puerto donde se ejecuta este microservicio
    INFO 13504 --- [product-service] [o-auto-1-exec-5] [68080acd121e7b6f72ebe7f8e27075de-72ebe7f8e27075de] d.m.p.a.service.impl.ProductServiceImpl  : Obteniendo el puerto donde se ejecuta este microservicio
    ````
  El `traceId` en el `product-service` es diferente al del `gateway-server` y `item-service`.

### ¬øPor qu√© el `gateway-server` s√≠ propaga las trazas autom√°ticamente?

El `gateway-server` est√° construido sobre `Spring Cloud Gateway`, que usa `WebFlux (reactivo)`. Y `Spring Cloud Gateway`
ya viene integrado con la infraestructura de `observabilidad` de `Spring (Micrometer + Brave/OpenTelemetry)`, lo que
permite que:

- Cuando llega una solicitud HTTP externa, `Spring Gateway` genera o recupera el `traceId/spanId`.
- Luego, cuando reenv√≠a la solicitud (por ejemplo, a `item-service`), `Spring Gateway` propaga autom√°ticamente los
  headers de trazabilidad, como `traceparent` o `b3`.

‚úÖ Eso funciona `out-of-the-box`, sin necesidad de agregar manualmente headers.

### ¬øY por qu√© el `item-service` no propaga autom√°ticamente?

Cuando t√∫, desde el `item-service`, haces una llamada `HTTP` a otro microservicio (en este caso al `product-service`)
usando `RestClient` o `RestTemplate`, el contexto de trazabilidad no se propaga autom√°ticamente, a menos que lo
configures correctamente.

Esto pasa porque:

- El `RestClient` (o `RestTemplate`) necesita que se le agregue un interceptor que tome el `traceId/spanId` actual del
  contexto y lo ponga en los headers de la solicitud HTTP.
- Si t√∫ instancias el `RestClient` manualmente (por ejemplo, con `new RestClient()`), ese interceptor no est√° presente.

