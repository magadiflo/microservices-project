# Sección 11: Trazabilidad distribuida con Micrometer Tracing y Zipkin

---

## Introducción a la trazabilidad distribuida

### ¿Qué es Micrometer?

`Micrometer` es una `facade (fachada) para métricas` en aplicaciones Java. Es la biblioteca de métricas integrada por
defecto en `Spring Boot 2+`, y permite recolectar y exportar métricas hacia distintos sistemas como `Prometheus`,
`Datadog`, `New Relic`, entre otros.

Desde `Spring Boot 3`, `Micrometer` también incluye soporte para trazabilidad distribuida a través de su módulo llamado
`Micrometer Tracing`, que reemplaza al antiguo `spring-cloud-sleuth`.

### Funciones clave de Micrometer Tracing:

- Generación automática de `trazas (traces)` y `spans` para cada solicitud entrante y saliente.
- `Propagación de contexto` entre microservicios, incluso cuando se usan tecnologías reactivas como `WebFlux`.
- Soporte para `exportación de trazas` hacia sistemas como `Zipkin` o `OpenTelemetry`.
- Integración fluida con `Spring Cloud Gateway`, `RestTemplate`, `WebClient`, `Feign`, etc.

### ¿Qué es Zipkin?

`Zipkin` es una herramienta de trazabilidad distribuida desarrollada por Twitter. Su propósito es recoger, almacenar y
visualizar trazas de solicitudes que fluyen entre los diferentes servicios de una arquitectura distribuida (como los
microservicios).

### Funcionalidades principales:

- Visualización de `todo el recorrido de una solicitud` a través de múltiples microservicios.
- Análisis de `latencia`, cuellos de botella, y puntos de fallo.
- Muestra de cada `span` (segmento de una operación) con detalles como duración, nombre del servicio, etiquetas
  personalizadas, etc.

### ¿Cómo se conecta con Micrometer?

`Micrometer Tracing` puede usar un reporter para enviar las trazas recolectadas a `Zipkin`. Así, `Zipkin` se convierte
en el backend de visualización de las trazas generadas por tu aplicación.

### Relación entre Micrometer y Zipkin

| Componente           | Rol                                       |
|----------------------|-------------------------------------------|
| `Micrometer Tracing` | Genera y gestiona trazas/spans en la app. |
| `Zipkin`             | Recibe, almacena y visualiza las trazas.  |

### ¿Qué son el `traceId` y el `spanId`?

En un sistema de `trazabilidad distribuida`, como el que se implementa con `Micrometer Tracing` y `Zipkin`, se utiliza
una estructura jerárquica para rastrear cómo una solicitud fluye a través de varios servicios.

1. 📍 `traceId` (ID de traza)

- Es un `identificador único` que representa una `única solicitud de extremo a extremo` a través de todo el sistema
  distribuido.
- Todos los `spans` (segmentos) relacionados con esa solicitud comparten el mismo `traceId`.
- Permite reconstruir toda la cadena de eventos y llamadas que ocurrieron desde el inicio hasta el final de la petición.

  > 🧠 `Ejemplo`: Una solicitud HTTP que entra por el `gateway-server` y luego pasa a `item-service` y después a
  > `product-service`, tendrá el mismo `traceId` en todos esos servicios.

2. 📍 `spanId` (ID de segmento)

- Es un `identificador único` para una `operación individual dentro del sistema`.
- Cada vez que un servicio realiza una operación (como llamar a otro servicio, acceder a una base de datos, etc.), se
  crea un nuevo `span` con su propio `spanId`.
- Un `span` puede tener un `parentSpanId`, que indica quién lo invocó.

  > 🧠 `Ejemplo`: El `gateway-server` recibe una solicitud y genera un `spanId`. Luego, cuando llama al `item-service`,
  > se genera otro `spanId` con el `spanId` del `gateway` como padre.

Imaginemos la siguiente estructura de llamada:

````
traceId: abc123
└── spanId: 001 (Gateway)
    ├── spanId: 002 (Llamada a item-service)
    └── spanId: 003 (Llamada a product-service)
````

- Todos los `spanId` están relacionados al mismo `traceId` porque son parte de la misma solicitud.
- Pero cada operación tiene su propio `spanId`, lo que permite saber qué parte de la solicitud tomó cuánto tiempo y
  dónde se ejecutó.
