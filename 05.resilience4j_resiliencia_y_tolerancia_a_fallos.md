# Sección 05: Resilience4j (Resiliencia y tolerancia a fallos)

---

## Introducción a Circuit Breaker (cortocircuito)

El patrón `Circuit Breaker` es una técnica de diseño para manejar fallos en sistemas distribuidos, como los
microservicios, y `Resilience4j` es una biblioteca que implementa este patrón en Java.

Un `Circuit Breaker` (o interruptor de circuito) es un patrón de diseño que protege un sistema de fallos repetidos. Su
funcionamiento es muy similar a un interruptor eléctrico:

1. `Cerrado (Closed)`: Cuando el sistema está funcionando correctamente, el interruptor está cerrado y las solicitudes
   pasan normalmente.

2. `Abierto (Open)`: Si se detectan fallos repetidos (por ejemplo, un servicio no responde), el interruptor se abre y
   las solicitudes no se envían al servicio. En su lugar, el sistema puede devolver una respuesta predeterminada o
   realizar una acción alternativa.

3. `Semi-abierto (Half-Open)`: Después de un periodo de tiempo, el `Circuit Breaker` permite algunas solicitudes de
   prueba (de forma controlada) para ver si el servicio ha recuperado su estabilidad. Si estas solicitudes tienen éxito,
   el circuito se cierra completamente; si fallan, el circuito se abre de nuevo.

![01.png](assets/section-05/01.png)

## Resilience4j

`Resilience4j` es una librería ligera que permite implementar este patrón en Java, y tiene muchas características
útiles como:

- `Circuit Breaker`: Maneja fallos de servicios externos.
- `Rate Limiter`: Limita la cantidad de solicitudes por unidad de tiempo.
- `Retry`: Vuelve a intentar operaciones fallidas.
- `Bulkhead`: Limita el daño de fallos a una parte del sistema.
- `TimeLimiter`: Limita el tiempo de ejecución de operaciones asíncronas.

## Parámetros del Circuit Breaker

- `slidingWindowSize (100)`, el tamaño de la ventana deslizante es por defecto de 100 peticiones. Es decir, se va a
  trabajar con base en 100 solicitudes para determinar la taza de fallos y éxitos.
- `failureRateThreshold(50)`, representa el porcentaje de falla, es el umbral de fallos que por defecto es del `50%`. Es
  decir, si de los 100 request (`slidingWindowSize`) fallan el 50%, entonces se abre el cortocircuito `OPEN`. Después de
  60 segundos (por defecto) pasa al estado semiabierto `HALF_OPEN`. Estando en estado semiabierto realiza peticiones de
  prueba para verificar si el servicio sigue fallando o ya no, de esa forma ver si se regresa a `OPEN` o pasa a
  `CLOSED`.
- `waitDurationInOpenState (60000ms)`, tiempo de duración en el que permanece en estado `OPEN`, por defecto es de 60
  segundos (60000ms).
- `permittedNumberOfCallsInHalfOpenState(10)`, número permitido de llamadas en estado `HALF_OPEN`, por defecto, son 10.
  Ahora, si el porcentaje de fallas en este estado `HALF_OPEN` supera el 50% (`failureRateThreshold`) entonces seguimos
  en estado `OPEN`, pero si las fallas son menores al 50%, entonces se consiera que es momento de regresar al estado
  `CLOSED`. Por ejemplo, si de las 10 llamadas, 2 son de fallo y 8 son de éxito, entonces se pasa al estado `CLOSED`, ya
  que es mayor al 50% la tasa de éxito.
- `slowCallRateThreshold(100)`, umbral cuando la llamada es lenta.
- `slowCallDurationThreshold(60000ms)`, se considera que una llamada es lenta si tiene esta duración de 60000ms.

## Configurando microservicio items con Resilience4j

Para ver el funcionamiento del `Resilience4j` desde nuestro `item-service` necesitamos modificar el `product-service`
para simular comportamientos cuando se hagan llamadas a ese microservicio.

### En el product-service

En nuestro `product-service` crearemos una nueva constante llamada `ILLEGAL_STATE_EXCEPTION`.

````java

@UtilityClass
public class ProductConstant {
    public static final String NO_SUCH_ELEMENT_MESSAGE = "The product with id %d does not exist";
    public static final String ILLEGAL_STATE_EXCEPTION = "Hay un error con el producto con id %d";
}
````

En el manejador de excepciones del `product-service`, capturamos la excepción `IllegalStateException` que será el que
enviemos al cliente cuando ocurra un error simulado al estar probando el `circuit breaker`.

````java

@RestControllerAdvice
public class GlobalExceptionHandler {

    @ExceptionHandler(NoSuchElementException.class)
    public ResponseEntity<ErrorResponse> apiException(NoSuchElementException exception, HttpServletRequest request) {
        ErrorResponse error = new ErrorResponse(HttpStatus.NOT_FOUND.value(), HttpStatus.NOT_FOUND.getReasonPhrase(), exception.getMessage(), request.getRequestURI());
        return ResponseEntity.status(HttpStatus.NOT_FOUND).body(error);
    }

    @ExceptionHandler(IllegalStateException.class)
    public ResponseEntity<ErrorResponse> apiException(IllegalStateException exception, HttpServletRequest request) {
        ErrorResponse error = new ErrorResponse(HttpStatus.BAD_REQUEST.value(), HttpStatus.BAD_REQUEST.getReasonPhrase(), exception.getMessage(), request.getRequestURI());
        return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(error);
    }

    @ExceptionHandler(Exception.class)
    public ResponseEntity<ErrorResponse> apiException(Exception exception, HttpServletRequest request) {
        ErrorResponse error = new ErrorResponse(HttpStatus.INTERNAL_SERVER_ERROR.value(), HttpStatus.INTERNAL_SERVER_ERROR.getReasonPhrase(), exception.getMessage(), request.getRequestURI());
        return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(error);
    }
}
````

En el controlador del `product-service` agregamos condicionales para que en función del valor del `productId` lancemos
una `excepción` o simulemos un `timeout`.

````java

@Slf4j
@RequiredArgsConstructor
@RestController
@RequestMapping(path = "/api/v1/products")
public class ProductController {

    private final ProductService productService;

    /* code */

    @GetMapping(path = "/{productId}")
    public ResponseEntity<ProductResponse> findProduct(@PathVariable Long productId) throws InterruptedException {
        if (productId.equals(10L)) {
            throw new IllegalStateException(ProductConstant.ILLEGAL_STATE_EXCEPTION.formatted(productId));
        }

        if (productId.equals(5L)) {
            TimeUnit.SECONDS.sleep(5);
        }
        return ResponseEntity.ok(this.productService.findProduct(productId));
    }

    /* code */
}
````

### En el item-service

En la documentación de [Resilience4j](https://resilience4j.readme.io/docs/getting-started-3) se menciona que para
trabajar con `Resilience4j` debemos agregar la dependencia `spring-cloud-starter-circuitbreaker-resilience4j`. Además,
este módulo espera que `spring-boot-starter-actuator` y `spring-boot-starter-aop` ya estén disponibles en tiempo de
ejecución.

Es importante tener en cuenta que más adelante usaremos anotaciones como `@CircuitBreaker`, `@Retry`, etc. Estas
anotaciones funcionan usando `aspectos (AOP)` para interceptar los métodos anotados. Si no agregamos la dependencia
`spring-boot-starter-aop` las anotaciones no se ejecutarán (se ignorarán silenciosamente).
`Sin AOP, los circuit breakers declarativos no funcionarían.`

Así que agregamos en el `pom.xml` de nuestro `item-service` las siguientes dependencias.

````xml

<dependencies>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-actuator</artifactId>
    </dependency>
    <dependency>
        <groupId>org.springframework.cloud</groupId>
        <artifactId>spring-cloud-starter-circuitbreaker-resilience4j</artifactId>
    </dependency>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-aop</artifactId>
    </dependency>
</dependencies>
````

En el controlador del `item-service` inyectamos el `CircuitBreakerFactory` que luego será utilizado en el endpoint
`findProduct()`. La respuesta que enviemos al cliente será envuelta en el `CircuitBreakerFactory` inyectado, de tal
manera que, si la llamada que se hace con `this.itemService.findItemByProductId(productId, quantity)` al microservicio
de productos es exitosa, se regresa el `ResponseEntity.ok` con el objeto obtenido. En caso de que ocurra un fallo en la
llamada, pues se ejecutará el siguiente parámetro del `run()` que es una función `fallback`, es decir, como camino
alternativo al ocurrir la falla se ejecutará dicha función que en nuestro caso es regresar un `ResponseEntity.ok(item)`.

````java

@Slf4j
@RestController
@RequestMapping(path = "/api/v1/items")
public class ItemController {

    private final ItemService itemService;
    private final CircuitBreakerFactory circuitBreakerFactory;

    public ItemController(@Qualifier("itemServiceWithRestClientImpl") ItemService itemService,
                          CircuitBreakerFactory circuitBreakerFactory) {
        this.itemService = itemService;
        this.circuitBreakerFactory = circuitBreakerFactory;
    }

    /* code */

    @GetMapping(path = "/{productId}")
    public ResponseEntity<Item> findProduct(@PathVariable Long productId, @RequestParam int quantity) {
        Product product = new Product(0L, "Producto respaldo", BigDecimal.ZERO, LocalDateTime.now(), 0);
        Item item = new Item(product, 1);

        return this.circuitBreakerFactory
                .create("items")        //1
                .run(
                        () -> {         //2
                            log.info("Llamando al product-service");
                            return ResponseEntity.ok(this.itemService.findItemByProductId(productId, quantity));
                        },
                        throwable -> {  //3
                            log.warn("Error cuando se llamó al product-service, se envía información alternativa");
                            return ResponseEntity.ok(item);
                        }
                );
    }
}
````

`CircuitBreakerFactory` es una fábrica de circuit breakers que provee `Spring Cloud Circuit Breaker`. Te permite crear y
personalizar circuit breakers de forma programática, sin necesidad de usar anotaciones como `@CircuitBreaker`. Muy útil
cuando quieres más control o necesitas diferentes comportamientos en distintos puntos de tu código.

1. `create("items")`

- Crea un `Circuit Breaker` con nombre `items`.
- Este nombre debe estar relacionado con tu configuración en el `application.yml` (donde defines cosas como
  `failureRateThreshold`, `slidingWindowSize`, etc.).
- Si no lo configuras explícitamente, usará los valores por defecto.

2. `run(Supplier<T> runnable, Function<Throwable, T> fallback)`

- `Primer parámetro`: lo que quieres que se intente ejecutar (la lógica principal).
- `Segundo parámetro`: una función de fallback que se ejecuta si:
    - El circuito está en estado `OPEN`.
    - La lógica principal lanza una excepción.

3. `Fallback (throwable -> {...})`

- Si por ejemplo `product-service` está caído o responde con error, este bloque se ejecuta.
- En tu ejemplo, se devuelve un producto de respaldo `("Producto respaldo")`.

#### Ventajas de usar CircuitBreakerFactory así

- Puedes manejar errores más detalladamente sin depender del manejo automático por anotaciones.
- Ideal para personalizar diferentes fallbacks, por ejemplo, dependiendo del tipo de error o el circuito.
- Muy útil cuando tu lógica está fuera del alcance de los AOP (como métodos privados o lambdas).

## Probando Resilience con los criterios por defecto

### 55 request con errores

A continuación vamos a probar los criterios por defecto del `Circuit Breaker`. Iniciaremos enviando unos `55 request`
con el `productId = 10`, de tal forma que el `product-service` nos lanzará errores. Ahora, como nuestro `item-service`
está haciendo uso del `Circuit Breaker` como alternativa nos devolverá el objeto estático que le definimos.

````bash
$ curl -v -G --data "quantity=10" http://localhost:8090/api/v1/items/10 | jq
>
< HTTP/1.1 200 OK
< transfer-encoding: chunked
< Content-Type: application/json
< Date: Thu, 10 Apr 2025 21:54:53 GMT
< token-response: 123456
< X-Response-color: green
< set-cookie: color=red
<
{
  "product": {
    "id": 0,
    "name": "Producto respaldo",
    "price": 0,
    "createAt": "2025-04-10T16:54:53.8747217",
    "port": 0
  },
  "quantity": 1,
  "total": 0
}
````

### 45 request con éxito

Ahora realizamos unos `45 request` con respuesta exitosa

````bash
$ curl -v -G --data "quantity=10" http://localhost:8090/api/v1/items/1 | jq
>
< HTTP/1.1 200 OK
< transfer-encoding: chunked
< Content-Type: application/json
< Date: Thu, 10 Apr 2025 22:02:59 GMT
< token-response: 123456
< X-Response-color: green
< set-cookie: color=red
<
{
  "product": {
    "id": 1,
    "name": "Panasonic",
    "price": 800.00,
    "createAt": "2025-04-10T16:50:03",
    "port": 52336
  },
  "quantity": 10,
  "total": 8000.00
}
````

### Request 101 muestra el Circuit Breaker abierto

La siguiente petición corresponde al `request #101`, pero como respuesta estamos obteniendo el objeto de respaldo a
pesar de que el producto con `id = 1` es correcto. Esto está ocurriendo porque se ha evaluado de los `100 request` (# de
request por defecto), `55 han fallado` y `45 han sido exitoso`, por lo tanto, la tasa de fallo es superior al `50%`, por
eso es que el `Circuit Breaker` pasó al estado `OPEN` y en vez de devolvernos un error, también nos devuelve un valor
alternativo.

````bash
$ curl -v -G --data "quantity=10" http://localhost:8090/api/v1/items/1 | jq
>
< HTTP/1.1 200 OK
< transfer-encoding: chunked
< Content-Type: application/json
< Date: Thu, 10 Apr 2025 22:04:51 GMT
< token-response: 123456
< X-Response-color: green
< set-cookie: color=red
<
{
  "product": {
    "id": 0,
    "name": "Producto respaldo",
    "price": 0,
    "createAt": "2025-04-10T17:04:51.4119986",
    "port": 0
  },
  "quantity": 1,
  "total": 0
}
````

Durante `1 minuto`, cuando el estado del `Circuit Breaker` esté en estado `OPEN` y a pesar de que el request sea válido,
estaremos recibiendo como respuesta el camino alternativo.

Cuando pase el `1 minuto` volveremos al estado `SEMI ABIERTO` y ahora estaremos probando sobre `#10 request` como base y
ya no sobre `100`.

### 7 request con errores

````bash
$ curl -v -G --data "quantity=10" http://localhost:8090/api/v1/items/10 | jq
>
< HTTP/1.1 200 OK
< transfer-encoding: chunked
< Content-Type: application/json
< Date: Thu, 10 Apr 2025 22:14:46 GMT
< token-response: 123456
< X-Response-color: green
< set-cookie: color=red
<
{
  "product": {
    "id": 0,
    "name": "Producto respaldo",
    "price": 0,
    "createAt": "2025-04-10T17:14:46.4685058",
    "port": 0
  },
  "quantity": 1,
  "total": 0
}
````

### 3 request con éxito

````bash
$ curl -v -G --data "quantity=10" http://localhost:8090/api/v1/items/1 | jq
>
< HTTP/1.1 200 OK
< transfer-encoding: chunked
< Content-Type: application/json
< Date: Thu, 10 Apr 2025 22:15:37 GMT
< token-response: 123456
< X-Response-color: green
< set-cookie: color=red
<
{
  "product": {
    "id": 1,
    "name": "Panasonic",
    "price": 800.00,
    "createAt": "2025-04-10T16:50:03",
    "port": 52336
  },
  "quantity": 10,
  "total": 8000.00
}
````

### Request #11, el Circuit Breaker se mantiene en estado abierto

Hasta este momento la tasa de errores en este estado `SEMI ABIERTO` es más del `50%`, por lo tanto, el siguiente
request que es el `request #11` nos retornará el objeto alternativo manteniéndose el estado en `OPEN`.

````bash
$ curl -v -G --data "quantity=10" http://localhost:8090/api/v1/items/1 | jq
>
< HTTP/1.1 200 OK
< transfer-encoding: chunked
< Content-Type: application/json
< Date: Thu, 10 Apr 2025 22:18:45 GMT
< token-response: 123456
< X-Response-color: green
< set-cookie: color=red
<
{
  "product": {
    "id": 0,
    "name": "Producto respaldo",
    "price": 0,
    "createAt": "2025-04-10T17:18:45.6915877",
    "port": 0
  },
  "quantity": 1,
  "total": 0
}
````

Durante `1 minuto`, cuando el estado del `Circuit Breaker` esté en estado `OPEN` y a pesar de que el request sea válido,
estaremos recibiendo como respuesta el camino alternativo.

Cuando pase el `1 minuto` volveremos al estado `SEMI ABIERTO` y ahora seguiremos probando sobre `#10 request` como base.
Supongamos que ahora hacemos más del `50% de éxito`.

### 2 request con errores

````bash
$ curl -v -G --data "quantity=10" http://localhost:8090/api/v1/items/10 | jq
>
< HTTP/1.1 200 OK
< transfer-encoding: chunked
< Content-Type: application/json
< Date: Thu, 10 Apr 2025 22:25:11 GMT
< token-response: 123456
< X-Response-color: green
< set-cookie: color=red
<
{
  "product": {
    "id": 0,
    "name": "Producto respaldo",
    "price": 0,
    "createAt": "2025-04-10T17:25:11.987164",
    "port": 0
  },
  "quantity": 1,
  "total": 0
}
````

### 8 request con éxito

````bash
$ curl -v -G --data "quantity=10" http://localhost:8090/api/v1/items/1 | jq
>
< HTTP/1.1 200 OK
< transfer-encoding: chunked
< Content-Type: application/json
< Date: Thu, 10 Apr 2025 22:25:35 GMT
< token-response: 123456
< X-Response-color: green
< set-cookie: color=red
<
{
  "product": {
    "id": 1,
    "name": "Panasonic",
    "price": 800.00,
    "createAt": "2025-04-10T16:50:03",
    "port": 52336
  },
  "quantity": 10,
  "total": 8000.00
}
````

### Request #11, el Circuit Breaker pasa al estado CLOSED

Como se hicieron `2 request con errores` y `8 request con éxito`, la tasa de errores es menor del `50%` por lo tanto,
el `Circuit Breaker` pasa al estado `CLOSED` (flujo normal).

````bash
$ curl -v -G --data "quantity=10" http://localhost:8090/api/v1/items/1 | jq
>
< HTTP/1.1 200 OK
< transfer-encoding: chunked
< Content-Type: application/json
< Date: Thu, 10 Apr 2025 22:26:15 GMT
< token-response: 123456
< X-Response-color: green
< set-cookie: color=red
<
{
  "product": {
    "id": 1,
    "name": "Panasonic",
    "price": 800.00,
    "createAt": "2025-04-10T16:50:03",
    "port": 52336
  },
  "quantity": 10,
  "total": 8000.00
}
````

## Personalizando parámetros del Circuit Breaker

En el apartado anterior hicimos pruebas con la configuración por defecto que viene en el `Circuit Breaker`. En este
apartado personalizaremos esas configuraciones con nuevos valores para los parámetros. Para eso, crearemos una clase
de configuración donde definiremos programáticamente los nuevos valores para el `Circuit Breaker`.

````java

@Slf4j
@Configuration
public class ResilienceConfig {

    @Bean
    public Customizer<Resilience4JCircuitBreakerFactory> customizerCircuitBreaker() {
        return factory -> factory.configureDefault(circuitBreakerId -> {
            log.info("Configurando circuit breaker: {}", circuitBreakerId);

            return new Resilience4JConfigBuilder(circuitBreakerId)
                    .circuitBreakerConfig(CircuitBreakerConfig.custom()
                            .slidingWindowSize(10)
                            .failureRateThreshold(50)
                            .waitDurationInOpenState(Duration.ofSeconds(10L))
                            .permittedNumberOfCallsInHalfOpenState(5)
                            .build())
                    .build();
        });
    }
}
````

**Donde**

- `slidingWindowSize(10)`, tamaño de la ventana deslizante ahora será de `10 request` (será nuestro 100%). Recordar que
  por defecto se trabajaba con `100 request`.
- `failureRateThreshold(50)`, umbral de tasa de fallas será del `50%`.
- `waitDurationInOpenState(Duration.ofSeconds(10L))`, duración de espera en estado `OPEN` será de `10 segundos`.
  Recordar que por defecto era de `1 minuto`.
- `permittedNumberOfCallsInHalfOpenState(5)`, número de llamadas permitidas en estado `SEMI ABIERTO`, serán de
  `5 request`. Es decir, que en ese estado ahora los `5 request` serán nuestro `100%`, lo que significa que al tener un
  `failureRateThreshold(50)` si se tiene 3 fallas de 5, seguirá en estado `OPEN`.

**Importante**
> En esta línea del código anterior `factory.configureDefault(circuitBreakerId -> {...}` el `circuitBreakerId` es el
> identificador que le damos a nuestro `Circuit Breaker`. En ese sentido, si vamos al `ItemController`, veremos en el
> método `findProduct()` la creación del `Circuit Breaker` de la siguiente manera:
> `this.circuitBreakerFactory.create("items").run(...);`, en ese caso el id de ese `Circuit Breaker` es `items`.
>
> Esto es muy importante tenerlo en cuenta, ya que con ese identificador podemos configurar los parámetros como el
> tamaño de la ventana deslizante, umbral de tasa de fallas, tiempo de espera en estado abierto, etc. de esa forma
> sobreescribimos los criterios que por defecto trae el `Circuit Breaker`.
>
> Todos los circuit breaker que tengamos en la aplicación pasarán por ese factory como id, pero como solo tenemos uno
> creado llamado `items`, obviamente solo ese se está pasando y se está configurando.

## Probando parámetros customizados del Circuit Breaker

Levantamos nuestras aplicaciones y verificamos que la personalización de parámetros para el `Circuit Breaker` se estén
aplicando. Lo primero que observaremos en la consola del `item-service` será el log que estamos imprimiendo al momento
de realizar la customización del `Circuit Breaker`.

````bash
d.m.item.app.config.ResilienceConfig     : Configurando circuit breaker: items
````

### 7 request con errores

Realizamos 7 request enviando el id el producto 10, esto nos retornará un error, pero como estamos trabajando con
`resilience`, entonces nos devolverá un objeto alternativo.

````bash
$ curl -v -G --data "quantity=10" http://localhost:8090/api/v1/items/10 | jq
>
< HTTP/1.1 200 OK
< transfer-encoding: chunked
< Content-Type: application/json
< Date: Fri, 11 Apr 2025 14:49:38 GMT
< token-response: 123456
< X-Response-color: green
< set-cookie: color=red
<
{
  "product": {
    "id": 0,
    "name": "Producto respaldo",
    "price": 0,
    "createAt": "2025-04-11T09:49:38.3705517",
    "port": 0
  },
  "quantity": 1,
  "total": 0
}
````

### 3 request con éxito

Enviamos 3 request con éxito, por lo que nos retorna el item con el producto buscado.

````bash
$ curl -v -G --data "quantity=10" http://localhost:8090/api/v1/items/1 | jq
>
< HTTP/1.1 200 OK
< transfer-encoding: chunked
< Content-Type: application/json
< Date: Fri, 11 Apr 2025 14:51:54 GMT
< token-response: 123456
< X-Response-color: green
< set-cookie: color=red
<
{
  "product": {
    "id": 1,
    "name": "Panasonic",
    "price": 800.00,
    "createAt": "2025-04-11T09:46:25",
    "port": 56136
  },
  "quantity": 10,
  "total": 8000.00
}
````

### Request #11 muestra el Circuit Breaker abierto

La siguiente petición corresponde al `request #11`, pero como respuesta estamos obteniendo el objeto de respaldo a pesar
de que el producto con `id = 1` es correcto. Esto está ocurriendo porque se ha evaluado de los `10 request`, 7 han
fallado y 3 han sido exitoso, por lo tanto, la tasa de fallo es superior al `50%`, por eso es que el
`Circuit Breaker` pasó al estado `OPEN` y en vez de devolvernos un error, también nos devuelve un valor alternativo.

````bash
$ curl -v -G --data "quantity=10" http://localhost:8090/api/v1/items/1 | jq
>
< HTTP/1.1 200 OK
< transfer-encoding: chunked
< Content-Type: application/json
< Date: Fri, 11 Apr 2025 15:15:46 GMT
< token-response: 123456
< X-Response-color: green
< set-cookie: color=red
<
{
  "product": {
    "id": 0,
    "name": "Producto respaldo",
    "price": 0,
    "createAt": "2025-04-11T10:15:46.5488648",
    "port": 0
  },
  "quantity": 1,
  "total": 0
}
````

Durante `10 segundos` (según la personalización del parámetro), cuando el estado del `Circuit Breaker` esté en estado
`OPEN` y a pesar de que el request sea válido, estaremos recibiendo como respuesta el camino alternativo.

Cuando pase los `10 segundos` volveremos al estado `SEMI ABIERTO` y ahora estaremos probando sobre `#5 request` como
base.

### 4 request con errores

````bash
$ curl -v -G --data "quantity=10" http://localhost:8090/api/v1/items/10 | jq
>
< HTTP/1.1 200 OK
< transfer-encoding: chunked
< Content-Type: application/json
< Date: Fri, 11 Apr 2025 15:17:59 GMT
< token-response: 123456
< X-Response-color: green
< set-cookie: color=red
<
{
  "product": {
    "id": 0,
    "name": "Producto respaldo",
    "price": 0,
    "createAt": "2025-04-11T10:17:59.4226411",
    "port": 0
  },
  "quantity": 1,
  "total": 0
}
````

### 1 request con éxito

````bash
$ curl -v -G --data "quantity=10" http://localhost:8090/api/v1/items/1 | jq
>
< HTTP/1.1 200 OK
< transfer-encoding: chunked
< Content-Type: application/json
< Date: Fri, 11 Apr 2025 15:18:07 GMT
< token-response: 123456
< X-Response-color: green
< set-cookie: color=red
<
{
  "product": {
    "id": 1,
    "name": "Panasonic",
    "price": 800.00,
    "createAt": "2025-04-11T09:54:04",
    "port": 56208
  },
  "quantity": 10,
  "total": 8000.00
}
````

### Request #6, el Circuit Breaker se mantiene en estado abierto

Hasta este momento la tasa de errores en este estado `SEMI ABIERTO` es más del `50%`, por lo tanto, el siguiente request
que es el `request #6` nos retornará el objeto alternativo, a pesar de que la solicitud debería ser exitosa,
manteniéndose el estado en `OPEN`.

````bash
$ curl -v -G --data "quantity=10" http://localhost:8090/api/v1/items/1 | jq
>
< HTTP/1.1 200 OK
< transfer-encoding: chunked
< Content-Type: application/json
< Date: Fri, 11 Apr 2025 15:18:11 GMT
< token-response: 123456
< X-Response-color: green
< set-cookie: color=red
<
{
  "product": {
    "id": 0,
    "name": "Producto respaldo",
    "price": 0,
    "createAt": "2025-04-11T10:18:11.1068484",
    "port": 0
  },
  "quantity": 1,
  "total": 0
}
````

Durante `10 segundos`, cuando el estado del `Circuit Breaker` esté en estado `OPEN` y a pesar de que el request sea
válido, estaremos recibiendo como respuesta el camino alternativo. Cuando pase los `10 segundos` volveremos al estado
`SEMI ABIERTO` y ahora seguiremos probando sobre `#5 request` como base.

Supongamos que ahora hacemos más del `50% de éxito`.

### 2 request con errores

````bash
$ curl -v -G --data "quantity=10" http://localhost:8090/api/v1/items/10 | jq
>
< HTTP/1.1 200 OK
< transfer-encoding: chunked
< Content-Type: application/json
< Date: Fri, 11 Apr 2025 15:21:50 GMT
< token-response: 123456
< X-Response-color: green
< set-cookie: color=red
<
{
  "product": {
    "id": 0,
    "name": "Producto respaldo",
    "price": 0,
    "createAt": "2025-04-11T10:21:50.8114461",
    "port": 0
  },
  "quantity": 1,
  "total": 0
}
````

### 3 request con éxito

````bash
$ curl -v -G --data "quantity=10" http://localhost:8090/api/v1/items/1 | jq
>
< HTTP/1.1 200 OK
< transfer-encoding: chunked
< Content-Type: application/json
< Date: Fri, 11 Apr 2025 15:21:55 GMT
< token-response: 123456
< X-Response-color: green
< set-cookie: color=red
<
{
  "product": {
    "id": 1,
    "name": "Panasonic",
    "price": 800.00,
    "createAt": "2025-04-11T09:54:04",
    "port": 56208
  },
  "quantity": 10,
  "total": 8000.00
}
````

### Request #6, el Circuit Breaker pasa al estado CLOSED

Como se hicieron `2 request con errores` y `3 request con éxito`, la tasa de errores es menor del `50%` por lo tanto,
el `Circuit Breaker` pasa al estado `CLOSED` (flujo normal).

````bash
$ curl -v -G --data "quantity=10" http://localhost:8090/api/v1/items/1 | jq
>
< HTTP/1.1 200 OK
< transfer-encoding: chunked
< Content-Type: application/json
< Date: Fri, 11 Apr 2025 15:22:01 GMT
< token-response: 123456
< X-Response-color: green
< set-cookie: color=red
<
{
  "product": {
    "id": 1,
    "name": "Panasonic",
    "price": 800.00,
    "createAt": "2025-04-11T09:54:04",
    "port": 56208
  },
  "quantity": 10,
  "total": 8000.00
}
````

## Timeout

> El `timeout` es cuando se sobrepasa el tiempo de espera que por defecto en `Spring Cloud` es de `1 segundo`.

Recordemos que para simular esta falla, en el controlador del `product-service` definimos una condición cuando el id
del producto sea igual a 5, que se duerma 5 segundos.

````java

@Slf4j
@RequiredArgsConstructor
@RestController
@RequestMapping(path = "/api/v1/products")
public class ProductController {

    /* code */

    @GetMapping(path = "/{productId}")
    public ResponseEntity<ProductResponse> findProduct(@PathVariable Long productId) throws InterruptedException {
        if (productId.equals(10L)) {
            throw new IllegalStateException(ProductConstant.ILLEGAL_STATE_EXCEPTION.formatted(productId));
        }

        if (productId.equals(5L)) {
            TimeUnit.SECONDS.sleep(5);
        }
        return ResponseEntity.ok(this.productService.findProduct(productId));
    }
    /* code */
}
````

En el `item-service` habíamos definido un bean de configuración para el `Resilience4j`, donde configuramos el
`Circuit Breaker`. En esa misma configuración vamos a agregar la configuración por defecto del `Timeout`, que en este
caso sería a través del `.timeLimiterConfig(TimeLimiterConfig.ofDefaults())`.

````java

@Slf4j
@Configuration
public class ResilienceConfig {

    @Bean
    public Customizer<Resilience4JCircuitBreakerFactory> customizerCircuitBreaker() {
        return factory -> factory.configureDefault(circuitBreakerId -> {
            log.info("Configurando circuit breaker: {}", circuitBreakerId);

            return new Resilience4JConfigBuilder(circuitBreakerId)
                    .circuitBreakerConfig(CircuitBreakerConfig.custom()
                            .slidingWindowSize(10)
                            .failureRateThreshold(50)
                            .waitDurationInOpenState(Duration.ofSeconds(10L))
                            .permittedNumberOfCallsInHalfOpenState(5)
                            .build())
                    .timeLimiterConfig(TimeLimiterConfig.ofDefaults())
                    .build();
        });
    }
}
````

Realizamos una petición a través del `item-service` enviándole el `productId 5` para ver el comportamiento del
`Timeout`. Como respuesta, podemos observar que nos está devolviendo el objeto alternativo, pese a que el producto con
id 5, sí existe. Lo que pasa es que ese producto, según la lógica que implementamos, está experimentando una demora de
5 segundos, por lo que el `timeout` del resilience está configurado por defecto para esperar 1 segundo y como el tiempo
de espera es mayor, entonces se responde al cliente con el objeto alternativo.

````bash
$ curl -v -G --data "quantity=10" http://localhost:8090/api/v1/items/5 | jq
>
< HTTP/1.1 200 OK
< transfer-encoding: chunked
< Content-Type: application/json
< Date: Fri, 11 Apr 2025 15:46:48 GMT
< token-response: 123456
< X-Response-color: green
< set-cookie: color=red
<
{
  "product": {
    "id": 0,
    "name": "Producto respaldo",
    "price": 0,
    "createAt": "2025-04-11T10:46:47.5822349",
    "port": 0
  },
  "quantity": 1,
  "total": 0
}
````

## Personalizando el timeout

En la configuración del resilience, vamos a modificar el `timeout por defecto de 1 segundo` a un
`timeout que acepte hasta 6 segundos`.

````java

@Slf4j
@Configuration
public class ResilienceConfig {

    @Bean
    public Customizer<Resilience4JCircuitBreakerFactory> customizerCircuitBreaker() {
        return factory -> factory.configureDefault(circuitBreakerId -> {
            log.info("Configurando circuit breaker: {}", circuitBreakerId);

            return new Resilience4JConfigBuilder(circuitBreakerId)
                    .circuitBreakerConfig(CircuitBreakerConfig.custom()
                            .slidingWindowSize(10)
                            .failureRateThreshold(50)
                            .waitDurationInOpenState(Duration.ofSeconds(10L))
                            .permittedNumberOfCallsInHalfOpenState(5)
                            .build())
                    .timeLimiterConfig(TimeLimiterConfig.custom()
                            .timeoutDuration(Duration.ofSeconds(6L))
                            .build())
                    .build();
        });
    }
}
````

De esta manera, cuando realicemos la petición con el productId = 5, la `petición será exitosa`, dado que el nuevo
timeout es de 6 segundos frente a los 5 segundos que le toma completar la petición.

````bash
$ curl -v -G --data "quantity=10" http://localhost:8090/api/v1/items/5 | jq
>
< HTTP/1.1 200 OK
< transfer-encoding: chunked
< Content-Type: application/json
< Date: Fri, 11 Apr 2025 15:59:57 GMT
< token-response: 123456
< X-Response-color: green
< set-cookie: color=red
<
100   136    0   136    0     0     25      0 --:--:--  0:00:05 --:--:--    33
{
  "product": {
    "id": 5,
    "name": "Hewlett Packard",
    "price": 500.00,
    "createAt": "2025-04-11T10:45:28",
    "port": 57169
  },
  "quantity": 10,
  "total": 5000.00
}
````

## Llamadas lentas (slow calls)

En `Resilience4j`, una llamada lenta no es necesariamente una que falle, sino una que toma más tiempo del que se
considera aceptable. Detectarlas ayuda a abrir el circuito aunque técnicamente no haya errores, porque un sistema
lento también es un sistema problemático.

Las `llamadas lentas` son similares al `timeout`, con la diferencia que en las llamadas lentas podemos customizar
algunos parámetros. Por ejemplo, una llamada lenta que se demora más de cierta cantidad de tiempo, se contabiliza como
una falla, pero no lanza ningún error, sino que más bien deja ejecutar el request a diferencia del `Timeout` que
simplemente se va al camino alternativo o lanza una excepción en caso de que no se tenga el camino alternativo.

**Nota**
> Debemos tener en cuenta que tanto `llamada lenta` como el `timeout` podrían no funcionar como lo esperamos. Así que
> debemos tener muy en cuenta que el `Timeout` es el que se toma en cuenta antes que la `slowCallDurationThreshold`
> (llamada lenta).
>
> Entonces, si queremos probar la llamada lenta, debemos asignarle al timeout mayor tiempo, en nuestro caso 6 segundos
> está perfecto, mientras que a la llamada lenta debemos asignarle menor tiempo para que esta se tome en cuenta primero.

En las configuraciones del resilience del `item-service` vamos a agregar las configuraciones para hacer pruebas con las
llamadas lentas.

````java

@Slf4j
@Configuration
public class ResilienceConfig {

    @Bean
    public Customizer<Resilience4JCircuitBreakerFactory> customizerCircuitBreaker() {
        return factory -> factory.configureDefault(circuitBreakerId -> {
            log.info("Configurando circuit breaker: {}", circuitBreakerId);

            return new Resilience4JConfigBuilder(circuitBreakerId)
                    .circuitBreakerConfig(CircuitBreakerConfig.custom()
                            .slidingWindowSize(10)
                            .failureRateThreshold(50)
                            .waitDurationInOpenState(Duration.ofSeconds(10L))
                            .permittedNumberOfCallsInHalfOpenState(5)
                            .slowCallRateThreshold(50)
                            .slowCallDurationThreshold(Duration.ofSeconds(2L))
                            .build())
                    .timeLimiterConfig(TimeLimiterConfig.custom()
                            .timeoutDuration(Duration.ofSeconds(6L))
                            .build())
                    .build();
        });
    }
}
````

De las configuraciones anteriores, fijémonos en las siguientes dos que se han agregado:

- `slowCallDurationThreshold(Duration.ofSeconds(2L))`
    - Define el límite de tiempo (threshold) que se usa para clasificar una llamada como lenta (por defecto es 60
      segundos).
    - En nuestro caso: si una llamada dura más de 2 segundos, se marca como lenta.


- `slowCallRateThreshold(50)`
    - Es el porcentaje máximo de llamadas lentas permitido, con respecto a las llamadas analizadas en la ventana (por
      defecto es 100%).
    - En nuestro caso: si más del 50% de las llamadas dentro de las últimas 10 (`slidingWindowSize`) se consideran
      lentas, entonces el circuito también se abre.

## Configurando Resilience4j en el application.yml

Otra forma de centralizar la configuración sin necesidad de codificarla con Java, especialmente útil cuando tenemos
varios `Circuit Breakers` y queremos aplicarles políticas comunes o específicas, es a través del uso del archivo
`application.yml`.

La configuración que hagamos en el archivo `application.yml` del `item-service` tendrá mayor prioridad que nuestra clase
de configuración `ResilienceConfig`, pero en ambos estamos haciendo lo mismo. Esto significa que la configuración que se
aplicará será la configuración que está en el `application.yml`, mientras que la configuración del `ResilienceConfig`
será descartada.

**Nota**
> Usar solo una de las dos formas, ya sea mediante el archivo `application.yml` o la `clase de configuración`.

A continuación se muestra la configuración personalizada del `CircuitBreaker` definida en nuestro `application.yml`.

````yml
resilience4j.circuitbreaker:
  configs:
    shared:
      slidingWindowSize: 6
      failureRateThreshold: 50
      waitDurationInOpenState: 20s
      permittedNumberOfCallsInHalfOpenState: 4
      slowCallRateThreshold: 50
      slowCallDurationThreshold: 2s
  instances:
    items:
      baseConfig: shared
````

`resilience4j.circuitbreaker`, esta es la raíz de configuración del `Circuit Breaker`. Tiene dos partes importantes:
`configs` y `instances`.

#### configs

Aquí definimos una configuración base llamada `shared`, la cual puede ser reutilizada por múltiples instancias. También
podríamos definir otras configuraciones base si necesitamos diferentes políticas para distintos `circuit breakers`.

Lo que hace cada propiedad:

- `slidingWindowSize: 6`, evalúa las estadísticas de las últimas 6 llamadas (éxito/fallo/lentas).
- `failureRateThreshold: 50`, si el 50% o más de las llamadas fallan, el circuito se abre.
- `waitDurationInOpenState: 20s`, el circuito permanece abierto durante 20 segundos antes de probar si se puede cerrar.
- `permittedNumberOfCallsInHalfOpenState: 4`, cuando está en estado semiabierto, permite 4 llamadas de prueba.
- `slowCallRateThreshold: 50`, si el 50% de las llamadas dentro de la ventana son lentas, también se abre el circuito.
- `slowCallDurationThreshold: 2s`, si una llamada tarda más de 2 segundos, se considera lenta.

#### instances

Aquí definimos una instancia específica de `Circuit Breaker` llamada `items`. Esta instancia usa la configuración base
llamada `shared` definida en el apartado de `configs`.

Ahora vamos a proceder a probar nuestra configuración del `application.yml` recordando que tenemos como base
`6 request (slidingWindowSize)`.

### 4 request con errores

````bash
$ curl -v -G --data "quantity=10" http://localhost:8090/api/v1/items/10 | jq
>
< HTTP/1.1 200 OK
< transfer-encoding: chunked
< Content-Type: application/json
< Date: Fri, 11 Apr 2025 17:31:56 GMT
< token-response: 123456
< X-Response-color: green
< set-cookie: color=red
<
{
  "product": {
    "id": 0,
    "name": "Producto respaldo",
    "price": 0,
    "createAt": "2025-04-11T12:31:56.1580705",
    "port": 0
  },
  "quantity": 1,
  "total": 0
}
````

### 2 request con éxito

````bash
$ curl -v -G --data "quantity=10" http://localhost:8090/api/v1/items/1 | jq
>
< HTTP/1.1 200 OK
< transfer-encoding: chunked
< Content-Type: application/json
< Date: Fri, 11 Apr 2025 17:32:06 GMT
< token-response: 123456
< X-Response-color: green
< set-cookie: color=red
<
{
  "product": {
    "id": 1,
    "name": "Panasonic",
    "price": 800.00,
    "createAt": "2025-04-11T12:27:21",
    "port": 59219
  },
  "quantity": 10,
  "total": 8000.00
}
````

### Request #7, el Circuit Breaker se mantiene en estado abierto

Se pasa al estado `OPEN` dado que se han realizado anteriormente `4 request con errores` y `2 request con éxito`.
Por lo tanto, más del `50% son de errores`.

````bash
$ curl -v -G --data "quantity=10" http://localhost:8090/api/v1/items/1 | jq
>
< HTTP/1.1 200 OK
< transfer-encoding: chunked
< Content-Type: application/json
< Date: Fri, 11 Apr 2025 17:32:12 GMT
< token-response: 123456
< X-Response-color: green
< set-cookie: color=red
<
{
  "product": {
    "id": 0,
    "name": "Producto respaldo",
    "price": 0,
    "createAt": "2025-04-11T12:32:12.8803183",
    "port": 0
  },
  "quantity": 1,
  "total": 0
}
````

## Configurando Timeout

El `TimeLimiter` nos permite establecer un tiempo máximo para que una llamada responda. Si el tiempo límite se supera,
se considera que la llamada ha fallado, aunque no haya habido una excepción real en el servicio. Esto es superútil
para evitar que llamadas lentas bloqueen tu sistema.

````yml
resilience4j.circuitbreaker:
  configs:
    shared:
      slidingWindowSize: 6
      failureRateThreshold: 50
      waitDurationInOpenState: 20s
      permittedNumberOfCallsInHalfOpenState: 4
      slowCallRateThreshold: 50
      slowCallDurationThreshold: 2s
  instances:
    items:
      baseConfig: shared

resilience4j.timelimiter:
  configs:
    shared:
      timeoutDuration: 2s
  instances:
    items:
      baseConfig: shared
````

Estás diciendo:

- Tengo una configuración base llamada `shared` que limita el tiempo de ejecución de las llamadas a `2 segundos`.
- La instancia llamada `items` aplicará esta configuración.

Entonces, si la llamada tarda más de 2 segundos, se considera fallida y se dispara el fallback (si está definido),
aunque no haya ninguna excepción interna.

## La anotación @CircuitBreaker

La anotación `@CircuitBreaker` de `Resilience4j` es una forma declarativa (más sencilla y limpia) de aplicar la
lógica de `Circuit Breaker` directamente sobre métodos, sin necesidad de usar `CircuitBreakerFactory`.

La anotación `@CircuitBreaker` permite que un método esté protegido por un `circuit breaker`, de modo que si el
servicio comienza a fallar repetidamente (o tarda demasiado en responder), se corta la llamada automáticamente
para proteger el sistema.

La anotación `@CircuitBreaker` tiene dos parámetros importantes:

- `name`, el nombre de la instancia definida en el `application.yml`. Por ejemplo, en nuestro caso creamos en el `yml`
  una instancia llamada `items`.
- `fallbackMethod`, el nombre de un método alternativo que se llama si la llamada falla o se corta.

**Nota**
> Si usamos la anotación `@CircuitBreaker` la configuración que usará será la que definamos en el `application.yml`
> y no la que hicimos de forma programática.

Recordar que para que las anotaciones como el `@CircuitBreaker` funcionen, necesitamos agregar la siguiente dependencia
al `pom.xml`.

````xml

<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-aop</artifactId>
</dependency>
````

Vamos a ver cómo funciona la anotación `@CircuitBreaker`. El valor de `name` fue lo que configuramos en el
`application.yml` como `items`. Ahora, el `fallbackMethod` define el nombre del método que se ejecutará como
alternativa cuando el flujo normal falle.

````java

@Slf4j
@RestController
@RequestMapping(path = "/api/v1/items")
public class ItemController {
    /* code */

    @CircuitBreaker(name = "items", fallbackMethod = "fallbackMethod")
    @GetMapping(path = "/cb/{productId}")
    public ResponseEntity<Item> showItem(@PathVariable Long productId, @RequestParam int quantity) {
        return ResponseEntity.ok(this.itemService.findItemByProductId(productId, quantity));
    }

    private ResponseEntity<Item> fallbackMethod(Long productId, int quantity, Throwable throwable) {
        log.info("Dentro del fallbackMethod(), error: {}", throwable.getMessage());
        log.info("productId: {}, quantity: {}", productId, quantity);
        Product product = new Product(0L, "Producto respaldo desde fallbackMethod()", BigDecimal.ZERO, LocalDateTime.now(), 0);
        Item item = new Item(product, 1);
        return ResponseEntity.ok(item);
    }
}
````

El `fallbackMethod`, es un método de respaldo que se ejecuta cuando el método protegido por el `@CircuitBreaker` falla.
Esto incluye:

- Fallos por excepciones
- Fallos por timeout si estás usando `TimeLimiter`
- Cuando el circuito está abierto

Su objetivo es devolver una respuesta alternativa, evitando que el error se propague al cliente y degradando el servicio
de forma controlada.

#### Reglas para definir un fallbackMethod

- Debe estar en la misma clase donde se aplica el `@CircuitBreaker`. El método de fallback obligatoriamente debe estar
  en la misma clase. No puedes moverlo a otra clase, porque la anotación lo busca dentro del mismo bean (mismo objeto
  Spring).
- Debe tener el mismo nombre que se indica en `fallbackMethod = "fallbackMethod"`.
- Debe aceptar los mismos parámetros del método original, más uno extra al final de tipo `Throwable` (para capturar el
  error).
- El orden de los parámetros debe coincidir exactamente.
- Debe devolver el mismo tipo de respuesta que el método original.

### 4 request con errores

Observamos que al procesar una solicitud con error, nos retorna el objeto que genera el método de respaldo
`fallbakMethod`.

````bash
$ curl -v -G --data "quantity=10" http://localhost:8090/api/v1/items/cb/10 | jq
>
< HTTP/1.1 200 OK
< transfer-encoding: chunked
< Content-Type: application/json
< Date: Fri, 11 Apr 2025 20:43:08 GMT
< token-response: 123456
< X-Response-color: green
< set-cookie: color=red
<
{
  "product": {
    "id": 0,
    "name": "Producto respaldo desde fallbackMethod()",
    "price": 0,
    "createAt": "2025-04-11T15:43:08.1063573",
    "port": 0
  },
  "quantity": 1,
  "total": 0
}
````

### 2 request con éxito

````bash
$ curl -v -G --data "quantity=10" http://localhost:8090/api/v1/items/cb/1 | jq
>
< HTTP/1.1 200 OK
< transfer-encoding: chunked
< Content-Type: application/json
< Date: Fri, 11 Apr 2025 20:43:22 GMT
< token-response: 123456
< X-Response-color: green
< set-cookie: color=red
<
{
  "product": {
    "id": 1,
    "name": "Panasonic",
    "price": 800.00,
    "createAt": "2025-04-11T15:40:23",
    "port": 61974
  },
  "quantity": 10,
  "total": 8000.00
}
````

### Request #7, el Circuit Breaker se mantiene en estado abierto

Anteriormente, se han realizado `4 request con errores` y `2 request con éxito`, por lo tanto, en este request, que
es el `request #7` nos retornará el objeto del método alternativo, dado que la `tasa de errores` sobre la base de
6 elementos (`slidingWindowSize`) configurados en el `application.yml` es más del `50%`.

````bash
$ curl -v -G --data "quantity=10" http://localhost:8090/api/v1/items/cb/1 | jq
>
< HTTP/1.1 200 OK
< transfer-encoding: chunked
< Content-Type: application/json
< Date: Fri, 11 Apr 2025 20:43:29 GMT
< token-response: 123456
< X-Response-color: green
< set-cookie: color=red
<
{
  "product": {
    "id": 0,
    "name": "Producto respaldo desde fallbackMethod()",
    "price": 0,
    "createAt": "2025-04-11T15:43:29.6704938",
    "port": 0
  },
  "quantity": 1,
  "total": 0
}
````

## La anotación @TimeLimiter

`@TimeLimiter` se asegura de que el método anotado no tarde más de cierto tiempo en completarse. Si se pasa del tiempo
configurado (en nuestro caso ese tiempo está configurado en el `application.yml`, en la instancia `items`), se
interrumpe la ejecución y se llama al método fallback `fallbackMethod2()`.

````java

@Slf4j
@RestController
@RequestMapping(path = "/api/v1/items")
public class ItemController {

    /* code */

    @TimeLimiter(name = "items", fallbackMethod = "fallbackMethod2")
    @GetMapping(path = "/cb-2/{productId}")
    public CompletableFuture<ResponseEntity<Item>> showItem2(@PathVariable Long productId, @RequestParam int quantity) {
        return CompletableFuture.supplyAsync(() -> ResponseEntity.ok(this.itemService.findItemByProductId(productId, quantity)));
    }

    private CompletableFuture<ResponseEntity<Item>> fallbackMethod2(Long productId, int quantity, Throwable throwable) {
        log.info("Dentro del fallbackMethod2(), error: {}", throwable.getMessage());
        log.info("productId: {} - quantity: {}", productId, quantity);
        Product product = new Product(0L, "Producto respaldo desde fallbackMethod2()", BigDecimal.ZERO, LocalDateTime.now(), 0);
        Item item = new Item(product, 1);
        return CompletableFuture.supplyAsync(() -> ResponseEntity.ok(item));
    }
}
````

- `name = "items"`, usa la configuración `items` definida en el `application.yml`.
- `CompletableFuture<>`, obligatorio cuando usas `@TimeLimiter`. **¿Por qué?** Porque `@TimeLimiter` necesita trabajar
  con algo asíncrono que se pueda `cancelar/interrumpir` si tarda mucho.
- `fallbackMethod2(...)`, se ejecuta si se supera el `timeoutDuration` o si ocurre otra excepción durante la ejecución.

En la siguiente ejecución vemos el funcionamiento del `@TimeLimiter`.

````bash
$ curl -v -G --data "quantity=10" http://localhost:8090/api/v1/items/cb-2/5 | jq
>
< HTTP/1.1 200 OK
< transfer-encoding: chunked
< Content-Type: application/json
< Date: Fri, 11 Apr 2025 21:56:21 GMT
< token-response: 123456
< X-Response-color: green
< set-cookie: color=red
<
{
  "product": {
    "id": 0,
    "name": "Producto respaldo desde fallbackMethod2()",
    "price": 0,
    "createAt": "2025-04-11T16:56:20.9758463",
    "port": 0
  },
  "quantity": 1,
  "total": 0
}
````

## Spring Cloud Gateway con Resilience4J

Agregamos la dependencia reactiva de `Resilience4j` al `pom.xml` del `gateway-server`.

````xml

<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-circuitbreaker-reactor-resilience4j</artifactId>
</dependency>
````

Ahora, vamos a agregar en el `application.yml` del `gateway-server` las configuraciones del `circuitbreaker` y del
`timelimiter` creando la instancia llamada `products`. Esta instancia será la que aplicaremos en la ruta
`product-service-route` a través del filtro llamado `CircuitBreaker`.

````yml

spring:
  application:
    name: gateway-server
  cloud:
    gateway:
      routes:
        - id: product-service-route
          uri: lb://product-service
          predicates:
            - Path=/api/v1/products/**
          filters:
            - name: CircuitBreaker
              args:
                name: products
                statusCodes: 500, 400
                fallbackUri: forward:/api/v1/items/fallback

resilience4j.circuitbreaker:
  configs:
    shared:
      slidingWindowSize: 6
      failureRateThreshold: 50
      waitDurationInOpenState: 20s
      permittedNumberOfCallsInHalfOpenState: 4
      slowCallRateThreshold: 50
      slowCallDurationThreshold: 2s
  instances:
    products:
      baseConfig: shared

resilience4j.timelimiter:
  configs:
    shared:
      timeoutDuration: 2s
  instances:
    products:
      baseConfig: shared
````

En la configuración anterior vemos nuestro `CircuitBreaker` configurado en un filtro dentro de la ruta de
`product-service-route`. Esto le indica a `Spring Cloud Gateway` que:

- Cuando se haga una petición a `/api/v1/products/**`, se aplique un `Circuit Breaker` llamado `products`.
- Si la respuesta `HTTP` del servicio `product-service` es un `500` o un `400`, se contará como fallo para el
  `Circuit Breaker`.

En `Spring Cloud Gateway`, por defecto, solo los errores `5xx` son considerados fallos. Pero en mi caso, el servicio
lanza un `400 BAD_REQUEST`, no se activa el `Circuit Breaker` a menos que lo pongas explícitamente en `statusCodes`,
como lo hicimos en la configuración anterior. Como hemos incluido ambos `(500 y 400)`, el `Circuit Breaker` podrá
activarse si ocurre cualquiera de estos dos errores.

Con respecto al `fallbackUri: forward:/api/v1/items/fallback`, definimos un endpoint de otro microservicio (no en el que
se produjo el error, si no se creará un loop). En nuestro caso, definimos el endpoint en el `item-service`.

````java

@Slf4j
@RestController
@RequestMapping(path = "/api/v1/items")
public class ItemController {

    /* code */

    @GetMapping(path = "/fallback")
    public ResponseEntity<Item> fallbackItem() {
        Product product = new Product(0L, "Fallback desde Gateway", BigDecimal.ZERO, LocalDateTime.now(), 0);
        return ResponseEntity.ok(new Item(product, 1));
    }
}
````

Cuando una llamada al `product-service` falla, y el código de estado coincide con los definidos en
`statusCodes (500, 400)`, el `Circuit Breaker` entra en acción. En ese momento, `Spring Cloud Gateway` redirige
internamente la petición al URI que definimos como fallback `forward:/api/v1/items/fallback`.

Esta redirección no pasa por el balanceador de carga ni hace otra petición HTTP externa, simplemente ejecuta ese
endpoint local dentro del `Gateway` o un servicio detrás de él si está mapeado.

#### Consideraciones importantes

1. El fallback URI debe existir (por ejemplo, en un controlador dentro del mismo Gateway o en algún microservicio
   accesible). No debe apuntar al mismo microservicio que falló, es decir, no debes redirigir la petición al
   `product-service` si es precisamente ese el que está caído o inestable. Eso rompería por completo el propósito del
   `Circuit Breaker`.
2. No puede depender de query params, a menos que los recibas como opcionales o los reconstruyas tú.
3. Si tu fallback es muy dinámico (por ejemplo, necesita saber el productId o la quantity original), deberías
   considerar:
    - Usar una lambda/gateway filter que capture los datos originales.
    - O usar un fallback general como ya hiciste y mostrar info estática o por defecto.

### 4 request con errores

Observamos que al procesar una solicitud con error, nos retorna el error 500, dado que no hemos configurado ningún
método o llamada `fallback`.

````bash
$ curl -v http://localhost:8090/api/v1/products/10 | jq
>
< HTTP/1.1 200 OK
< transfer-encoding: chunked
< token-response: 123456
< Content-Type: application/json
< Date: Fri, 11 Apr 2025 23:06:17 GMT
< token-response: 123456
< X-Response-color: green
< set-cookie: color=red
< set-cookie: color=red
<
{
  "product": {
    "id": 0,
    "name": "Fallback desde Gateway",
    "price": 0,
    "createAt": "2025-04-11T18:06:17.5137268",
    "port": 0
  },
  "quantity": 1,
  "total": 0
}
````

### 2 request con éxito

````bash
$ curl -v http://localhost:8090/api/v1/products/1 | jq
>
< HTTP/1.1 200 OK
< transfer-encoding: chunked
< Content-Type: application/json
< Date: Fri, 11 Apr 2025 23:06:52 GMT
< token-response: 123456
< set-cookie: color=red
< set-cookie: userCookie=magadiflo
<
{
  "id": 1,
  "name": "Panasonic",
  "price": 800.00,
  "createAt": "2025-04-11T17:44:25",
  "port": 63688
}
````

### Request #7, el Circuit Breaker se mantiene en estado abierto

Anteriormente, se han realizado `4 request con errores` y `2 request con éxito`, por lo tanto, en este request, que
es el `request #7` nos seguirá mostrando error, a pesar de que la petición lleve datos correctos, esto es porque la
`tasa de errores` sobre la base de 6 elementos (`slidingWindowSize`) configurados en el `application.yml`
es más del `50%`.

````bash
$ curl -v http://localhost:8090/api/v1/products/1 | jq
>
< HTTP/1.1 200 OK
< transfer-encoding: chunked
< Content-Type: application/json
< Date: Fri, 11 Apr 2025 23:07:31 GMT
< token-response: 123456
< X-Response-color: green
< set-cookie: color=red
<
{
  "product": {
    "id": 0,
    "name": "Fallback desde Gateway",
    "price": 0,
    "createAt": "2025-04-11T18:07:31.025286",
    "port": 0
  },
  "quantity": 1,
  "total": 0
}
````
