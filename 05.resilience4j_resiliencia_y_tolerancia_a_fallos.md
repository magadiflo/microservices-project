# Sección 05: Resilience4j (Resiliencia y tolerancia a fallos)

---

## Introducción a Circuit Breaker (cortocircuito)

El patrón `Circuit Breaker` es una técnica de diseño para manejar fallos en sistemas distribuidos, como los
microservicios, y `Resilience4j` es una biblioteca que implementa este patrón en Java.

Un `Circuit Breaker` (o interruptor de circuito) es un patrón de diseño que protege un sistema de fallos repetidos. Su
funcionamiento es muy similar a un interruptor eléctrico:

1. `Cerrado (Closed)`: Cuando el sistema está funcionando correctamente, el interruptor está cerrado y las solicitudes
   pasan normalmente.

2. `Abierto (Open)`: Si se detectan fallos repetidos (por ejemplo, un servicio no responde), el interruptor se abre y
   las solicitudes no se envían al servicio. En su lugar, el sistema puede devolver una respuesta predeterminada o
   realizar una acción alternativa.

3. `Semi-abierto (Half-Open)`: Después de un periodo de tiempo, el `Circuit Breaker` permite algunas solicitudes de
   prueba (de forma controlada) para ver si el servicio ha recuperado su estabilidad. Si estas solicitudes tienen éxito,
   el circuito se cierra completamente; si fallan, el circuito se abre de nuevo.

![01.png](assets/section-05/01.png)

## Resilience4j

`Resilience4j` es una librería ligera que permite implementar este patrón en Java, y tiene muchas características
útiles como:

- `Circuit Breaker`: Maneja fallos de servicios externos.
- `Rate Limiter`: Limita la cantidad de solicitudes por unidad de tiempo.
- `Retry`: Vuelve a intentar operaciones fallidas.
- `Bulkhead`: Limita el daño de fallos a una parte del sistema.
- `TimeLimiter`: Limita el tiempo de ejecución de operaciones asíncronas.

## Parámetros del Circuit Breaker

- `slidingWindowSize (100)`, el tamaño de la ventana deslizante es por defecto de 100 peticiones. Es decir, se va a
  trabajar con base en 100 solicitudes para determinar la taza de fallos y éxitos.
- `failureRateThreshold(50)`, representa el porcentaje de falla, es el umbral de fallos que por defecto es del `50%`. Es
  decir, si de los 100 request (`slidingWindowSize`) fallan el 50%, entonces se abre el cortocircuito `OPEN`. Después de
  60 segundos (por defecto) pasa al estado semiabierto `HALF_OPEN`. Estando en estado semiabierto realiza peticiones de
  prueba para verificar si el servicio sigue fallando o ya no, de esa forma ver si se regresa a `OPEN` o pasa a
  `CLOSED`.
- `waitDurationInOpenState (60000ms)`, tiempo de duración en el que permanece en estado `OPEN`, por defecto es de 60
  segundos (60000ms).
- `permittedNumberOfCallsInHalfOpenState(10)`, número permitido de llamadas en estado `HALF_OPEN`, por defecto, son 10.
  Ahora, si el porcentaje de fallas en este estado `HALF_OPEN` supera el 50% (`failureRateThreshold`) entonces seguimos
  en estado `OPEN`, pero si las fallas son menores al 50%, entonces se consiera que es momento de regresar al estado
  `CLOSED`. Por ejemplo, si de las 10 llamadas, 2 son de fallo y 8 son de éxito, entonces se pasa al estado `CLOSED`, ya
  que es mayor al 50% la tasa de éxito.
- `slowCallRateThreshold(100)`, umbral cuando la llamada es lenta.
- `slowCallDurationThreshold(60000ms)`, se considera que una llamada es lenta si tiene esta duración de 60000ms.

## Configurando microservicio items con Resilience4j

Para ver el funcionamiento del `Resilience4j` desde nuestro `item-service` necesitamos modificar el `product-service`
para simular comportamientos cuando se hagan llamadas a ese microservicio.

### En el product-service

En nuestro `product-service` crearemos una nueva constante llamada `ILLEGAL_STATE_EXCEPTION`.

````java

@UtilityClass
public class ProductConstant {
    public static final String NO_SUCH_ELEMENT_MESSAGE = "The product with id %d does not exist";
    public static final String ILLEGAL_STATE_EXCEPTION = "Hay un error con el producto con id %d";
}
````

En el manejador de excepciones del `product-service`, capturamos la excepción `IllegalStateException` que será el que
enviemos al cliente cuando ocurra un error simulado al estar probando el `circuit breaker`.

````java

@RestControllerAdvice
public class GlobalExceptionHandler {

    @ExceptionHandler(NoSuchElementException.class)
    public ResponseEntity<ErrorResponse> apiException(NoSuchElementException exception, HttpServletRequest request) {
        ErrorResponse error = new ErrorResponse(HttpStatus.NOT_FOUND.value(), HttpStatus.NOT_FOUND.getReasonPhrase(), exception.getMessage(), request.getRequestURI());
        return ResponseEntity.status(HttpStatus.NOT_FOUND).body(error);
    }

    @ExceptionHandler(IllegalStateException.class)
    public ResponseEntity<ErrorResponse> apiException(IllegalStateException exception, HttpServletRequest request) {
        ErrorResponse error = new ErrorResponse(HttpStatus.BAD_REQUEST.value(), HttpStatus.BAD_REQUEST.getReasonPhrase(), exception.getMessage(), request.getRequestURI());
        return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(error);
    }

    @ExceptionHandler(Exception.class)
    public ResponseEntity<ErrorResponse> apiException(Exception exception, HttpServletRequest request) {
        ErrorResponse error = new ErrorResponse(HttpStatus.INTERNAL_SERVER_ERROR.value(), HttpStatus.INTERNAL_SERVER_ERROR.getReasonPhrase(), exception.getMessage(), request.getRequestURI());
        return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(error);
    }
}
````

En el controlador del `product-service` agregamos condicionales para que en función del valor del `productId` lancemos
una `excepción` o simulemos un `timeout`.

````java

@Slf4j
@RequiredArgsConstructor
@RestController
@RequestMapping(path = "/api/v1/products")
public class ProductController {

    private final ProductService productService;

    /* code */

    @GetMapping(path = "/{productId}")
    public ResponseEntity<ProductResponse> findProduct(@PathVariable Long productId) throws InterruptedException {
        if (productId.equals(10L)) {
            throw new IllegalStateException(ProductConstant.ILLEGAL_STATE_EXCEPTION.formatted(productId));
        }

        if (productId.equals(5L)) {
            TimeUnit.SECONDS.sleep(5);
        }
        return ResponseEntity.ok(this.productService.findProduct(productId));
    }

    /* code */
}
````

### En el item-service

Ahora, en el `item-service` agregamos la dependencia del `Resilience4j`.

````xml

<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-circuitbreaker-resilience4j</artifactId>
</dependency>
````

En el controlador del `item-service` inyectamos el `CircuitBreakerFactory` que luego será utilizado en el endpoint
`findProduct()`. La respuesta que enviemos al cliente será envuelta en el `CircuitBreakerFactory` inyectado, de tal
manera que, si la llamada que se hace con `this.itemService.findItemByProductId(productId, quantity)` al microservicio
de productos es exitosa, se regresa el `ResponseEntity.ok` con el objeto obtenido. En caso de que ocurra un fallo en la
llamada, pues se ejecutará el siguiente parámetro del `run()` que es una función `fallback`, es decir, como camino
alternativo al ocurrir la falla se ejecutará dicha función que en nuestro caso es regresar un
`ResponseEntity.status(HttpStatus.RESET_CONTENT)...`.

````java

@Slf4j
@RestController
@RequestMapping(path = "/api/v1/items")
public class ItemController {

    private final ItemService itemService;
    private final CircuitBreakerFactory circuitBreakerFactory;

    public ItemController(@Qualifier("itemServiceWithRestClientImpl") ItemService itemService,
                          CircuitBreakerFactory circuitBreakerFactory) {
        this.itemService = itemService;
        this.circuitBreakerFactory = circuitBreakerFactory;
    }

    /* code */

    @GetMapping(path = "/{productId}")
    public ResponseEntity<Item> findProduct(@PathVariable Long productId, @RequestParam int quantity) {
        Product product = new Product(0L, "Producto respaldo", BigDecimal.ZERO, LocalDateTime.now(), 0);
        Item item = new Item(product, 1);

        return this.circuitBreakerFactory
                .create("items")        //1
                .run(
                        () -> {         //2
                            log.info("Llamada exitosa al product-service");
                            return ResponseEntity.ok(this.itemService.findItemByProductId(productId, quantity));
                        },
                        throwable -> {  //3
                            log.warn("Error cuando se llamó al product-service, se envía información alternativa");
                            return ResponseEntity.status(HttpStatus.RESET_CONTENT).body(item);
                        }
                );
    }
}
````

`CircuitBreakerFactory` es una fábrica de circuit breakers que provee `Spring Cloud Circuit Breaker`. Te permite crear y
personalizar circuit breakers de forma programática, sin necesidad de usar anotaciones como `@CircuitBreaker`. Muy útil
cuando quieres más control o necesitas diferentes comportamientos en distintos puntos de tu código.

1. `create("items")`

- Crea un `Circuit Breaker` con nombre `items`.
- Este nombre debe estar relacionado con tu configuración en el `application.yml` (donde defines cosas como
  `failureRateThreshold`, `slidingWindowSize`, etc.).
- Si no lo configuras explícitamente, usará los valores por defecto.

2. `run(Supplier<T> runnable, Function<Throwable, T> fallback)`

- `Primer parámetro`: lo que quieres que se intente ejecutar (la lógica principal).
- `Segundo parámetro`: una función de fallback que se ejecuta si:
    - El circuito está en estado `OPEN`.
    - La lógica principal lanza una excepción.

3. `Fallback (throwable -> {...})`

- Si por ejemplo `product-service` está caído o responde con error, este bloque se ejecuta.
- En tu ejemplo, se devuelve un producto de respaldo `("Producto respaldo")`.

#### Ventajas de usar CircuitBreakerFactory así

- Puedes manejar errores más detalladamente sin depender del manejo automático por anotaciones.
- Ideal para personalizar diferentes fallbacks, por ejemplo, dependiendo del tipo de error o el circuito.
- Muy útil cuando tu lógica está fuera del alcance de los AOP (como métodos privados o lambdas).

