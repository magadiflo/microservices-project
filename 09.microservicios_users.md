# Sección 09: Microservicio users

---

## Creando el user-service

Creamos el nuevo microservicio `item-service` desde
[Spring Initializr](https://start.spring.io/#!type=maven-project&language=java&platformVersion=3.4.4&packaging=jar&jvmVersion=21&groupId=dev.magadiflo&artifactId=user-service&name=user-service&description=User%20Service&packageName=dev.magadiflo.user.app&dependencies=actuator,web,data-jpa,lombok,postgresql,cloud-eureka,cloud-config-client).

````xml
<!--Spring Boot 3.4.4-->
<!--Spring Cloud 2024.0.1-->
<!--Java 21-->
<dependencies>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-actuator</artifactId>
    </dependency>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-data-jpa</artifactId>
    </dependency>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-web</artifactId>
    </dependency>
    <dependency>
        <groupId>org.springframework.cloud</groupId>
        <artifactId>spring-cloud-starter-config</artifactId>
    </dependency>
    <dependency>
        <groupId>org.springframework.cloud</groupId>
        <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>
    </dependency>

    <dependency>
        <groupId>org.postgresql</groupId>
        <artifactId>postgresql</artifactId>
        <scope>runtime</scope>
    </dependency>
    <dependency>
        <groupId>org.projectlombok</groupId>
        <artifactId>lombok</artifactId>
        <optional>true</optional>
    </dependency>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-test</artifactId>
        <scope>test</scope>
    </dependency>
</dependencies>
````

## Creando entity User y repositorio JPA

En nuestro `user-service` creamos la entidad `User`.

````java

@AllArgsConstructor
@NoArgsConstructor
@Builder
@Data
@Entity
@Table(name = "users")
public class User {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    @Column(unique = true)
    private String username;
    private String password;
    private boolean enabled;
    @Column(unique = true)
    private String email;
}
````

Creamos el repositorio para la entidad `User` donde definimos dos métodos utilizando los `Query Methods` de
`Spring Data Jpa`.

````java
public interface UserRepository extends JpaRepository<User, Long> {
    Optional<User> findByUsername(String username);

    Optional<User> findByEmail(String email);
}
````

## Implementando componente service

En este apartado implementaremos la capa de servicio del `user-service`, eso implica que debemos crear clases de
utilitario, dtos, constantes, etc.

Creamos una clase que contendrá las distintas constantes para nuestro microservicio.

````java

@UtilityClass
public class UserConstant {
    public static final String NO_SUCH_ELEMENT_MESSAGE = "The user with id %d does not exist";
    public static final String NO_SUCH_USERNAME_MESSAGE = "The user with username %s does not exist";
    public static final String ILLEGAL_STATE_EXCEPTION = "There is an error with the user with id %d";
}
````

Creamos nuestras clases que manejarán las excepciones.

````java
public record ErrorResponse(int status,
                            String error,
                            String message,
                            String path) {
    @JsonProperty
    public LocalDateTime timestamp() {
        return LocalDateTime.now().truncatedTo(ChronoUnit.SECONDS);
    }
}
````

````java

@RestControllerAdvice
public class GlobalExceptionHandler {

    @ExceptionHandler(NoSuchElementException.class)
    public ResponseEntity<ErrorResponse> apiException(NoSuchElementException exception, HttpServletRequest request) {
        ErrorResponse error = new ErrorResponse(HttpStatus.NOT_FOUND.value(), HttpStatus.NOT_FOUND.getReasonPhrase(), exception.getMessage(), request.getRequestURI());
        return ResponseEntity.status(HttpStatus.NOT_FOUND).body(error);
    }

    @ExceptionHandler(IllegalStateException.class)
    public ResponseEntity<ErrorResponse> apiException(IllegalStateException exception, HttpServletRequest request) {
        ErrorResponse error = new ErrorResponse(HttpStatus.BAD_REQUEST.value(), HttpStatus.BAD_REQUEST.getReasonPhrase(), exception.getMessage(), request.getRequestURI());
        return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(error);
    }

    @ExceptionHandler(Exception.class)
    public ResponseEntity<ErrorResponse> apiException(Exception exception, HttpServletRequest request) {
        ErrorResponse error = new ErrorResponse(HttpStatus.INTERNAL_SERVER_ERROR.value(), HttpStatus.INTERNAL_SERVER_ERROR.getReasonPhrase(), exception.getMessage(), request.getRequestURI());
        return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(error);
    }
}
````

Creamos los siguientes dtos.

````java
public record UserRequest(String username,
                          String password,
                          String email) {
}
````

````java
public record UserResponse(Long id,
                           String username,
                           boolean enabled,
                           String email) {
}
````

````java
public record UserEnabledRequest(boolean enabled) {
}
````

Creamos una clase mapeadora para convertir dto a entity y viceversa.

````java

@Component
public class UserMapper {
    public UserResponse toUserResponse(User user) {
        return new UserResponse(user.getId(), user.getUsername(), user.isEnabled(), user.getEmail());
    }

    public User toUser(UserRequest request) {
        return User.builder()
                .username(request.username())
                .password(request.password())
                .email(request.email())
                .build();
    }

    public User toUpdateUser(User user, UserRequest request) {
        user.setUsername(request.username());
        user.setEmail(request.email());
        return user;
    }

    public User toUpdateUserEnabled(User user, UserEnabledRequest userEnabledRequest) {
        user.setEnabled(userEnabledRequest.enabled());
        return user;
    }
}
````

Finalmente, creamos la clase de servicio junto a su intefaz.

````java
public interface UserService {
    List<UserResponse> findUsers();

    UserResponse findUser(Long userId);

    UserResponse findUserByUsername(String username);

    UserResponse saveUser(UserRequest userRequest);

    UserResponse updateUser(Long userId, UserRequest userRequest);

    void deleteUser(Long userId);

    UserResponse updateUserEnabled(Long userId, UserEnabledRequest userEnabledRequest);
}
````

````java

@Slf4j
@RequiredArgsConstructor
@Service
@Transactional(readOnly = true)
public class UserServiceImpl implements UserService {

    private final UserRepository userRepository;
    private final UserMapper userMapper;

    @Override
    public List<UserResponse> findUsers() {
        return this.userRepository.findAll().stream()
                .map(this.userMapper::toUserResponse)
                .toList();
    }

    @Override
    public UserResponse findUser(Long userId) {
        return this.userRepository.findById(userId)
                .map(this.userMapper::toUserResponse)
                .orElseThrow(() -> new NoSuchElementException(UserConstant.NO_SUCH_ELEMENT_MESSAGE.formatted(userId)));
    }

    @Override
    public UserResponse findUserByUsername(String username) {
        return this.userRepository.findByUsername(username)
                .map(this.userMapper::toUserResponse)
                .orElseThrow(() -> new NoSuchElementException(UserConstant.NO_SUCH_USERNAME_MESSAGE.formatted(username)));
    }

    @Override
    @Transactional
    public UserResponse saveUser(UserRequest userRequest) {
        User userDB = this.userRepository.save(this.userMapper.toUser(userRequest));
        return this.userMapper.toUserResponse(userDB);
    }

    @Override
    @Transactional
    public UserResponse updateUser(Long userId, UserRequest userRequest) {
        return this.userRepository.findById(userId)
                .map(userDB -> this.userMapper.toUpdateUser(userDB, userRequest))
                .map(this.userRepository::save)
                .map(this.userMapper::toUserResponse)
                .orElseThrow(() -> new NoSuchElementException(UserConstant.NO_SUCH_ELEMENT_MESSAGE.formatted(userId)));
    }

    @Override
    @Transactional
    public void deleteUser(Long userId) {
        User userDB = this.userRepository.findById(userId)
                .orElseThrow(() -> new NoSuchElementException(UserConstant.NO_SUCH_ELEMENT_MESSAGE.formatted(userId)));
        this.userRepository.deleteById(userDB.getId());
    }

    @Override
    @Transactional
    public UserResponse updateUserEnabled(Long userId, UserEnabledRequest userEnabledRequest) {
        return this.userRepository.findById(userId)
                .map(userDB -> this.userMapper.toUpdateUserEnabled(userDB, userEnabledRequest))
                .map(this.userRepository::save)
                .map(this.userMapper::toUserResponse)
                .orElseThrow(() -> new NoSuchElementException(UserConstant.NO_SUCH_ELEMENT_MESSAGE.formatted(userId)));
    }
}
````

## Implementando controlador rest

Implementamos nuestro controlador rest para el `user-service`.

````java

@Slf4j
@RequiredArgsConstructor
@RestController
@RequestMapping(path = "/api/v1/users")
public class UserController {

    private final UserService userService;

    @GetMapping
    public ResponseEntity<List<UserResponse>> findUsers() {
        return ResponseEntity.ok(this.userService.findUsers());
    }

    @GetMapping(path = "/{userId}")
    public ResponseEntity<UserResponse> findUser(@PathVariable Long userId) {
        return ResponseEntity.ok(this.userService.findUser(userId));
    }

    @GetMapping(path = "/username/{username}")
    public ResponseEntity<UserResponse> findUserByUsername(@PathVariable String username) {
        return ResponseEntity.ok(this.userService.findUserByUsername(username));
    }

    @PostMapping
    public ResponseEntity<UserResponse> saveUser(@RequestBody UserRequest userRequest) {
        UserResponse userResponse = this.userService.saveUser(userRequest);
        URI location = URI.create("/api/v1/users/%d".formatted(userResponse.id()));
        return ResponseEntity.created(location).body(userResponse);
    }

    @PutMapping(path = "/{userId}")
    public ResponseEntity<UserResponse> updateUser(@PathVariable Long userId, @RequestBody UserRequest userRequest) {
        return ResponseEntity.ok(this.userService.updateUser(userId, userRequest));
    }

    @DeleteMapping(path = "/{userId}")
    public ResponseEntity<Void> deleteUser(@PathVariable Long userId) {
        this.userService.deleteUser(userId);
        return ResponseEntity.noContent().build();
    }

    @PatchMapping(path = "/{userId}/enabled")
    public ResponseEntity<UserResponse> updateUserEnabled(@PathVariable Long userId, @RequestBody UserEnabledRequest userEnabledRequest) {
        return ResponseEntity.ok(this.userService.updateUserEnabled(userId, userEnabledRequest));
    }
}
````

## Configurando la conexión a PostgresSQL y creando la tabla users

Agregamos ls siguiente configuración en el `application.yml` del `user-service`. En este archivo estamos configurando
la conexión a `PostgreSQL`, `Eureka client` y `Config Server`.

````yml
server:
  port: 0
  error:
    include-message: always

spring:
  application:
    name: user-service
  profiles:
    active: default
  config:
    import: optional:configserver:http://localhost:8888
  datasource:
    url: jdbc:postgresql://localhost:5432/db_user_service
    username: postgres
    password: magadiflo
  jpa:
    hibernate:
      ddl-auto: update
    properties:
      hibernate:
        format_sql: true
    defer-datasource-initialization: true
  sql:
    init:
      mode: always

eureka:
  instance:
    prefer-ip-address: true
    instance-id: ${spring.cloud.client.hostname}:${spring.application.name}:${random.value}
  client:
    service-url:
      defaultZone: http://localhost:8761/eureka/

logging:
  level:
    org.hibernate.SQL: debug
````

Además, para poblar las tablas he creado el archivo `data.sql` con dos registros a insertar.

````sql
TRUNCATE TABLE users RESTART IDENTITY;

INSERT INTO users(id, username, password, enabled, email)
VALUES(1, 'martin', '123456', true, 'martin@gmail.com'),
(2, 'admin', '123456', true, 'admin@gmail.com');

-- Actualiza la secuencia para que el siguiente valor sea 3
SELECT setval('users_id_seq', 2, true);
````

**Nota**

- Como estamos trabajando con `PostgreSQL` y estamos insertando manualmente dos registros, agregando explícitamente sus
  identificadores, necesitamos actualizar manualmente la secuencia de la clave primaria, para que cuando insertemos
  datos usando `spring dat jpa`, estos puedan continuar con la secuencia, es decir, el siguiente registro a insertar
  tendría el valor `id=3`.
- Para actualizar la secuencia usamos el comando `SELECT setval('users_id_seq', 2, true);`, donde:
    - `users_id_seq`, es el nombre de la secuencia que queremos modificar. `PostgreSQL` crea automáticamente una
      secuencia para cada campo `SERIAL`.
    - `2`, es el nuevo valor actual que establecemos a la secuencia. Es decir, la secuencia recordará este valor como el
      último valor generado.
    - `true`, es el parámetro `is_called`. Cuando usamos `true`, le decimos a `PostgreSQL` que el valor `2` ya se ha
      usado, así que el próximo valor generado será `3`. Si fuera `false`, entonces el siguiente valor generado volvería
      a ser `2`.
- Para obtener el nombre de la secuencia, podemos ejecutar este comando en PostgreSQL:
  `SELECT pg_get_serial_sequence('users', 'id');`, cuyo resultado en nuestro caso es `users_id_seq`.

Ahora, nos apoyaremos del propio `hibernate` para crear la tabla de usuarios en la base de datos a partir de la clase
de entidad `User`, esto es gracias a la configuración `spring.jpa.hibernate.ddl-auto=update`. En seguida, luego de que
`hibernate` haya creado la tabla de usuario se ejecutará nuestro `data.sql`. Esta ejecución diferida es gracias a la
configuración `spring.jpa.defer-datasource-initialization=true` y al `spring.sql.init.mode=always`, es decir, primero
deja que `hibernate` ejecute todo lo que tenga que ejecutar y luego recién ejecuta el `data.sql`.

Para ejecutar nuestro `user-service` debemos previamente ejecutar el `discovery-service` ya que en el `application.yml`
hemos agregado la configuración de `Eureka`. Con respecto a `config-server` no es necesario ejecutarlo, dado que no
tenemos configuraciones en ese servidor para nuestro `user-service`.

A continuación se observa que la tabla se ha creado y poblado correctamente.

![01.png](assets/section-09/01.png)

Como pusimos el puerto aletorio (`server.port=0`), entonces debemos ver en el log qué puerto se generó. Luego, podemos
usar ese puerto para que forme parte de la url para hacer peticiones a nuestro `user-service` (`Nota`. En algunas
peticiones que hago estoy usando puertos distintos porque son pruebas que he estado realizando).

````bash
$ curl -v http://localhost:52860/api/v1/users | jq
>
< HTTP/1.1 200
< Content-Type: application/json
< Transfer-Encoding: chunked
< Date: Tue, 15 Apr 2025 22:24:35 GMT
<
[
  {
    "id": 1,
    "username": "martin",
    "enabled": true,
    "email": "martin@gmail.com"
  },
  {
    "id": 2,
    "username": "admin",
    "enabled": true,
    "email": "admin@gmail.com"
  }
]
````

````bash
$ curl -v http://localhost:52860/api/v1/users/1 | jq
>
< HTTP/1.1 200
< Content-Type: application/json
< Transfer-Encoding: chunked
< Date: Tue, 15 Apr 2025 22:26:01 GMT
<
{
  "id": 1,
  "username": "martin",
  "enabled": true,
  "email": "martin@gmail.com"
}
````

````bash
$ curl -v http://localhost:52860/api/v1/users/username/martin | jq
>
< HTTP/1.1 200
< Content-Type: application/json
< Transfer-Encoding: chunked
< Date: Tue, 15 Apr 2025 22:26:39 GMT
<
{
  "id": 1,
  "username": "martin",
  "enabled": true,
  "email": "martin@gmail.com"
}
````

````bash
$ curl -v -X POST -H "Content-Type: application/json" -d "{\"username\": \"user\", \"password\": \"123456\", \"email\": \"user@gmail.com\"}" http://localhost:52980/api/v1/users | jq
>
< HTTP/1.1 201
< Location: /api/v1/users/3
< Content-Type: application/json
< Transfer-Encoding: chunked
< Date: Tue, 15 Apr 2025 22:37:44 GMT
<
{
  "id": 3,
  "username": "user",
  "enabled": false,
  "email": "user@gmail.com"
}
````

````bash
$ curl -v -X PUT -H "Content-Type: application/json" -d "{\"username\": \"user_home\", \"password\": \"123456home\", \"email\": \"user.home@gmail.com\"}" http://localhost:52980/api/v1/users/3 | jq
>
< HTTP/1.1 200
< Content-Type: application/json
< Transfer-Encoding: chunked
< Date: Tue, 15 Apr 2025 22:41:12 GMT
<
{
  "id": 3,
  "username": "user_home",
  "enabled": false,
  "email": "user.home@gmail.com"
}
````

````bash
$ curl -v -X DELETE http://localhost:52980/api/v1/users/3 | jq
>
< HTTP/1.1 204
< Date: Tue, 15 Apr 2025 22:41:51 GMT
<
````

````bash
$ curl -v -X PATCH -H "Content-Type: application/json" -d "{\"enabled\": false}" http://localhost:56287/api/v1/users/3/enabled | jq
>
< HTTP/1.1 200
< Content-Type: application/json
< Transfer-Encoding: chunked
< Date: Wed, 16 Apr 2025 15:03:58 GMT
<
{
  "id": 3,
  "username": "user",
  "enabled": false,
  "email": "user@gmail.com"
}
````

## Configurando PasswordEncoder BCryptPasswordEncoder

En nuestro `user-service` creamos una clase de configuración donde definimos el bean del `PasswordEncoder`.

````java

@Configuration
public class UserConfig {
    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }
}
````

**Importante**
> Hashear ≠ Cifrar<br>
> Un `hash` es irreversible, es decir: no puedes obtener la contraseña original desde el `hash`.<br>
> Para validar una contraseña, se hashea la que el usuario ingresa y se compara con el hash almacenado en la base de
> datos.<br>

**Resumen**
> Spring Security con `PasswordEncoder` (especialmente con `BCrypt`):<br>
> ✅ Hashea la contraseña (no la codifica ni la cifra)<br>
> ❌ No se puede recuperar la contraseña original<br>
> ✅ Es seguro y recomendado para almacenar contraseñas<br>

Luego, en el `UserMapper` que es donde estamos mapeando un usuario dto a un usuario entity, vamos a inyectar el
`PasswordEncoder` y a usarlo para `hashear la contraseña`.

````java

@RequiredArgsConstructor
@Component
public class UserMapper {

    private final PasswordEncoder passwordEncoder;

    public UserResponse toUserResponse(User user) {
        return new UserResponse(user.getId(), user.getUsername(), user.isEnabled(), user.getEmail());
    }

    public User toUser(UserRequest request) {
        return User.builder()
                .username(request.username())
                .password(this.passwordEncoder.encode(request.password()))
                .enabled(true)
                .email(request.email())
                .build();
    }

    public User toUpdateUser(User user, UserRequest request) {
        user.setUsername(request.username());
        user.setEmail(request.email());
        return user;
    }

    public User toUpdateUserEnabled(User user, UserEnabledRequest userEnabledRequest) {
        user.setEnabled(userEnabledRequest.enabled());
        return user;
    }
}
````

## Creando relación unidireccional entre entity User y Role

Creamos la entidad `Role`.

````java

@AllArgsConstructor
@NoArgsConstructor
@Builder
@Data
@Entity
@Table(name = "roles")
public class Role {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    @Column(unique = true)
    private String name;
}
````

Nuestra entidad `User` será la dueña de la relación (la `entidad propietaria`), por lo tanto, definiremos la relación
en esta entidad.

````java

@AllArgsConstructor
@NoArgsConstructor
@Builder
@Data
@Entity
@Table(name = "users")
public class User {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    @Column(unique = true)
    private String username;
    private String password;
    private boolean enabled;
    @Column(unique = true)
    private String email;

    @JoinTable(
            name = "users_roles",
            joinColumns = @JoinColumn(name = "user_id", referencedColumnName = "id"),
            inverseJoinColumns = @JoinColumn(name = "role_id", referencedColumnName = "id"),
            uniqueConstraints = @UniqueConstraint(columnNames = {"user_id", "role_id"})
    )
    @ManyToMany
    private Set<Role> roles = new HashSet<>();
}
````

**Importante**

- Observemos que en la relación unidireccional `@ManyToMany` no estamos usando el atributo `cascade`.
- Como solo estamos usando la anotación `@ManyToMany` sin ningún atributo, al `guardar` o `actualizar` un `User`, los
  `Role` asociados no se persisten ni se actualizan automáticamente.
- Por lo tanto, si estamos asociando roles nuevos (que aún no existen en la base de datos), lanzará una excepción
  (`TransientPropertyValueException`) porque intenta asociar una entidad (`Role`) que no está persistida aún.
- También, si modificamos un `Role` desde el `User`, esos cambios no se guardarán a menos que explícitamente guardemos
  el `Role`.

| Cascada               | ¿Qué hace?                                                                                         |
|-----------------------|----------------------------------------------------------------------------------------------------|
| `CascadeType.PERSIST` | Si creamos un nuevo `Role` dentro de un `User` y guardamos el `User`, también se guarda el `Role`. |
| `CascadeType.MERGE`   | Si actualizamos un `User` y también hicimos cambios en los `Role`, se actualizan automáticamente.  |
| `Sin cascade`         | Tenemos que guardar/actualizar `Role` por separado, o lanzará error si no existen.                 |

**Recomendación**

- En relaciones `ManyToMany` con entidades como `Role`, **que suelen estar predefinidas y no cambian mucho**,
  normalmente no se recomienda usar `cascade` si los `Roles` son gestionados por separado.
- Así que si los `Roles` ya existen y no se van a crear dinámicamente al mismo tiempo que los `Users`, está bien que
  usemos la anotación `@ManyToMany` sin el atributo `cascade` para evitar efectos colaterales.
- Entonces, en nuestro caso no necesitamos el `cascade`, así evitamos que accidentalmente se creen o modifiquen `Role`
  desde operaciones sobre `User`.

**Ventajas de no usar el cascade en nuestro caso**

- Te aseguras de que los `Role` solo se creen o editen desde el módulo que los gestiona.
- Previenes errores como que al guardar un `User` sin verificar si el `Role` ya existe, se intente crear un `Role`
  duplicado (y lance una excepción por unique constraint).
- Claridad en la lógica: la responsabilidad de manejar los `Role` está claramente separada.

## Creando tablas roles y users_roles

En este apartado crearemos las tablas `roles` y la tabla intermedia `users_roles` apoyándonos de `Spring Data Jpa` y las
anotaciones que usamos en las entidades `Role` y `User`.

Antes de ejecutar la aplicación vamos a modificar el archivo `data.sql` de nuestro `user-service`.

````sql
DELETE FROM users_roles;
DELETE FROM users;
DELETE FROM roles;

INSERT INTO users(id, username, password, enabled, email)
VALUES(1, 'martin', '123456', true, 'martin@gmail.com'),
(2, 'admin', '123456', true, 'admin@gmail.com');

INSERT INTO roles(id, name)
VALUES(1, 'ROLE_USER'),
(2, 'ROLE_ADMIN');

-- Actualiza la secuencia para que el siguiente valor sea 3
SELECT setval('users_id_seq', 2, true);
SELECT setval('roles_id_seq', 2, true);
````

**Donde**

- Hemos cambiado el `TRUNCATE` por `DELETE`. A diferencia de `TRUNCATE`, `DELETE` no afecta la estructura de la tabla
  ni las restricciones de clave foránea. Elimina los registros de las tablas, lo que permite eliminar los datos sin
  violar las restricciones de clave foránea.
- Reinicio de secuencias (`setval`). Reiniciamos las secuencias para que el siguiente valor asignado a los registros
  sea el correcto y no se dupliquen los IDs.

Ejecutamos la aplicación y vemos que las tablas se han creado correctamente en la base de dato.

![02.png](assets/section-09/02.png)

## Asignando Role a User

Cuando creemos un usuario, por defecto vamos a crearlo con el rol `ROLE_USER`, así que tenemos que realizar ciertas
modificaciones a nuestro código.

Creamos un `enum` que contendrá los roles que manejaremos en nuestra aplicación.

````java
public enum Roles {
    ROLE_USER,
    ROLE_ADMIN
}
````

Creamos un repositorio para nuestra entidad `Role` definiéndole un `query method` para obtener la entidad Role a partir
del nombre del rol.

````java
public interface RoleRepository extends JpaRepository<Role, Long> {
    Optional<Role> findByName(String name);
}
````

En nuestra clase concreta `UserServiceImpl` utilizamos el repositorio del rol creado anteriormente para poder consultar
por el rol y poder asignarle al usuario que está siendo creado.

````java

@Slf4j
@RequiredArgsConstructor
@Service
@Transactional(readOnly = true)
public class UserServiceImpl implements UserService {

    private final UserRepository userRepository;
    private final RoleRepository roleRepository;
    private final UserMapper userMapper;

    /* code */

    @Override
    @Transactional
    public UserResponse saveUser(UserRequest userRequest) {
        User userToSave = this.userMapper.toUser(userRequest);
        Optional<Role> roleOptional = this.roleRepository.findByName(Roles.ROLE_USER.name());
        if (roleOptional.isPresent()) {
            Set<Role> roles = new HashSet<>();
            roles.add(roleOptional.get());
            userToSave.setRoles(roles);
        }
        User userDB = this.userRepository.save(userToSave);
        return this.userMapper.toUserResponse(userDB);
    }

    /* code */
}
````

## Asignando Role Admin y organizando lógica de negocio

Iniciaremos con la creación de un mensaje de constante que usaremos más adelante en la clase de servicio.

````java

@UtilityClass
public class UserConstant {
    public static final String NO_SUCH_ELEMENT_MESSAGE = "The user with id %d does not exist";
    public static final String NO_SUCH_USERNAME_MESSAGE = "The user with username %s does not exist";
    public static final String ILLEGAL_STATE_EXCEPTION = "There is an error with the user with id %d";
    public static final String ILLEGAL_STATE_ROLE_EXCEPTION = "One or more roles are invalid";
}
````

Crearemos una clase de enumeración para definir los roles de nuestra aplicación. Adicionalmente, le agregaremos un
método que nos dirá si el rol que buscamos existe o no.

````java
public enum Roles {
    ROLE_USER,
    ROLE_ADMIN;

    public static boolean exists(String roleName) {
        return Arrays.stream(Roles.values())
                .anyMatch(role -> role.name().equals(roleName));
    }
}
````

Es importante crear una clase dto que nos permitirá exponer la información del rol.

````java
public record RoleResponse(Long id,
                           String name) {
}
````

En nuestro dto `UserResponse` agregamos el conjunto de roles que estará asociado a un usuario.

````java
public record UserResponse(Long id,
                           String username,
                           boolean enabled,
                           String email,
                           Set<RoleResponse> roles) {
}
````

En el `UserRequest` agregaremos un atributo booleano `isAdmin` para que cuando un usuario se registre verifiquemos
previamente si será admin o no. En caso no lo sea se le asignará el role de usuario, caso contrario será un
administrador.

````java
public record UserRequest(String username,
                          String password,
                          String email,
                          Boolean isAdmin) {
}
````

En el `UserMapper` agregaremos el método `toUpdateUserRoles()` y modificaremos el método `toUserResponse()`.

````java

@RequiredArgsConstructor
@Component
public class UserMapper {

    private final PasswordEncoder passwordEncoder;

    public UserResponse toUserResponse(User user) {
        Set<RoleResponse> rolesResponse = user.getRoles().stream()
                .map(role -> new RoleResponse(role.getId(), role.getName()))
                .collect(Collectors.toSet());
        return new UserResponse(user.getId(), user.getUsername(), user.isEnabled(), user.getEmail(), rolesResponse);
    }

    public User toUser(UserRequest request) {/* code */}

    public User toUpdateUser(User user, UserRequest request) {/* code */}

    public User toUpdateUserEnabled(User user, UserEnabledRequest userEnabledRequest) {/* code */}

    public User toUpdateUserRoles(User user, Set<Role> roles) {
        user.setRoles(roles);
        return user;
    }
}
````

En el repositorio `RoleRepository` agregamos un nuevo `query method` llamado `findAllByNameIn()` para obtener todos los
roles según el nombre que le pasemos por parámetro.

````java
public interface RoleRepository extends JpaRepository<Role, Long> {
    Set<Role> findAllByNameIn(Collection<String> roleNames);

    Optional<Role> findByName(String name);
}
````

En el `UserService` agregamos dos nuevos métodos `updateUserEnabled()` y `updateUserRoles()`.

````java
public interface UserService {
    List<UserResponse> findUsers();

    UserResponse findUser(Long userId);

    UserResponse findUserByUsername(String username);

    UserResponse saveUser(UserRequest userRequest);

    UserResponse updateUser(Long userId, UserRequest userRequest);

    void deleteUser(Long userId);

    UserResponse updateUserEnabled(Long userId, UserEnabledRequest userEnabledRequest);

    UserResponse updateUserRoles(Long userId, Set<String> roleNames);
}
````

A continuación implementamos en el `UserServiceImpl` los métodos anteriormente definidos en la interfaz.

````java

@Slf4j
@RequiredArgsConstructor
@Service
@Transactional(readOnly = true)
public class UserServiceImpl implements UserService {

    private final UserRepository userRepository;
    private final RoleRepository roleRepository;
    private final UserMapper userMapper;

    /* code */

    @Override
    @Transactional
    public UserResponse saveUser(UserRequest userRequest) {
        User userToSave = this.userMapper.toUser(userRequest);
        String role = userRequest.isAdmin() != null && userRequest.isAdmin() ? Roles.ROLE_ADMIN.name() : Roles.ROLE_USER.name();
        Optional<Role> roleOptional = this.roleRepository.findByName(role);
        if (roleOptional.isPresent()) {
            Set<Role> roles = new HashSet<>();
            roles.add(roleOptional.get());
            userToSave.setRoles(roles);
        }
        User userDB = this.userRepository.save(userToSave);
        return this.userMapper.toUserResponse(userDB);
    }

    /* code */

    @Override
    @Transactional
    public UserResponse updateUserRoles(Long userId, Set<String> roleNames) {
        boolean invalidRoleExists = roleNames.stream()
                .anyMatch(roleName -> !Roles.exists(roleName));

        if (invalidRoleExists) {
            throw new IllegalStateException(UserConstant.ILLEGAL_STATE_ROLE_EXCEPTION);
        }

        Set<Role> rolesDB = this.roleRepository.findAllByNameIn(roleNames);

        return this.userRepository.findById(userId)
                .map(userDB -> this.userMapper.toUpdateUserRoles(userDB, rolesDB))
                .map(this.userRepository::save)
                .map(this.userMapper::toUserResponse)
                .orElseThrow(() -> new NoSuchElementException(UserConstant.NO_SUCH_ELEMENT_MESSAGE.formatted(userId)));
    }
}
````

En el controlador de usuario definimos el endpoint que nos permitirá actualizar los roles del usuario.

````java

@Slf4j
@RequiredArgsConstructor
@RestController
@RequestMapping(path = "/api/v1/users")
public class UserController {

    private final UserService userService;

    /* code */

    @PatchMapping(path = "/{userId}/roles")
    public ResponseEntity<UserResponse> updateUserRoles(@PathVariable Long userId, @RequestBody Set<String> roleNames) {
        return ResponseEntity.ok(this.userService.updateUserRoles(userId, roleNames));
    }
}
````

Finalmente, para tener algunos usuarios con roles vamos a modificar el `data.sql`. Observar que la contraseña que estoy
colocando para ambos registros corresponde a la contraseña `123456` pero hasheada.

````sql
DELETE FROM users_roles;
DELETE FROM users;
DELETE FROM roles;

-- Password: 123456
INSERT INTO users(id, username, password, enabled, email)
VALUES(1, 'admin', '$2a$10$Yg5fqSv6vCGGyf4a6wlOXe9HZVV1EBtcBBKp1KgoF/Ec9j3j2oaPG', true, 'admin@gmail.com'),
(2, 'martin', '$2a$10$DkMNPHecq0S/T.dkC8Wrh.whOH.hvKzbtmMGs9r4NQcM.VvbIqdJy', true, 'martin@gmail.com');

INSERT INTO roles(id, name)
VALUES(1, 'ROLE_ADMIN'),
(2, 'ROLE_USER');

INSERT INTO users_roles(user_id, role_id)
VALUES(1, 1),
(1, 2),
(2, 2);

-- Actualiza la secuencia para que el siguiente valor sea 3
SELECT setval('users_id_seq', 2, true);
SELECT setval('roles_id_seq', 2, true);
````

## Probando creación de usuario y actualización de roles

Levantamos la aplicación `discovery-server` y el `user-service` para realizar las pruebas de registro de usuario y
actualización de roles.

Creamos un usuario sin especificarle el rol que tendrá, así que por defecto le asignará el rol `ROLE_USER`.

````bash
$ curl -v -X POST -H "Content-Type: application/json" -d "{\"username\": \"user\", \"password\": \"123456\", \"email\": \"user@gmail.com\"}" http://localhost:59207/api/v1/users | jq
>
< HTTP/1.1 201
< Location: /api/v1/users/3
< Content-Type: application/json
< Transfer-Encoding: chunked
< Date: Wed, 16 Apr 2025 21:42:39 GMT
<
{
  "id": 3,
  "username": "user",
  "enabled": true,
  "email": "user@gmail.com",
  "roles": [
    {
      "id": 2,
      "name": "ROLE_USER"
    }
  ]
}
````

Supongamos que queremos que el usuario anterior tenga los roles `ROLE_USER` y `ROLE_ADMIN`, así que procedemos a usar el
endpoint que construímos para actualizar el rol.

````bash
$ curl -v -X PATCH -H "Content-Type: application/json" -d "[\"ROLE_USER\", \"ROLE_ADMIN\"]" http://localhost:59207/api/v1/users/3/roles | jq
>
< HTTP/1.1 200
< Content-Type: application/json
< Transfer-Encoding: chunked
< Date: Wed, 16 Apr 2025 21:44:40 GMT
<
{
  "id": 3,
  "username": "user",
  "enabled": true,
  "email": "user@gmail.com",
  "roles": [
    {
      "id": 2,
      "name": "ROLE_USER"
    },
    {
      "id": 1,
      "name": "ROLE_ADMIN"
    }
  ]
}
````

Si le mandamos un rol que no existe en nuestro servicio, pues le retornamos un error.

````bash
$ curl -v -X PATCH -H "Content-Type: application/json" -d "[\"ROLE_USER\", \"ROLE_AUXILIARY\", \"ROLE_ADMIN\"]" http://localhost:59207/api/v1/users/3/roles | jq
>
< HTTP/1.1 400
< Content-Type: application/json
< Transfer-Encoding: chunked
< Date: Wed, 16 Apr 2025 21:45:42 GMT
< Connection: close
<
{
  "status": 400,
  "error": "Bad Request",
  "message": "One or more roles are invalid",
  "path": "/api/v1/users/3/roles",
  "timestamp": "2025-04-16T16:45:42"
}
````

## Configurando user-service en gateway-server

En el `application.yml` del `gateway-server` agregaremos la ruta para el `user-service`, de tal forma que podremos
conectarnos a ese microservicio a través del gateway y usando un único puerto `8090`.

````yml
spring:
  application:
    name: gateway-server
  cloud:
    gateway:
      routes:
        - id: user-service-route
          uri: lb://user-service
          predicates:
            - Path=/api/v1/users/**
````

Levantamos las aplicaciones en el siguiente orden:

- discovery-server
- user-service
- gateway-server

Ahora, sí a través el `gateway-server` cuyo puerto es el `8090` realizamos las peticiones hacia el `user-service`.

````bash
$ curl -v http://localhost:8090/api/v1/users | jq
>
< HTTP/1.1 200 OK
< transfer-encoding: chunked
< Content-Type: application/json
< Date: Wed, 16 Apr 2025 22:52:42 GMT
< token-response: 123456
< set-cookie: color=red
<
[
  {
    "id": 1,
    "username": "admin",
    "enabled": true,
    "email": "admin@gmail.com",
    "roles": [
      {
        "id": 2,
        "name": "ROLE_USER"
      },
      {
        "id": 1,
        "name": "ROLE_ADMIN"
      }
    ]
  },
  {
    "id": 2,
    "username": "martin",
    "enabled": true,
    "email": "martin@gmail.com",
    "roles": [
      {
        "id": 2,
        "name": "ROLE_USER"
      }
    ]
  }
]
````
