# Sección 04: Spring Cloud Gateway

---

## Introducción a Spring Cloud Gateway

`Spring Cloud Gateway` busca proporcionar una forma sencilla y eficaz de enrutar las API y abordar cuestiones
transversales como la seguridad, la monitorización/métricas y la resiliencia.

Características de `Spring Cloud Gateway`:

- Desarrollado en Spring Framework 5, Project Reactor y Spring Boot 2.0
- Capacidad para conectar rutas con cualquier atributo de solicitud.
- Los predicados y filtros son específicos de cada ruta.
- Integración con Hystrix Circuit Breaker.
- Integración con Spring Cloud DiscoveryClient.
- Fácil escritura de predicados y filtros.
- Limitación de la tasa de solicitudes.
- Reescritura de rutas.

![01.png](assets/section-04/01.png)

## [Creando servicio Spring Cloud Gateway](https://start.spring.io/#!type=maven-project&language=java&platformVersion=3.4.4&packaging=jar&jvmVersion=21&groupId=dev.magadiflo&artifactId=gateway-server&name=gateway-server&description=Gateway%20Server&packageName=dev.magadiflo.gateway.server.app&dependencies=cloud-gateway-reactive,cloud-eureka,lombok)

Las dependencias usadas para crear el Gateway serán los siguientes:

````xml
<!--Spring Boot 3.4.4-->
<!--Spring Cloud 2024.0.1-->
<!--Java 21-->
<dependencies>
    <dependency>
        <groupId>org.springframework.cloud</groupId>
        <artifactId>spring-cloud-starter-gateway</artifactId>
    </dependency>
    <dependency>
        <groupId>org.springframework.cloud</groupId>
        <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>
    </dependency>

    <dependency>
        <groupId>org.projectlombok</groupId>
        <artifactId>lombok</artifactId>
        <optional>true</optional>
    </dependency>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-test</artifactId>
        <scope>test</scope>
    </dependency>
    <dependency>
        <groupId>io.projectreactor</groupId>
        <artifactId>reactor-test</artifactId>
        <scope>test</scope>
    </dependency>
</dependencies>
````

En el `application.yml` agregamos las siguientes configuraciones.

````yml
server:
  port: 8090
  error:
    include-message: always

spring:
  application:
    name: gateway-server

eureka:
  instance:
    prefer-ip-address: true
  client:
    service-url:
      defaultZone: http://localhost:8761/eureka/
````

## Configuración de rutas usando application.yml

Configuramos las rutas de nuestros microservicios en el `gateway-server`.

````yml
spring:
  application:
    name: gateway-server
  cloud:
    gateway:
      routes:
        - id: product-service-route
          uri: lb://product-service
          predicates:
            - Path=/api/v1/products/**
        - id: item-service-route
          uri: lb://item-service
          predicates:
            - Path=/api/v1/items/**
````

Ahora, levantamos las aplicaciones en el siguiente orden:

- Eureka Server
- Microservicios (product-service, item-service)
- Gateway Server

Realizamos las peticiones a través del `gateway-server` con su puerto `8090`.

````bash
$ curl -v -G --data "quantity=10" http://localhost:8090/api/v1/items/1 | jq
>
< HTTP/1.1 200 OK
< transfer-encoding: chunked
< Content-Type: application/json
< Date: Wed, 09 Apr 2025 17:09:57 GMT
<
{
  "product": {
    "id": 1,
    "name": "Panasonic",
    "price": 800.00,
    "createAt": "2025-04-09T12:07:34",
    "port": 55115
  },
  "quantity": 10,
  "total": 8000.00
}
````

````bash
$ curl -v http://localhost:8090/api/v1/products/5 | jq
>
< HTTP/1.1 200 OK
< transfer-encoding: chunked
< Content-Type: application/json
< Date: Wed, 09 Apr 2025 17:11:14 GMT
<
{
  "id": 5,
  "name": "Hewlett Packard",
  "price": 500.00,
  "createAt": "2025-04-09T12:07:34",
  "port": 55115
}
````

````bash
$ curl -v -G --data "quantity=10" http://localhost:8090/api/v1/items/50 | jq
>
< HTTP/1.1 404 Not Found
< transfer-encoding: chunked
< Content-Type: application/json
< Date: Wed, 09 Apr 2025 17:12:58 GMT
<
{
  "status": 404,
  "error": "Not Found",
  "message": "The item cannot be displayed because the product with id 50 does not exist",
  "path": "/api/v1/items/50",
  "timestamp": "2025-04-09T12:12:58"
}
````

## Implementando filtros globales pre y post

Vamos a implementar un filtro global; este filtro se ejecuta para todas las solicitudes y respuestas que pasen a través
del gateway.

````java

@Slf4j
@Component
public class SampleGlobalFilter implements GlobalFilter {
    @Override
    public Mono<Void> filter(ServerWebExchange exchange, GatewayFilterChain chain) {
        log.info("Global: ejecutando filtro request PRE");

        return chain.filter(exchange)
                .then(Mono.fromRunnable(() -> {
                    log.info("Global: ejecutando filtro response POST");

                }));
    }
}
````

**Dónde**

- La clase implementa la interfaz `GlobalFilter`, que es una forma de crear filtros globales para
  `Spring Cloud Gateway`. Un filtro global se ejecuta para todas las solicitudes que pasen por el gateway.
- La interfaz `GlobalFilter` requiere implementar el método `filter()`, que es donde definiremos la lógica de nuestro
  filtro.
- `ServerWebExchange`, representa la solicitud actual `(request)` y la respuesta `(response)` que están siendo
  procesadas. Desde `exchange`, puedes acceder a la solicitud `(request)` y la respuesta `(response)`, así como a los
  atributos de contexto.
- `GatewayFilterChain`, es el objeto que maneja la cadena de filtros. Llamando a `chain.filter(exchange)` en este
  filtro, le estás diciendo a `Spring Cloud Gateway` que pase la solicitud al siguiente filtro en la cadena.
- `log.info("Global: ejecutando filtro request PRE")`, esto es solo un mensaje de registro (log) que indica que el
  filtro se está ejecutando antes de que la solicitud sea procesada por el siguiente filtro.
- `chain.filter(exchange)`, esta línea pasa la solicitud al siguiente filtro o al manejador de la solicitud si no hay
  más filtros.
- `Mono<Void>`, el filtro devuelve un `Mono` (de Reactor), lo que indica que el filtro es asíncrono. Es una forma de
  trabajar con operaciones reactivas. La ejecución de este filtro es asíncrona, por lo que puedes encadenar otras
  operaciones (como la manipulación de la respuesta).
- `.then(Mono.fromRunnable(() -> { ... }))`, después de que la solicitud haya pasado por la cadena de filtros, este
  bloque se ejecuta para procesar la respuesta (POST) del gateway. Este código se ejecuta después de que se haya
  procesado la respuesta. Aquí también estás registrando un mensaje de log.

**Resumen del flujo del filtro:**

- `Pre-procesamiento`, antes de que la solicitud sea manejada por los siguientes filtros, se registra un mensaje
  indicando que el filtro está ejecutándose (filtro request PRE).
- `Post-procesamiento`, después de que todos los filtros hayan procesado la solicitud y antes de que la respuesta se
  envíe al cliente, se ejecuta un bloque de código para registrar un mensaje indicando que el filtro se está ejecutando
  en la respuesta POST.

## Modificando el response en el filtro post

En este apartado nos vamos a apoyar del filtro global para agregar una cookie al momento de que la respuesta regrese
al cliente.

Entonces, en el filtro global `SampleGlobalFilter` del `gateway-server` agregamos el siguiente código.

````java

@Slf4j
@Component
public class SampleGlobalFilter implements GlobalFilter {
    @Override
    public Mono<Void> filter(ServerWebExchange exchange, GatewayFilterChain chain) {
        log.info("Global: ejecutando filtro request PRE");

        return chain.filter(exchange)
                .then(Mono.fromRunnable(() -> {
                    log.info("Global: ejecutando filtro response POST");

                    exchange.getResponse()
                            .getCookies()
                            .add("color", ResponseCookie.from("color", "red").build());
                }));
    }
}
````

Ahora, levantamos las aplicaciones en el siguiente orden y veamos el comportamiento.

- Eureka Server
- Microservicios (product-service, item-service)
- Gateway Server

En la siguiente petición, observemos que estamos recibiendo como respuesta, además de la información consultada, el
cookie que definimos en la respuesta `set-cookie: color=red`.

````bash
$ curl -v -G --data "quantity=10" http://localhost:8090/api/v1/items/1 | jq
>
< HTTP/1.1 200 OK
< transfer-encoding: chunked
< Content-Type: application/json
< Date: Wed, 09 Apr 2025 20:18:28 GMT
< set-cookie: color=red
<
{
  "product": {
    "id": 1,
    "name": "Panasonic",
    "price": 800.00,
    "createAt": "2025-04-09T15:17:09",
    "port": 57420
  },
  "quantity": 10,
  "total": 8000.00
}
````

Si revisamos los logs del gateway-server, vemos que los logs se están imprimiendo correctamente.

````bash
INFO 3196 --- [gateway-server] [ctor-http-nio-2] d.m.g.s.app.filter.SampleGlobalFilter    : Global: ejecutando filtro request PRE
INFO 3196 --- [gateway-server] [ctor-http-nio-2] d.m.g.s.app.filter.SampleGlobalFilter    : Global: ejecutando filtro response POST
````

## Modificando el request en el filtro pre

Este filtro global se ejecuta para todas las peticiones que pasan por el Gateway.

- `PRE`: Antes de enviar la solicitud al microservicio de destino, se agrega un header personalizado `token-request`.
- `POST`: Después de recibir la respuesta del microservicio:
    - Se lee el valor del header `token-request` (agregado en PRE).
    - Se agrega un header `token-response` en la respuesta con ese mismo valor.
    - Se agrega una cookie `color=red` en la respuesta.

Recordar que `exchange.getRequest()` es inmutable dentro del flujo reactivo de `Spring Cloud Gateway`. Para modificarlo,
es necesario crear una nueva instancia usando `.mutate()` y luego construir un nuevo `ServerWebExchange`.

En resumen, podríamos decir:

- `ServerHttpRequest` y `ServerWebExchange` son inmutables por diseño, porque así se mantiene la coherencia en entornos
  reactivos y concurrentes.
- Cuando haces un `.mutate()`, estás construyendo una copia modificada del objeto, pero nada cambia si no haces el
  `.build()` y lo `reasignas`.
- Por eso, si modificamos el request (headers, path, etc.), como por ejemplo en nuestro caso, necesitamos:
  ````java
  ServerHttpRequest newRequest = exchange.getRequest().mutate().header("token-request", "123456").build();
  ServerWebExchange newExchange = exchange.mutate().request(newRequest).build();
  ````
- Y a partir de ese punto, trabajaremos con el `newExchange`, que es el que lleva nuestros cambios. Así que ya no
  debemos usar el exchange original, sino el modificado si queremos ver reflejados los cambios.

````java

@Slf4j
@Component
public class SampleGlobalFilter implements GlobalFilter {
    @Override
    public Mono<Void> filter(ServerWebExchange exchange, GatewayFilterChain chain) {
        log.info("Global: ejecutando filtro request PRE");
        ServerHttpRequest newRequest = exchange.getRequest()
                .mutate()
                .header("token-request", "123456")
                .build();

        ServerWebExchange newExchange = exchange.mutate()
                .request(newRequest)
                .build();

        return chain.filter(newExchange)
                .then(Mono.fromRunnable(() -> {
                    log.info("Global: ejecutando filtro response POST");
                    String tokenRequest = newExchange.getRequest().getHeaders().getFirst("token-request");
                    Optional.ofNullable(tokenRequest).ifPresent(value ->
                            newExchange.getResponse().getHeaders().add("token-response", value));

                    newExchange.getResponse()
                            .getCookies()
                            .add("color", ResponseCookie.from("color", "red").build());
                }));
    }
}
````

Si hacemos la petición a través de nuestro `gateway-server`, veremos que como parte de la respuesta de las cabeceras
obtenemos tanto el `token-response: 123456` como el `set-cookie: color=red`.

````bash
$ curl -v -G --data "quantity=10" http://localhost:8090/api/v1/items/1 | jq
>
< HTTP/1.1 200 OK
< transfer-encoding: chunked
< Content-Type: application/json
< Date: Wed, 09 Apr 2025 21:24:43 GMT
< token-response: 123456
< set-cookie: color=red
<
{
  "product": {
    "id": 1,
    "name": "Panasonic",
    "price": 800.00,
    "createAt": "2025-04-09T16:23:39",
    "port": 58260
  },
  "quantity": 10,
  "total": 8000.00
}
````

## Implementando Gateway Filter Factory

En este apartado crearemos nuestro `GatewayFilterFactory` que sirve para aplicar filtros de forma selectiva a rutas
específicas, a diferencia del filtro global que se aplica a todas.

Iniciamos creando este record que lo usaremos en nuestro `GatewayFilterFactory` personalizado.

````java
public record ConfigurationCookie(String message,
                                  String cookieValue,
                                  String cookieName) {
}
````

A continuación se muestra la clase del gateway filter factory personalizado. La clase `SampleCookieGatewayFilterFactory`
extiende `AbstractGatewayFilterFactory<ConfigurationCookie>`, lo que significa que es una implementación de un filtro en
`Spring Cloud Gateway` que permite manipular las solicitudes y respuestas que pasan a través del `Gateway`.

````java

@Slf4j
@Component
public class SampleCookieGatewayFilterFactory extends AbstractGatewayFilterFactory<ConfigurationCookie> {

    public SampleCookieGatewayFilterFactory() {
        super(ConfigurationCookie.class);
    }

    @Override
    public GatewayFilter apply(ConfigurationCookie config) {
        return (exchange, chain) -> {
            log.info("Ejecuta PRE GatewayFilterFactory: {}", config.message());

            return chain.filter(exchange)
                    .then(Mono.fromRunnable(() -> {
                        log.info("Ejecuta POST GatewayFilterFactory: {}", config.message());
                    }));
        };
    }
}
````

**Nota**

- En el constructor de nuestro filtro personalizado debemos hacer una configuración importante. Cuando implementamos un
  filtro personalizado en `Spring Cloud Gateway`, debes pasar la clase de configuración al constructor de la clase base
  `AbstractGatewayFilterFactory<ConfigurationCookie>`, como lo hicimos en el caso de `ConfigurationCookie.class`. Esto
  es necesario para que `Spring` pueda mapear correctamente las configuraciones desde el archivo `application.yml` a los
  parámetros de la clase de configuración.


- Para que la clase se detecte automáticamente como un filtro debe tener al final del nombre de la clase el sufijo
  `GatewayFilterFactory`. Por ejemplo, `Ejemplo + GatewayFilterFactory => EjemploGatewayFilterFactory`, aunque también
  se puede realizar la configuración con cualquier nombre en el `application.yml`.


- El nombre del filtro en el `yml` debe coincidir con el nombre de nuestra clase sin el sufijo `GatewayFilterFactory` (o
  con `name()` sobreescrito si queremos usar otro nombre). Por ejemplo, nuestra clase se llama
  `SampleCookieGatewayFilterFactory`, entonces en el `yml` lo usaríamos simplemente como `SampleCookie`. Spring
  automáticamente quita el sufijo `GatewayFilterFactory` y usa el resto como el nombre del filtro en la configuración.

## Gateway Filter Factory Modificando Response HTTP

Veamos la lógica que hemos aplicado en este filtro.

- `PRE (antes de que se pase a los siguientes filtros)`, se imprime un mensaje en el log antes de que continúe con la
  cadena de filtros `(chain.filter(exchange))`.


- `POST (después de que se complete la cadena de filtros)`, el `Mono.fromRunnable()` se ejecuta después de que se haya
  completado el filtro. Esto significa que la lógica dentro de este bloque se ejecuta después de que la respuesta haya
  sido procesada. Si la configuración `(config.cookieValue())` tiene un valor de cookie, este valor se añade a la
  respuesta `(exchange.getResponse().addCookie(...))`, usando el nombre y valor del cookie que se define en
  `ConfigurationCookie`.

````java

@Slf4j
@Component
public class SampleCookieGatewayFilterFactory extends AbstractGatewayFilterFactory<ConfigurationCookie> {

    public SampleCookieGatewayFilterFactory() {
        super(ConfigurationCookie.class);
    }

    @Override
    public GatewayFilter apply(ConfigurationCookie config) {
        return (exchange, chain) -> {
            log.info("Ejecuta PRE GatewayFilterFactory: {}", config.message());

            return chain.filter(exchange)
                    .then(Mono.fromRunnable(() -> {
                        log.info("Ejecuta POST GatewayFilterFactory: {}", config.message());

                        Optional.ofNullable(config.cookieValue()).ifPresent(cookie ->
                                exchange.getResponse()
                                        .addCookie(ResponseCookie.from(config.cookieName(), cookie).build()));
                    }));
        };
    }
}
````

Este `GatewayFilterFactory` personaliza las solicitudes y respuestas de `Spring Cloud Gateway` de la siguiente manera:

- Antes de que la solicitud se envíe a través de la cadena de filtros `(PRE)`, se imprime un mensaje de log.
- Después de que se procesa la solicitud `(POST)`, si se ha definido un valor de cookie en la configuración
  `(config.cookieValue())`, se agrega una cookie a la respuesta.

## Configurando y probando nuestro Gateway Filter Factory personalizado

Vamos a configurar nuestro filtro `SampleCookieGatewayFilterFactory` en el `application.yml` del `gateway-server` y lo
aplicaremos únicamente a la ruta `product-service-route`.

````yml
spring:
  application:
    name: gateway-server
  cloud:
    gateway:
      routes:
        - id: product-service-route
          uri: lb://product-service
          predicates:
            - Path=/api/v1/products/**
          filters:
            - name: SampleCookie
              args:
                message: "Este es un mensaje personalizado para el product-service"
                cookieName: "userCookie"
                cookieValue: "magadiflo"
        - id: item-service-route
          uri: lb://item-service
          predicates:
            - Path=/api/v1/items/**
````

**Importante**

- Como dijimos en líneas arriba, cuando definamos el filtro personalizado para una ruta específica, únicamente debemos
  colocar el prefijo del nombre de la clase, en nuestro caso nuestra clase se llama `SampleCookieGatewayFilterFactory`,
  por lo tanto, únicamente colocaremos el `SampleCookie` sin el sufijo `GatewayFilterFactory`.
- Cuando `Spring Cloud Gateway` busca un filtro por su nombre en el archivo `application.yml`, se espera que el nombre
  sea solo el nombre base de la clase (sin el sufijo `GatewayFilterFactory`), porque `Spring` ya sabe cómo asociar el
  nombre del filtro con la clase que lo implementa, utilizando el sufijo `GatewayFilterFactory` internamente. Esto hace
  que la configuración sea más sencilla y más legible.

Ahora realizamos una petición al microservicio donde agregamos el filtro personalizado `product-service`. Podemos
observar en la respuesta que nos está colocando el `set-cookie: userCookie=magadiflo` configurado en la clase de
filtro personalizada.

````bash
$ curl -v http://localhost:8090/api/v1/products/5 | jq
>
* Request completely sent off
< HTTP/1.1 200 OK
< transfer-encoding: chunked
< Content-Type: application/json
< Date: Wed, 09 Apr 2025 22:58:01 GMT
< token-response: 123456
< set-cookie: color=red
< set-cookie: userCookie=magadiflo
<
{
  "id": 5,
  "name": "Hewlett Packard",
  "price": 500.00,
  "createAt": "2025-04-09T17:49:52",
  "port": 59526
}
````

Incluso, si vemos el log del `gateway-server` observamos los mensajes que imprimimos en el filtro personalizado.

````bash
s.a.f.f.SampleCookieGatewayFilterFactory : Ejecuta PRE GatewayFilterFactory: Este es un mensaje personalizado para el product-service
d.m.g.s.app.filter.SampleGlobalFilter    : Global: ejecutando filtro request PRE
d.m.g.s.app.filter.SampleGlobalFilter    : Global: ejecutando filtro response POST
s.a.f.f.SampleCookieGatewayFilterFactory : Ejecuta POST GatewayFilterFactory: Este es un mensaje personalizado para el product-service
````

Ahora, qué pasa si realizamos una petición al `item-service`, es decir, este microservicio no tiene definido el filtro
personalizado, por lo tanto, no se debería ejecutar dicho filtro y es así, en la respuesta que obtenemos ahora no
vemos en la cabecera el `set-cookie: userCookie=magadiflo`, que fue definido en el filtro personalizado y en el
`application.yml`.

````bash
$ curl -v -G --data "quantity=10" http://localhost:8090/api/v1/items/1 | jq
>
< HTTP/1.1 200 OK
< transfer-encoding: chunked
< Content-Type: application/json
< Date: Wed, 09 Apr 2025 23:02:53 GMT
< token-response: 123456
< set-cookie: color=red
<
{
  "product": {
    "id": 1,
    "name": "Panasonic",
    "price": 800.00,
    "createAt": "2025-04-09T17:49:52",
    "port": 59526
  },
  "quantity": 10,
  "total": 8000.00
}
````

Si revisamos el logs del `gateway-server` vemos que no se imprimen los logs del filtro personalizado.

````bash
d.m.g.s.app.filter.SampleGlobalFilter    : Global: ejecutando filtro request PRE
d.m.g.s.app.filter.SampleGlobalFilter    : Global: ejecutando filtro response POST
````

## Sobreescribiendo el nombre del filtro personalizado

Desde `Spring Cloud 2022.0 (aka Kilburn)` en adelante, podemos sobrescribir el método `name()` de nuestro
`GatewayFilterFactory` para cambiar cómo se llama el filtro en el `application.yml`, sin tener que renombrar la clase.

Lo que haremos será sobreescribir el método `name()` de nuestro filtro personalizado retornando el nuevo nombre que le
daremos a nuestro filtro.

````java

@Slf4j
@Component
public class SampleCookieGatewayFilterFactory extends AbstractGatewayFilterFactory<ConfigurationCookie> {

    public SampleCookieGatewayFilterFactory() {
        super(ConfigurationCookie.class);
    }

    @Override
    public GatewayFilter apply(ConfigurationCookie config) {
        return (exchange, chain) -> {
            log.info("Ejecuta PRE GatewayFilterFactory: {}", config.message());

            return chain.filter(exchange)
                    .then(Mono.fromRunnable(() -> {
                        log.info("Ejecuta POST GatewayFilterFactory: {}", config.message());

                        Optional.ofNullable(config.cookieValue()).ifPresent(cookie ->
                                exchange.getResponse()
                                        .addCookie(ResponseCookie.from(config.cookieName(), cookie).build()));
                    }));
        };
    }

    @Override
    public String name() {
        return "AddMyCookie";
    }
}
````

El nombre que colocamos al filtro anterior (`AddMyCookie`) lo usaremos en el `application.yml`.

````yml
spring:
  application:
    name: gateway-server
  cloud:
    gateway:
      routes:
        - id: product-service-route
          uri: lb://product-service
          predicates:
            - Path=/api/v1/products/**
          filters:
            - name: AddMyCookie
              args:
                message: "Este es un mensaje personalizado para el product-service"
                cookieName: "userCookie"
                cookieValue: "magadiflo"
````

**Importante**
> Recordar que en `Spring Cloud Gateway`, cuando creamos un filtro personalizado extendiendo
> `AbstractGatewayFilterFactory`, por defecto el nombre que usamos en el `application.yml` para referenciarlo es el
> nombre de la clase sin el sufijo `GatewayFilterFactory`. Es decir, en nuestro ejemplo inicial el nombre del filtro que
> usamos fue `SampleCookie` por defecto.
>
> Ahora, si queremos cambiar el nombre del filtro personalizado, simplemente debemos sobreescribir el método `name()` y
> luego el valor retornado usarlo en el `application.yml`, tal como vimos en este apartado.

Ahora, ejecutamos nuestras aplicaciones y vemos que el filtro sigue funcionando correctamente, pero esta vez, en la
ruta del gateway en el `application.yml` estamos usando un nombre de filtro distinto al del nombre de la clase.

````bash
$ curl -v http://localhost:8090/api/v1/products/5 | jq
>
< HTTP/1.1 200 OK
< transfer-encoding: chunked
< Content-Type: application/json
< Date: Thu, 10 Apr 2025 15:05:38 GMT
< token-response: 123456
< set-cookie: color=red
< set-cookie: userCookie=magadiflo
<
{
  "id": 5,
  "name": "Hewlett Packard",
  "price": 500.00,
  "createAt": "2025-04-10T10:03:38",
  "port": 62672
}
````

## Filtros Gateway Factory que vienen de fábrica

Los filtros de ruta permiten modificar la solicitud HTTP entrante o la respuesta HTTP saliente de alguna manera.
El alcance de los filtros de ruta se limita a una ruta específica. `Spring Cloud Gateway` incluye varias fábricas de
`GatewayFilter` integradas.

En nuestro ejemplo, estamos usando filtros predeterminados (de fábrica) únicamente en la ruta `item-service-route`.

````yml
spring:
  application:
    name: gateway-server
  cloud:
    gateway:
      routes:
        - id: product-service-route
          uri: lb://product-service
          predicates:
            - Path=/api/v1/products/**
          filters:
            - name: AddMyCookie
              args:
                message: "Este es un mensaje personalizado para el product-service"
                cookieName: "userCookie"
                cookieValue: "magadiflo"
        - id: item-service-route
          uri: lb://item-service
          predicates:
            - Path=/api/v1/items/**
          filters:
            - AddRequestHeader=X-Request-color, yellow
            - AddResponseHeader=X-Response-color, green
            - AddRequestParameter=color-name, blue
````

**Donde**

- `AddRequestHeader`, agrega un header http al request antes de enviarlo al microservicio de destino (`item-service`).
- `AddResponseHeader`, agrega un header http a la respuesta que vuelve al cliente. En nuestro caso, cuando el cliente
  recibe la respuesta del `item-service`, verá en sus cabeceras la respuesta `X-Response-color, green`.
- `AddRequestParameter`, agrega un parámetro de query al request antes de mandarlo al microservicio de destino
  (`item-service`).

Para ver que los filtros `AddRequestParameter` y `AddRequestHeader` estén funcionando, vamos a crear un nuevo endpoint
en el `item-service` donde imprimiremos los valores enviados.

````java

@Slf4j
@RestController
@RequestMapping(path = "/api/v1/items")
public class ItemController {

    private final ItemService itemService;

    public ItemController(@Qualifier("itemServiceWithRestClientImpl") ItemService itemService) {
        this.itemService = itemService;
    }

    @GetMapping
    public ResponseEntity<List<Item>> findProducts() {/* code */}

    @GetMapping(path = "/filters-gateway")
    public ResponseEntity<Void> findProducts(@RequestParam(name = "color-name") String colorName,
                                             @RequestHeader(name = "X-Request-color") String headerColor) {
        log.info("AddRequestParameter (color-name): {}", colorName);
        log.info("AddRequestHeader (X-Request-color): {}", headerColor);
        return ResponseEntity.noContent().build();
    }

    @GetMapping(path = "/{productId}")
    public ResponseEntity<Item> findProduct(@PathVariable Long productId, @RequestParam int quantity) {/* code */}
}
````

Finalmente, realizamos la petición al nuevo endpoint del `item-service`. Como repuesta en los headers vemos el
`X-Response-color: green` que configuramos en el filtro `AddResponseHeader`.

````bash
$ curl -v http://localhost:8090/api/v1/items/filters-gateway | jq
>
< HTTP/1.1 204 No Content
< Date: Thu, 10 Apr 2025 15:38:48 GMT
< token-response: 123456
< X-Response-color: green
< set-cookie: color=red
<
````

Para observar el funcionamiento de los filtros de `request`, vemos en consola del `item-service` que los valores
enviados en dichos filtros se están obteniendo sin problemas.

````bash
d.m.item.app.controller.ItemController   : AddRequestParameter (color-name): blue
d.m.item.app.controller.ItemController   : AddRequestHeader (X-Request-color): yellow
````
