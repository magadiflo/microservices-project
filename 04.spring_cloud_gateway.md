# Sección 04: Spring Cloud Gateway

---

## Introducción a Spring Cloud Gateway

`Spring Cloud Gateway` busca proporcionar una forma sencilla y eficaz de enrutar las API y abordar cuestiones
transversales como la seguridad, la monitorización/métricas y la resiliencia.

Características de `Spring Cloud Gateway`:

- Desarrollado en Spring Framework 5, Project Reactor y Spring Boot 2.0
- Capacidad para conectar rutas con cualquier atributo de solicitud.
- Los predicados y filtros son específicos de cada ruta.
- Integración con Hystrix Circuit Breaker.
- Integración con Spring Cloud DiscoveryClient.
- Fácil escritura de predicados y filtros.
- Limitación de la tasa de solicitudes.
- Reescritura de rutas.

![01.png](assets/section-04/01.png)

## [Creando servicio Spring Cloud Gateway](https://start.spring.io/#!type=maven-project&language=java&platformVersion=3.4.4&packaging=jar&jvmVersion=21&groupId=dev.magadiflo&artifactId=gateway-server&name=gateway-server&description=Gateway%20Server&packageName=dev.magadiflo.gateway.server.app&dependencies=cloud-gateway-reactive,cloud-eureka,lombok)

Las dependencias usadas para crear el Gateway serán los siguientes:

````xml
<!--Spring Boot 3.4.4-->
<!--Spring Cloud 2024.0.1-->
<!--Java 21-->
<dependencies>
    <dependency>
        <groupId>org.springframework.cloud</groupId>
        <artifactId>spring-cloud-starter-gateway</artifactId>
    </dependency>
    <dependency>
        <groupId>org.springframework.cloud</groupId>
        <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>
    </dependency>

    <dependency>
        <groupId>org.projectlombok</groupId>
        <artifactId>lombok</artifactId>
        <optional>true</optional>
    </dependency>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-test</artifactId>
        <scope>test</scope>
    </dependency>
    <dependency>
        <groupId>io.projectreactor</groupId>
        <artifactId>reactor-test</artifactId>
        <scope>test</scope>
    </dependency>
</dependencies>
````

En el `application.yml` agregamos las siguientes configuraciones.

````yml
server:
  port: 8090
  error:
    include-message: always

spring:
  application:
    name: gateway-server

eureka:
  instance:
    prefer-ip-address: true
  client:
    service-url:
      defaultZone: http://localhost:8761/eureka/
````

## Configuración de rutas usando application.yml

Configuramos las rutas de nuestros microservicios en el `gateway-server`.

````yml
spring:
  application:
    name: gateway-server
  cloud:
    gateway:
      routes:
        - id: product-service-route
          uri: lb://product-service
          predicates:
            - Path=/api/v1/products/**
        - id: item-service-route
          uri: lb://item-service
          predicates:
            - Path=/api/v1/items/**
````

Ahora, levantamos las aplicaciones en el siguiente orden:

- Eureka Server
- Microservicios (product-service, item-service)
- Gateway Server

Realizamos las peticiones a través del `gateway-server` con su puerto `8090`.

````bash
$ curl -v -G --data "quantity=10" http://localhost:8090/api/v1/items/1 | jq
>
< HTTP/1.1 200 OK
< transfer-encoding: chunked
< Content-Type: application/json
< Date: Wed, 09 Apr 2025 17:09:57 GMT
<
{
  "product": {
    "id": 1,
    "name": "Panasonic",
    "price": 800.00,
    "createAt": "2025-04-09T12:07:34",
    "port": 55115
  },
  "quantity": 10,
  "total": 8000.00
}
````

````bash
$ curl -v http://localhost:8090/api/v1/products/5 | jq
>
< HTTP/1.1 200 OK
< transfer-encoding: chunked
< Content-Type: application/json
< Date: Wed, 09 Apr 2025 17:11:14 GMT
<
{
  "id": 5,
  "name": "Hewlett Packard",
  "price": 500.00,
  "createAt": "2025-04-09T12:07:34",
  "port": 55115
}
````

````bash
$ curl -v -G --data "quantity=10" http://localhost:8090/api/v1/items/50 | jq
>
< HTTP/1.1 404 Not Found
< transfer-encoding: chunked
< Content-Type: application/json
< Date: Wed, 09 Apr 2025 17:12:58 GMT
<
{
  "status": 404,
  "error": "Not Found",
  "message": "The item cannot be displayed because the product with id 50 does not exist",
  "path": "/api/v1/items/50",
  "timestamp": "2025-04-09T12:12:58"
}
````

## Implementando filtros globales pre y post

Vamos a implementar un filtro global; este filtro se ejecuta para todas las solicitudes y respuestas que pasen a través
del gateway.

````java

@Slf4j
@Component
public class SampleGlobalFilter implements GlobalFilter {
    @Override
    public Mono<Void> filter(ServerWebExchange exchange, GatewayFilterChain chain) {
        log.info("Global: ejecutando filtro request PRE");

        return chain.filter(exchange)
                .then(Mono.fromRunnable(() -> {
                    log.info("Global: ejecutando filtro response POST");

                }));
    }
}
````

**Dónde**

- La clase implementa la interfaz `GlobalFilter`, que es una forma de crear filtros globales para
  `Spring Cloud Gateway`. Un filtro global se ejecuta para todas las solicitudes que pasen por el gateway.
- La interfaz `GlobalFilter` requiere implementar el método `filter()`, que es donde definiremos la lógica de nuestro
  filtro.
- `ServerWebExchange`, representa la solicitud actual `(request)` y la respuesta `(response)` que están siendo
  procesadas. Desde `exchange`, puedes acceder a la solicitud `(request)` y la respuesta `(response)`, así como a los
  atributos de contexto.
- `GatewayFilterChain`, es el objeto que maneja la cadena de filtros. Llamando a `chain.filter(exchange)` en este
  filtro, le estás diciendo a `Spring Cloud Gateway` que pase la solicitud al siguiente filtro en la cadena.
- `log.info("Global: ejecutando filtro request PRE")`, esto es solo un mensaje de registro (log) que indica que el
  filtro se está ejecutando antes de que la solicitud sea procesada por el siguiente filtro.
- `chain.filter(exchange)`, esta línea pasa la solicitud al siguiente filtro o al manejador de la solicitud si no hay
  más filtros.
- `Mono<Void>`, el filtro devuelve un `Mono` (de Reactor), lo que indica que el filtro es asíncrono. Es una forma de
  trabajar con operaciones reactivas. La ejecución de este filtro es asíncrona, por lo que puedes encadenar otras
  operaciones (como la manipulación de la respuesta).
- `.then(Mono.fromRunnable(() -> { ... }))`, después de que la solicitud haya pasado por la cadena de filtros, este
  bloque se ejecuta para procesar la respuesta (POST) del gateway. Este código se ejecuta después de que se haya
  procesado la respuesta. Aquí también estás registrando un mensaje de log.

**Resumen del flujo del filtro:**

- `Pre-procesamiento`, antes de que la solicitud sea manejada por los siguientes filtros, se registra un mensaje
  indicando que el filtro está ejecutándose (filtro request PRE).
- `Post-procesamiento`, después de que todos los filtros hayan procesado la solicitud y antes de que la respuesta se
  envíe al cliente, se ejecuta un bloque de código para registrar un mensaje indicando que el filtro se está ejecutando
  en la respuesta POST.

## Modificando el response en el filtro post

En este apartado nos vamos a apoyar del filtro global para agregar una cookie al momento de que la respuesta regrese
al cliente.

Entonces, en el filtro global `SampleGlobalFilter` del `gateway-server` agregamos el siguiente código.

````java

@Slf4j
@Component
public class SampleGlobalFilter implements GlobalFilter {
    @Override
    public Mono<Void> filter(ServerWebExchange exchange, GatewayFilterChain chain) {
        log.info("Global: ejecutando filtro request PRE");

        return chain.filter(exchange)
                .then(Mono.fromRunnable(() -> {
                    log.info("Global: ejecutando filtro response POST");

                    exchange.getResponse()
                            .getCookies()
                            .add("color", ResponseCookie.from("color", "red").build());
                }));
    }
}
````

Ahora, levantamos las aplicaciones en el siguiente orden y veamos el comportamiento.

- Eureka Server
- Microservicios (product-service, item-service)
- Gateway Server

En la siguiente petición, observemos que estamos recibiendo como respuesta, además de la información consultada, el
cookie que definimos en la respuesta `set-cookie: color=red`.

````bash
$ curl -v -G --data "quantity=10" http://localhost:8090/api/v1/items/1 | jq
>
< HTTP/1.1 200 OK
< transfer-encoding: chunked
< Content-Type: application/json
< Date: Wed, 09 Apr 2025 20:18:28 GMT
< set-cookie: color=red
<
{
  "product": {
    "id": 1,
    "name": "Panasonic",
    "price": 800.00,
    "createAt": "2025-04-09T15:17:09",
    "port": 57420
  },
  "quantity": 10,
  "total": 8000.00
}
````

Si revisamos los logs del gateway-server, vemos que los logs se están imprimiendo correctamente.

````bash
INFO 3196 --- [gateway-server] [ctor-http-nio-2] d.m.g.s.app.filter.SampleGlobalFilter    : Global: ejecutando filtro request PRE
INFO 3196 --- [gateway-server] [ctor-http-nio-2] d.m.g.s.app.filter.SampleGlobalFilter    : Global: ejecutando filtro response POST
````

## Modificando el request en el filtro pre

Este filtro global se ejecuta para todas las peticiones que pasan por el Gateway.

- `PRE`: Antes de enviar la solicitud al microservicio de destino, se agrega un header personalizado `token-request`.
- `POST`: Después de recibir la respuesta del microservicio:
    - Se lee el valor del header `token-request` (agregado en PRE).
    - Se agrega un header `token-response` en la respuesta con ese mismo valor.
    - Se agrega una cookie `color=red` en la respuesta.

Recordar que `exchange.getRequest()` es inmutable dentro del flujo reactivo de `Spring Cloud Gateway`. Para modificarlo,
es necesario crear una nueva instancia usando `.mutate()` y luego construir un nuevo `ServerWebExchange`.

En resumen, podríamos decir:

- `ServerHttpRequest` y `ServerWebExchange` son inmutables por diseño, porque así se mantiene la coherencia en entornos
  reactivos y concurrentes.
- Cuando haces un `.mutate()`, estás construyendo una copia modificada del objeto, pero nada cambia si no haces el
  `.build()` y lo `reasignas`.
- Por eso, si modificamos el request (headers, path, etc.), como por ejemplo en nuestro caso, necesitamos:
  ````java
  ServerHttpRequest newRequest = exchange.getRequest().mutate().header("token-request", "123456").build();
  ServerWebExchange newExchange = exchange.mutate().request(newRequest).build();
  ````
- Y a partir de ese punto, trabajaremos con el `newExchange`, que es el que lleva nuestros cambios. Así que ya no
  debemos usar el exchange original, sino el modificado si queremos ver reflejados los cambios.

````java

@Slf4j
@Component
public class SampleGlobalFilter implements GlobalFilter {
    @Override
    public Mono<Void> filter(ServerWebExchange exchange, GatewayFilterChain chain) {
        log.info("Global: ejecutando filtro request PRE");
        ServerHttpRequest newRequest = exchange.getRequest()
                .mutate()
                .header("token-request", "123456")
                .build();

        ServerWebExchange newExchange = exchange.mutate()
                .request(newRequest)
                .build();

        return chain.filter(newExchange)
                .then(Mono.fromRunnable(() -> {
                    log.info("Global: ejecutando filtro response POST");
                    String tokenRequest = newExchange.getRequest().getHeaders().getFirst("token-request");
                    Optional.ofNullable(tokenRequest).ifPresent(value ->
                            newExchange.getResponse().getHeaders().add("token-response", value));

                    newExchange.getResponse()
                            .getCookies()
                            .add("color", ResponseCookie.from("color", "red").build());
                }));
    }
}
````

Si hacemos la petición a través de nuestro `gateway-server`, veremos que como parte de la respuesta de las cabeceras
obtenemos tanto el `token-response: 123456` como el `set-cookie: color=red`.

````bash
$ curl -v -G --data "quantity=10" http://localhost:8090/api/v1/items/1 | jq
>
< HTTP/1.1 200 OK
< transfer-encoding: chunked
< Content-Type: application/json
< Date: Wed, 09 Apr 2025 21:24:43 GMT
< token-response: 123456
< set-cookie: color=red
<
{
  "product": {
    "id": 1,
    "name": "Panasonic",
    "price": 800.00,
    "createAt": "2025-04-09T16:23:39",
    "port": 58260
  },
  "quantity": 10,
  "total": 8000.00
}
````

## Implementando Gateway Filter Factory

En este apartado crearemos nuestro `GatewayFilterFactory` que sirve para aplicar filtros de forma selectiva a rutas
específicas, a diferencia del filtro global que se aplica a todas.

Iniciamos creando este record que lo usaremos en nuestro `GatewayFilterFactory` personalizado.

````java
public record ConfigurationCookie(String message,
                                  String cookieValue,
                                  String cookieName) {
}
````

A continuación se muestra la clase del gateway filter factory personalizado.

````java

@Slf4j
@Component
public class SampleCookieGatewayFilterFactory extends AbstractGatewayFilterFactory<ConfigurationCookie> {
    @Override
    public GatewayFilter apply(ConfigurationCookie config) {
        return (exchange, chain) -> {
            log.info("Ejecuta PRE GatewayFilterFactory: {}", config.message());

            return chain.filter(exchange)
                    .then(Mono.fromRunnable(() -> {
                        log.info("Ejecuta POST GatewayFilterFactory: {}", config.message());
                    }));
        };
    }
}
````

**Nota**

- Para que la clase se detecte automáticamente como un filtro debe tener al final del nombre de la clase el sufijo
  `GatewayFilterFactory`. Por ejemplo, `Ejemplo + GatewayFilterFactory => EjemploGatewayFilterFactory`, aunque también
  se puede realizar la configuración con cualquier nombre en el `application.yml`.
- El nombre del filtro en el `yml` debe coincidir con el nombre de nuestra clase sin el sufijo `GatewayFilterFactory` (o
  con `name()` sobreescrito si queremos usar otro nombre). Por ejemplo, nuestra clase se llama
  `SampleCookieGatewayFilterFactory`, entonces en el `yml` lo usaríamos simplemente como `SampleCookie`. Spring
  automáticamente quita el sufijo `GatewayFilterFactory` y usa el resto como el nombre del filtro en la configuración.
