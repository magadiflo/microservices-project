# Sección 04: Spring Cloud Gateway

---

## Introducción a Spring Cloud Gateway

`Spring Cloud Gateway` busca proporcionar una forma sencilla y eficaz de enrutar las API y abordar cuestiones
transversales como la seguridad, la monitorización/métricas y la resiliencia.

Características de `Spring Cloud Gateway`:

- Desarrollado en Spring Framework 5, Project Reactor y Spring Boot 2.0
- Capacidad para conectar rutas con cualquier atributo de solicitud.
- Los predicados y filtros son específicos de cada ruta.
- Integración con Hystrix Circuit Breaker.
- Integración con Spring Cloud DiscoveryClient.
- Fácil escritura de predicados y filtros.
- Limitación de la tasa de solicitudes.
- Reescritura de rutas.

![01.png](assets/section-04/01.png)

## [Creando servicio Spring Cloud Gateway](https://start.spring.io/#!type=maven-project&language=java&platformVersion=3.4.4&packaging=jar&jvmVersion=21&groupId=dev.magadiflo&artifactId=gateway-server&name=gateway-server&description=Gateway%20Server&packageName=dev.magadiflo.gateway.server.app&dependencies=cloud-gateway-reactive,cloud-eureka,lombok)

Las dependencias usadas para crear el Gateway serán los siguientes:

````xml
<!--Spring Boot 3.4.4-->
<!--Spring Cloud 2024.0.1-->
<!--Java 21-->
<dependencies>
    <dependency>
        <groupId>org.springframework.cloud</groupId>
        <artifactId>spring-cloud-starter-gateway</artifactId>
    </dependency>
    <dependency>
        <groupId>org.springframework.cloud</groupId>
        <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>
    </dependency>

    <dependency>
        <groupId>org.projectlombok</groupId>
        <artifactId>lombok</artifactId>
        <optional>true</optional>
    </dependency>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-test</artifactId>
        <scope>test</scope>
    </dependency>
    <dependency>
        <groupId>io.projectreactor</groupId>
        <artifactId>reactor-test</artifactId>
        <scope>test</scope>
    </dependency>
</dependencies>
````

En el `application.yml` agregamos las siguientes configuraciones.

````yml
server:
  port: 8090
  error:
    include-message: always

spring:
  application:
    name: gateway-server

eureka:
  instance:
    prefer-ip-address: true
  client:
    service-url:
      defaultZone: http://localhost:8761/eureka/
````

## Configuración de rutas usando application.yml

Configuramos las rutas de nuestros microservicios en el `gateway-server`.

````yml
spring:
  application:
    name: gateway-server
  cloud:
    gateway:
      routes:
        - id: product-service-route
          uri: lb://product-service
          predicates:
            - Path=/api/v1/products/**
        - id: item-service-route
          uri: lb://item-service
          predicates:
            - Path=/api/v1/items/**
````

Ahora, levantamos las aplicaciones en el siguiente orden:

- Eureka Server
- Microservicios (product-service, item-service)
- Gateway Server

Realizamos las peticiones a través del `gateway-server` con su puerto `8090`.

````bash
$ curl -v -G --data "quantity=10" http://localhost:8090/api/v1/items/1 | jq
>
< HTTP/1.1 200 OK
< transfer-encoding: chunked
< Content-Type: application/json
< Date: Wed, 09 Apr 2025 17:09:57 GMT
<
{
  "product": {
    "id": 1,
    "name": "Panasonic",
    "price": 800.00,
    "createAt": "2025-04-09T12:07:34",
    "port": 55115
  },
  "quantity": 10,
  "total": 8000.00
}
````

````bash
$ curl -v http://localhost:8090/api/v1/products/5 | jq
>
< HTTP/1.1 200 OK
< transfer-encoding: chunked
< Content-Type: application/json
< Date: Wed, 09 Apr 2025 17:11:14 GMT
<
{
  "id": 5,
  "name": "Hewlett Packard",
  "price": 500.00,
  "createAt": "2025-04-09T12:07:34",
  "port": 55115
}
````

````bash
$ curl -v -G --data "quantity=10" http://localhost:8090/api/v1/items/50 | jq
>
< HTTP/1.1 404 Not Found
< transfer-encoding: chunked
< Content-Type: application/json
< Date: Wed, 09 Apr 2025 17:12:58 GMT
<
{
  "status": 404,
  "error": "Not Found",
  "message": "The item cannot be displayed because the product with id 50 does not exist",
  "path": "/api/v1/items/50",
  "timestamp": "2025-04-09T12:12:58"
}
````

## Implementando filtros globales pre y post

Vamos a implementar un filtro global; este filtro se ejecuta para todas las solicitudes y respuestas que pasen a través
del gateway.

````java

@Slf4j
@Component
public class SampleGlobalFilter implements GlobalFilter {
    @Override
    public Mono<Void> filter(ServerWebExchange exchange, GatewayFilterChain chain) {
        log.info("Global: ejecutando filtro request PRE");

        return chain.filter(exchange)
                .then(Mono.fromRunnable(() -> {
                    log.info("Global: ejecutando filtro response POST");

                }));
    }
}
````

**Dónde**

- La clase implementa la interfaz `GlobalFilter`, que es una forma de crear filtros globales para
  `Spring Cloud Gateway`. Un filtro global se ejecuta para todas las solicitudes que pasen por el gateway.
- La interfaz `GlobalFilter` requiere implementar el método `filter()`, que es donde definiremos la lógica de nuestro
  filtro.
- `ServerWebExchange`, representa la solicitud actual `(request)` y la respuesta `(response)` que están siendo
  procesadas. Desde `exchange`, puedes acceder a la solicitud `(request)` y la respuesta `(response)`, así como a los
  atributos de contexto.
- `GatewayFilterChain`, es el objeto que maneja la cadena de filtros. Llamando a `chain.filter(exchange)` en este
  filtro, le estás diciendo a `Spring Cloud Gateway` que pase la solicitud al siguiente filtro en la cadena.
- `log.info("Global: ejecutando filtro request PRE")`, esto es solo un mensaje de registro (log) que indica que el
  filtro se está ejecutando antes de que la solicitud sea procesada por el siguiente filtro.
- `chain.filter(exchange)`, esta línea pasa la solicitud al siguiente filtro o al manejador de la solicitud si no hay
  más filtros.
- `Mono<Void>`, el filtro devuelve un `Mono` (de Reactor), lo que indica que el filtro es asíncrono. Es una forma de
  trabajar con operaciones reactivas. La ejecución de este filtro es asíncrona, por lo que puedes encadenar otras
  operaciones (como la manipulación de la respuesta).
- `.then(Mono.fromRunnable(() -> { ... }))`, después de que la solicitud haya pasado por la cadena de filtros, este
  bloque se ejecuta para procesar la respuesta (POST) del gateway. Este código se ejecuta después de que se haya
  procesado la respuesta. Aquí también estás registrando un mensaje de log.

**Resumen del flujo del filtro:**

- `Pre-procesamiento`, antes de que la solicitud sea manejada por los siguientes filtros, se registra un mensaje
  indicando que el filtro está ejecutándose (filtro request PRE).
- `Post-procesamiento`, después de que todos los filtros hayan procesado la solicitud y antes de que la respuesta se
  envíe al cliente, se ejecuta un bloque de código para registrar un mensaje indicando que el filtro se está ejecutando
  en la respuesta POST.

## Modificando el response en el filtro post

En este apartado nos vamos a apoyar del filtro global para agregar una cookie al momento de que la respuesta regrese
al cliente.

Entonces, en el filtro global `SampleGlobalFilter` del `gateway-server` agregamos el siguiente código.

````java

@Slf4j
@Component
public class SampleGlobalFilter implements GlobalFilter {
    @Override
    public Mono<Void> filter(ServerWebExchange exchange, GatewayFilterChain chain) {
        log.info("Global: ejecutando filtro request PRE");

        return chain.filter(exchange)
                .then(Mono.fromRunnable(() -> {
                    log.info("Global: ejecutando filtro response POST");

                    exchange.getResponse()
                            .getCookies()
                            .add("color", ResponseCookie.from("color", "red").build());
                }));
    }
}
````

Ahora, levantamos las aplicaciones en el siguiente orden y veamos el comportamiento.

- Eureka Server
- Microservicios (product-service, item-service)
- Gateway Server

En la siguiente petición, observemos que estamos recibiendo como respuesta, además de la información consultada, el
cookie que definimos en la respuesta `set-cookie: color=red`.

````bash
$ curl -v -G --data "quantity=10" http://localhost:8090/api/v1/items/1 | jq
>
< HTTP/1.1 200 OK
< transfer-encoding: chunked
< Content-Type: application/json
< Date: Wed, 09 Apr 2025 20:18:28 GMT
< set-cookie: color=red
<
{
  "product": {
    "id": 1,
    "name": "Panasonic",
    "price": 800.00,
    "createAt": "2025-04-09T15:17:09",
    "port": 57420
  },
  "quantity": 10,
  "total": 8000.00
}
````

Si revisamos los logs del gateway-server, vemos que los logs se están imprimiendo correctamente.

````bash
INFO 3196 --- [gateway-server] [ctor-http-nio-2] d.m.g.s.app.filter.SampleGlobalFilter    : Global: ejecutando filtro request PRE
INFO 3196 --- [gateway-server] [ctor-http-nio-2] d.m.g.s.app.filter.SampleGlobalFilter    : Global: ejecutando filtro response POST
````
