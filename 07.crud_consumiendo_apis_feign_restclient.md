# Sección 07: CRUD Consumiendo nuestras APIS con Feign y RestClient

---

## Consumiendo API Rest con RestClient desde item-service

Lo que haremos en este apartado es que desde el microservicio `item-service` realizaremos las operaciones que se harían
directamente desde el propio `product-service`. Es decir, el `crud` de producto se puede hacer directamente desde el
propio `product-service`, pero a modo de práctica es que esas operaciones las haremos desde el `item-service` para
ver la comunicación entre microservicios.

Iniciamos creando el record `ProductRequest` que contendrá la información enviada en los request.

````java
public record ProductRequest(String name,
                             BigDecimal price) {
}
````

En la interfaz `ItemService` agregaremos al final, los últimos tres métodos para la implementación del crud de
productos.

````java
public interface ItemService {
    List<Item> findItems();

    Item findItemByProductId(Long productId, int quantity);

    Product saveProduct(ProductRequest productRequest);

    Product updateProduct(Long productId, ProductRequest productRequest);

    void deleteProduct(Long productId);
}
````

En la implementación `ItemServiceWithRestClientImpl` sobreescribimos los métodos agregados anteriormente y lo
implementamos haciendo uso del cliente `RestClient`.

````java

@Slf4j
@Service
public class ItemServiceWithRestClientImpl implements ItemService {

    private final RestClient productRestClient;

    public ItemServiceWithRestClientImpl(@Qualifier("productRestClient") RestClient.Builder restClientBuilder) {
        this.productRestClient = restClientBuilder.build();
    }

    @Override
    public List<Item> findItems() {/* code */}

    @Override
    public Item findItemByProductId(Long productId, int quantity) {/* code */}

    @Override
    public Product saveProduct(ProductRequest productRequest) {
        return this.productRestClient.post()
                .contentType(MediaType.APPLICATION_JSON)
                .body(productRequest)
                .retrieve()
                .body(Product.class);
    }

    @Override
    public Product updateProduct(Long productId, ProductRequest productRequest) {
        return this.productRestClient.put()
                .uri("/{productId}", productId)
                .contentType(MediaType.APPLICATION_JSON)
                .body(productRequest)
                .retrieve()
                .onStatus(HttpStatusCode::is4xxClientError, (request, response) -> {
                    String bodyMessage = Util.readInputStream(response.getBody());
                    throw new NoSuchElementException(ItemConstant.NO_FOUND_ELEMENT_MESSAGE.formatted(productId).concat(". ").concat(bodyMessage));
                })
                .body(Product.class);
    }

    @Override
    public void deleteProduct(Long productId) {
        this.productRestClient.delete()
                .uri("/{productId}", productId)
                .retrieve()
                .onStatus(HttpStatusCode::is4xxClientError, (request, response) -> {
                    String bodyMessage = Util.readInputStream(response.getBody());
                    throw new NoSuchElementException(ItemConstant.NO_FOUND_ELEMENT_MESSAGE.formatted(productId).concat(". ").concat(bodyMessage));
                })
                .toBodilessEntity();
    }
}
````

Como en nuestro `item-service` tenemos dos implementaciones de la interfaz `ItemService`, debemos sobreescribir esos
métodos en todas las implementaciones concretas. Más adelante trabajaremos con la implementación concreta
`ItemServiceImpl` haciendo uso del `FeignClient`.

````java

@Slf4j
@RequiredArgsConstructor
@Service
public class ItemServiceImpl implements ItemService {

    private final ProductFeignClient productFeignClient;

    @Override
    public List<Item> findItems() {/* code */}

    @Override
    public Item findItemByProductId(Long productId, int quantity) {/* code */}

    @Override
    public Product saveProduct(ProductRequest request) {
        return null;
    }

    @Override
    public Product updateProduct(Long productId, ProductRequest request) {
        return null;
    }

    @Override
    public void deleteProduct(Long productId) {

    }
}
````

## Implementando handler CRUD en controlador de item-service

Implementamos el controlador del `item-service` con los nuevos métodos definidos en el servicio.

````java

@RefreshScope
@Slf4j
@RestController
@RequestMapping(path = "/api/v1/items")
public class ItemController {

    private final ItemService itemService;
    private final CircuitBreakerFactory circuitBreakerFactory;
    private final Environment environment;

    /* code */

    @PostMapping(path = "/for-product")
    public ResponseEntity<Product> saveProduct(@RequestBody ProductRequest productRequest) {
        Product productResponse = this.itemService.saveProduct(productRequest);
        URI location = URI.create("/api/v1/products/%d".formatted(productResponse.id()));
        return ResponseEntity.created(location).body(productResponse);
    }

    @PutMapping(path = "/for-product/{productId}")
    public ResponseEntity<Product> updateProduct(@PathVariable Long productId, @RequestBody ProductRequest productRequest) {
        return ResponseEntity.ok(this.itemService.updateProduct(productId, productRequest));
    }

    @DeleteMapping(path = "/for-product/{productId}")
    public ResponseEntity<Void> deleteProduct(@PathVariable Long productId) {
        this.itemService.deleteProduct(productId);
        return ResponseEntity.noContent().build();
    }
}
````
