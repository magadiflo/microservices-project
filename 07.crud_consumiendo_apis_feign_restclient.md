# Sección 07: CRUD Consumiendo nuestras APIS con Feign y RestClient

---

## Consumiendo API Rest con RestClient desde item-service

Lo que haremos en este apartado es que desde el microservicio `item-service` realizaremos las operaciones que se harían
directamente desde el propio `product-service`. Es decir, el `crud` de producto se puede hacer directamente desde el
propio `product-service`, pero a modo de práctica es que esas operaciones las haremos desde el `item-service` para
ver la comunicación entre microservicios.

Iniciamos creando el record `ProductRequest` que contendrá la información enviada en los request.

````java
public record ProductRequest(String name,
                             BigDecimal price) {
}
````

En la interfaz `ItemService` agregaremos al final, los últimos tres métodos para la implementación del crud de
productos.

````java
public interface ItemService {
    List<Item> findItems();

    Item findItemByProductId(Long productId, int quantity);

    Product saveProduct(ProductRequest productRequest);

    Product updateProduct(Long productId, ProductRequest productRequest);

    void deleteProduct(Long productId);
}
````

En la implementación `ItemServiceWithRestClientImpl` sobreescribimos los métodos agregados anteriormente y lo
implementamos haciendo uso del cliente `RestClient`.

````java

@Slf4j
@Service
public class ItemServiceWithRestClientImpl implements ItemService {

    private final RestClient productRestClient;

    public ItemServiceWithRestClientImpl(@Qualifier("productRestClient") RestClient.Builder restClientBuilder) {
        this.productRestClient = restClientBuilder.build();
    }

    @Override
    public List<Item> findItems() {/* code */}

    @Override
    public Item findItemByProductId(Long productId, int quantity) {/* code */}

    @Override
    public Product saveProduct(ProductRequest productRequest) {
        return this.productRestClient.post()
                .contentType(MediaType.APPLICATION_JSON)
                .body(productRequest)
                .retrieve()
                .body(Product.class);
    }

    @Override
    public Product updateProduct(Long productId, ProductRequest productRequest) {
        return this.productRestClient.put()
                .uri("/{productId}", productId)
                .contentType(MediaType.APPLICATION_JSON)
                .body(productRequest)
                .retrieve()
                .onStatus(HttpStatusCode::is4xxClientError, (request, response) -> {
                    String bodyMessage = Util.readInputStream(response.getBody());
                    throw new NoSuchElementException(ItemConstant.NO_FOUND_ELEMENT_MESSAGE.formatted(productId).concat(". ").concat(bodyMessage));
                })
                .body(Product.class);
    }

    @Override
    public void deleteProduct(Long productId) {
        this.productRestClient.delete()
                .uri("/{productId}", productId)
                .retrieve()
                .onStatus(HttpStatusCode::is4xxClientError, (request, response) -> {
                    String bodyMessage = Util.readInputStream(response.getBody());
                    throw new NoSuchElementException(ItemConstant.NO_FOUND_ELEMENT_MESSAGE.formatted(productId).concat(". ").concat(bodyMessage));
                })
                .toBodilessEntity();
    }
}
````

Como en nuestro `item-service` tenemos dos implementaciones de la interfaz `ItemService`, debemos sobreescribir esos
métodos en todas las implementaciones concretas. Más adelante trabajaremos con la implementación concreta
`ItemServiceImpl` haciendo uso del `FeignClient`.

````java

@Slf4j
@RequiredArgsConstructor
@Service
public class ItemServiceImpl implements ItemService {

    private final ProductFeignClient productFeignClient;

    @Override
    public List<Item> findItems() {/* code */}

    @Override
    public Item findItemByProductId(Long productId, int quantity) {/* code */}

    @Override
    public Product saveProduct(ProductRequest request) {
        return null;
    }

    @Override
    public Product updateProduct(Long productId, ProductRequest request) {
        return null;
    }

    @Override
    public void deleteProduct(Long productId) {

    }
}
````

## Implementando handler CRUD en controlador de item-service

Implementamos el controlador del `item-service` con los nuevos métodos definidos en el servicio.

````java

@RefreshScope
@Slf4j
@RestController
@RequestMapping(path = "/api/v1/items")
public class ItemController {

    private final ItemService itemService;
    private final CircuitBreakerFactory circuitBreakerFactory;
    private final Environment environment;

    /* code */

    @PostMapping(path = "/for-product")
    public ResponseEntity<Product> saveProduct(@RequestBody ProductRequest productRequest) {
        Product productResponse = this.itemService.saveProduct(productRequest);
        URI location = URI.create("/api/v1/products/%d".formatted(productResponse.id()));
        return ResponseEntity.created(location).body(productResponse);
    }

    @PutMapping(path = "/for-product/{productId}")
    public ResponseEntity<Product> updateProduct(@PathVariable Long productId, @RequestBody ProductRequest productRequest) {
        return ResponseEntity.ok(this.itemService.updateProduct(productId, productRequest));
    }

    @DeleteMapping(path = "/for-product/{productId}")
    public ResponseEntity<Void> deleteProduct(@PathVariable Long productId) {
        this.itemService.deleteProduct(productId);
        return ResponseEntity.noContent().build();
    }
}
````

## Probando operaciones CRUD en item-service

Hasta este punto hemos terminado de implementar las operaciones de registrar, actualizar y eliminar productos pero desde
el `item-service`. Como dijimos, con esto estamos viendo cómo es que los microservicios se comunican entre sí, en ese
caso haciendo uso del cliente `RestClient`.

Iniciamos las aplicaciones en este orden:

- config-server
- discovery-server
- product-service
- item-service
- gateway-server

Guardamos un producto desde `item-service` hacia el `product-service`.

````bash
$ curl -v -X POST -H "Content-Type: application/json" -d "{\"name\": \"Auricular Halio\", \"price\": 60}" http://localhost:8090/api/v1/items/for-product | jq
>
< HTTP/1.1 201 Created
< transfer-encoding: chunked
< Location: /api/v1/products/10
< Content-Type: application/json
< Date: Tue, 15 Apr 2025 17:21:55 GMT
< token-response: 123456
< X-Response-color: green
< set-cookie: color=red
<
{
  "id": 10,
  "name": "Auricular Halio",
  "price": 60,
  "createAt": "2025-04-15T12:21:55",
  "port": 49608
}
````

Actualizamos un producto desde `item-service` hacia el `product-service`.

````bash
$ curl -v -X PUT -H "Content-Type: application/json" -d "{\"name\": \"Phone Huawei\", \"price\": 890.60}" http://localhost:8090/api/v1/items/for-product/10 | jq
>
< HTTP/1.1 200 OK
< transfer-encoding: chunked
< Content-Type: application/json
< Date: Tue, 15 Apr 2025 17:24:33 GMT
< token-response: 123456
< X-Response-color: green
< set-cookie: color=red
<
{
  "id": 10,
  "name": "Phone Huawei",
  "price": 890.60,
  "createAt": "2025-04-15T12:21:55",
  "port": 49608
}
````

Eliminamos un producto desde `item-service` hacia el `product-service`.

````bash
$ curl -v -X DELETE http://localhost:8090/api/v1/items/for-product/10 | jq
>
< HTTP/1.1 204 No Content
< Date: Tue, 15 Apr 2025 17:25:56 GMT
< token-response: 123456
< X-Response-color: green
< set-cookie: color=red
<
````

Actualizamos un producto que no existe desde `item-service` hacia el `product-service`.

````bash
$ curl -v -X PUT -H "Content-Type: application/json" -d "{\"name\": \"Phone Huawei\", \"price\": 890.60}" http://localhost:8090/api/v1/items/for-product/10 | jq
>
< HTTP/1.1 404 Not Found
< transfer-encoding: chunked
< Content-Type: application/json
< Date: Tue, 15 Apr 2025 17:27:39 GMT
< token-response: 123456
< X-Response-color: green
< set-cookie: color=red
<
{
  "status": 404,
  "error": "Not Found",
  "message": "The product with id 10 does not exist in product-service. {\"status\":404,\"error\":\"Not Found\",\"message\":\"The product with id 10 does not exist\",\"path\":\"/api/v1/products/10\",\"timestamp\":\"2025-04-15T12:27:39\"}",
  "path": "/api/v1/items/for-product/10",
  "timestamp": "2025-04-15T12:27:39"
}
````
