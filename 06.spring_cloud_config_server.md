# Sección 06: Spring Cloud Config Server - Centralizando la configuración

---

## Creando el servidor de configuración

Creamos el proyecto `config-server` desde
[Spring Initializr](https://start.spring.io/#!type=maven-project&language=java&platformVersion=3.4.4&packaging=jar&jvmVersion=21&groupId=dev.magadiflo&artifactId=config-server&name=config-server&description=Config%20Server&packageName=dev.magadiflo.config.server.app&dependencies=actuator,cloud-config-server)
con las siguientes dependencias.

````xml
<!--Spring Boot 3.4.4-->
<!--Spring Cloud Version 2024.0.1-->
<!--Java 21-->
<dependencies>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-actuator</artifactId>
    </dependency>
    <dependency>
        <groupId>org.springframework.cloud</groupId>
        <artifactId>spring-cloud-config-server</artifactId>
    </dependency>

    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-test</artifactId>
        <scope>test</scope>
    </dependency>
</dependencies>
````

Habilitamos el proyecto `config-server` como un servidor de configuraciones agregando la anotación `@EnableConfigServer`
en la clase principal.

````java

@EnableConfigServer
@SpringBootApplication
public class ConfigServerApplication {
    public static void main(String[] args) {
        SpringApplication.run(ConfigServerApplication.class, args);
    }
}
````

En el `application.yml` agregamos las siguientes configuraciones.

````yml
server:
  port: 8888
  error:
    include-message: always

spring:
  application:
    name: config-server
  cloud:
    config:
      server:
        git:
          uri: file:///D:/programming/spring/01.udemy/02.andres_guzman/06.microservices_netflix_eureka/config-server-repo
````

- `spring.cloud.config.server.git.uri`, le estamos diciendo al servidor que busque los archivos de configuración en un
  repositorio `Git local`. Usar `file:///` es totalmente válido durante el desarrollo, y apunta a una carpeta local que
  simula el repositorio.


- `En Sistemas Unix (Linux/Mack)`, las rutas se escriben con una sola barra normal `/`. Por ejemplo
  `file:/Users/config`.


- `En windows`, las rutas se escriben con 3 barras. Por ejemplo: `file:///D:/programming/config`.

Esa ruta debe contener archivos `.properties` o `.yml` con nombres similares a cómo se muestra a continuación, que es
como el `config server` busca los archivos.

> `nombre-aplicacion.yml` o `nombre-aplicacion-profile.yml`

## Crea archivo de configuración en repositorio local

En nuestro directorio del repositorio local crearemos el archivo `item-service.yml` correspondiente al nombre del
microservicio `item-service`. Las configuraciones que agreguemos en este archivo se aplicarán a dicho microservicio por
eso es importante seguir la convención al nombrar el archivo.

Estoy trabajando en windows, pero como para practicar el uso de `linux` es que también trabajaré con `wsl` con una
distribución de `linux` instalada, en mi caso `Ubuntu`. Se puede seguir este apartado que es la creación del archivo
`item-service.yml` agregando cierta configuración, simplemente haciendo uso de algún editor en windows y crearlo
manualmente como cualquier archivo, pero en mi caso, haré uso de esta forma como para ir practicando linux.

Así que, si listo las distribuciones wsl que tengo instaladas,
veremos los siguientes:

````bash
D:\programming\spring\01.udemy\02.andres_guzman\06.microservices_netflix_eureka\config-server-repo
$ wsl -l -v
  NAME              STATE           VERSION
* Ubuntu            Running         2
  docker-desktop    Stopped         2
````

Como se observa, tengo `Ubuntu` como distribución por defecto, así que si escribo `wsl` en la ruta donde estoy
posicionado, mi terminal se posicionará dentro de esa distribución en esa misma ruta.

````bash
D:\programming\spring\01.udemy\02.andres_guzman\06.microservices_netflix_eureka\config-server-repo
λ wsl
magadiflo@SysEngJava:/mnt/d/programming/spring/01.udemy/02.andres_guzman/06.microservices_netflix_eureka/config-server-repo$
````

Ahora, creo el archivo `item-service.yml` y listo el directorio para ver que fue creado.

````bash
magadiflo@SysEngJava:/mnt/d/programming/spring/01.udemy/02.andres_guzman/06.microservices_netflix_eureka/config-server-repo$ touch item-service.yml
magadiflo@SysEngJava:/mnt/d/programming/spring/01.udemy/02.andres_guzman/06.microservices_netflix_eureka/config-server-repo$ ls -l
total 0
-rwxrwxrwx 1 magadiflo magadiflo 0 Apr 14 11:27 item-service.yml
````

Para editar el archivo desde la terminal, usaré el comando `vim`.

````bash
magadiflo@SysEngJava:/mnt/d/programming/spring/01.udemy/02.andres_guzman/06.microservices_netflix_eureka/config-server-repo$ vim item-service.yml
````

Luego se nos abrirá en la misma terminal el editor `vim`. Presionamos `i` (`INSERT`) para agregar contenido al archivo.

![01.png](assets/section-06/01.png)

Si ya hemos terminado de agregar contenido al archivo, presionamos `ESC` y escribimos `:wq` (write, quit) más `Enter`.

![02.png](assets/section-06/02.png)

Verificamos el contenido del archivo `item-service.yml`.

````bash
magadiflo@SysEngJava:/mnt/d/programming/spring/01.udemy/02.andres_guzman/06.microservices_netflix_eureka/config-server-repo$ cat item-service.yml
server:
  port: 8085
````

## Creando el repositorio local y realizando commit

Agregamos una configuración adicional al `item-service.yml` ubicado en el repositorio local.

````yml
server:
  port: 8085

custom:
  text: item-service.yml en config server con perfil por defecto
````

A continuación, lo que haremos será inicializar el repositorio local con `git init`. Luego, lo agregamos al `staging`
para finalmente crear nuestro primer commit.

````bash
magadiflo@SysEngJava:/mnt/d/programming/spring/01.udemy/02.andres_guzman/06.microservices_netflix_eureka/config-server-repo$ git init
magadiflo@SysEngJava:/mnt/d/programming/spring/01.udemy/02.andres_guzman/06.microservices_netflix_eureka/config-server-repo$ git add .
magadiflo@SysEngJava:/mnt/d/programming/spring/01.udemy/02.andres_guzman/06.microservices_netflix_eureka/config-server-repo$ git commit -m "Agrega configuraciones para item-service.yml"
magadiflo@SysEngJava:/mnt/d/programming/spring/01.udemy/02.andres_guzman/06.microservices_netflix_eureka/config-server-repo$ git lg
* cf10bee (HEAD -> main) Agrega configuraciones para item-service.yml
````

## Prioridad de configuración entre el Config Server y el microservicio

Cuando usamos Spring Cloud Config Server, la configuración de los archivos application.properties o application.yml se
maneja de la siguiente forma:

1. `Fusión de propiedades`, las propiedades definidas dentro del `microservicio`
   `(application.properties o application.yml)` se combinan con las que vienen del `Config Server`.


2. `Prioridad de sobrescritura`, si una misma propiedad existe tanto en el `microservicio` como en el `Config Server`,
   entonces tendrá prioridad la del `Config Server`. Es decir, la configuración remota sobrescribe la local.


3. `Propiedades adicionales`, si hay propiedades que solo existen en uno de los dos lados, entonces se mantienen y se
   complementan. No se eliminan ni anulan entre sí.

#### Ejemplo práctico

Supongamos que tenemos en el `application.yml` del microservicio:

````yml
server:
  port: 8081
miapp:
  modo: local
````

Y en el archivo remoto `config-server-repo/miapp-dev.yml` tenemos:

````yml
server:
  port: 9090
miapp:
  mensaje: "Desde el config server"
````

El resultado final de las propiedades será:

````yml
server:
  port: 9090                          # Esta fue sobrescrita por el Config Server
miapp:
  modo: local                         # Esta viene del microservicio
  mensaje: "Desde el config server"   # Esta viene del Config Server
````

> La configuración del `Config Server` tiene prioridad sobre la `configuración local`. Si hay conflicto, gana el
> servidor. Si no hay conflicto, se combinan.

## Conectando servicio items al servidor de configuraciones

El `config-server` lee las configuraciones desde el `repositorio Git local` especificado en su `application.yml`, por lo
que podemos acceder a estas configuraciones a través de las `URLs` expuestas por el servidor.

Una vez que tenemos nuestro `Config Server` en ejecución, podemos acceder a las configuraciones de nuestros
microservicios mediante una URL con el siguiente formato:

> `http://<host>:<puerto>/<nombre-del-servicio>/<perfil>`

A continuación, accedemos a las configuraciones del `item-service` con perfil `default`.

````bash
$ curl -v http://localhost:8888/item-service/default | jq
>
< HTTP/1.1 200
< Content-Type: application/json
< Transfer-Encoding: chunked
< Date: Mon, 14 Apr 2025 17:14:38 GMT
<
{
  "name": "item-service",
  "profiles": [
    "default"
  ],
  "label": null,
  "version": "cf10bee2d84f342a8679c428f3a38fc0a5b40424",
  "state": "",
  "propertySources": [
    {
      "name": "file:///D:/programming/spring/01.udemy/02.andres_guzman/06.microservices_netflix_eureka/config-server-repo/item-service.yml",
      "source": {
        "server.port": 8085,
        "custom.text": "item-service.yml en config server con perfil por defecto"
      }
    }
  ]
}
````

**Donde**

- `localhost`: el host donde corre nuestro `config server` (puede ser IP también).
- `8888`: puerto del `config server` (por defecto).
- `item-service`: nombre del microservicio (`spring.application.name`).
- `default`: perfil activo que estás consultando (`default`, `dev`, `prod`, etc).

> Para verificar que el `Config Server` está funcionando correctamente y leyendo la configuración desde el repositorio
> Git, accedo a la URL `http://localhost:8888/{app-name}/{profile}`. Si la respuesta muestra las propiedades esperadas,
> la conexión está correcta.

Para que nuestro microservicio `item-service` se conectará al `config-server`, necesitamos agregar la dependencia de
`Config Client`. Esta dependencia es un cliente que se conecta a un servidor` Spring Cloud Config` para obtener la
configuración de la aplicación.

````xml

<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-config</artifactId>
</dependency>
````

Luego, en el `application.yml` del `item-service` agregamos la configuración para conectarnos al `config-server`.
La propiedad `spring.config.import` permitirá al `item-service` conectarse al servidor de configuración en la ubicación
especificada http://localhost:8888. La eliminación del prefijo `optional:` hará que el `Config Client` falle si no puede
conectarse al `Config Server`.

````yml
spring:
  application:
    name: item-service
  profiles:
    active: default
  config:
    import: optional:configserver:http://localhost:8888
````

## Leer configuración desde controlador utilizando la anotación @Value

En el controlador del `item-service` agregamos propiedades para capturar los valores configurados en los archivos de
propiedades. Estos valores los obtendremos usando la anotación `@Value` y dentro de él escribiendo la propiedad a
obtener. Podemos usar la anotación en una propiedad de instancia o en los parámetros de un método, en ambos casos el
valor será inyectado.

````java

@Slf4j
@RestController
@RequestMapping(path = "/api/v1/items")
public class ItemController {

    @Value("${custom.text}")
    private String text;

    /* code */

    @GetMapping(path = "/retrieve-configs")
    public ResponseEntity<Map<String, Object>> retrieveConfig(@Value("${server.port}") int port) {
        log.info("server.port: {}", port);
        log.info("custom.text: {}", this.text);

        return ResponseEntity.ok(Map.of(
                "custom.text", this.text,
                "server.port", port)
        );
    }
    /* code */
}
````

Ejecutamos las aplicaciones en el siguiente orden.

- config-server
- discovery-server
- item-service

A continuación se muestra el log del `item-service` quien muestra que primero se conecta al `config-server` para obtener
las propiedades de configuración. Estas propiedades tendrán mayor prioridad que aquellas propiedades que tenga la propia
aplicación `item-service`. Por esa razón, observamos que el puerto que toma es el `8085` definido en el `config-server`.

````bash
  .   ____          _            __ _ _
 /\\ / ___'_ __ _ _(_)_ __  __ _ \ \ \ \
( ( )\___ | '_ | '_| | '_ \/ _` | \ \ \ \
 \\/  ___)| |_)| | | | | || (_| |  ) ) ) )
  '  |____| .__|_| |_|_| |_\__, | / / / /
 =========|_|==============|___/=/_/_/_/

 :: Spring Boot ::                (v3.4.4)

d.m.item.app.ItemServiceApplication      : Starting ItemServiceApplication using Java 21.0.6 with PID 11696 (D:\programming\spring\01.udemy\02.andres_guzman\06.microservices_netflix_eureka\microservices-project\business-domain\item-service\target\classes started by magadiflo in D:\programming\spring\01.udemy\02.andres_guzman\06.microservices_netflix_eureka\microservices-project)
d.m.item.app.ItemServiceApplication      : The following 1 profile is active: "default"
o.s.c.c.c.ConfigServerConfigDataLoader   : Fetching config from server at : http://localhost:8888
o.s.c.c.c.ConfigServerConfigDataLoader   : Located environment: name=item-service, profiles=[default], label=null, version=cf10bee2d84f342a8679c428f3a38fc0a5b40424, state=
o.s.cloud.context.scope.GenericScope     : BeanFactory id=cc0c83f3-5c77-383d-ad1a-dabb2a677711
o.s.b.w.embedded.tomcat.TomcatWebServer  : Tomcat initialized with port 8085 (http)
o.apache.catalina.core.StandardService   : Starting service [Tomcat]
o.apache.catalina.core.StandardEngine    : Starting Servlet engine: [Apache Tomcat/10.1.39]
...
com.netflix.discovery.DiscoveryClient    : Discovery Client initialized at timestamp 1744662749770 with initial instances count: 1
o.s.c.n.e.s.EurekaServiceRegistry        : Registering application ITEM-SERVICE with eureka with status UP
...
o.s.b.w.embedded.tomcat.TomcatWebServer  : Tomcat started on port 8085 (http) with context path '/'
.s.c.n.e.s.EurekaAutoServiceRegistration : Updating port to 8085
com.netflix.discovery.DiscoveryClient    : DiscoveryClient_ITEM-SERVICE/SysEngJava:item-service:a4c96d41ced1a1a81716da120c2bcc92 - registration status: 204
d.m.item.app.ItemServiceApplication      : Started ItemServiceApplication in 7.803 seconds (process running for 8.775)
````

Ejecutamos el endpointq ue construimos para ver los valores que ha tomado nuestra aplicación.

````bash
$ curl -v http://localhost:8085/api/v1/items/retrieve-configs | jq
>
< HTTP/1.1 200
< Content-Type: application/json
< Transfer-Encoding: chunked
< Date: Mon, 14 Apr 2025 20:31:32 GMT
<
{
  "server.port": 8085,
  "custom.text": "item-service.yml en config server con perfil por defecto"
}
````

## Configurando los ambientes en el repositorio Git

En nuestro repositorio `local de git` que está ubicado en
`D:\programming\spring\01.udemy\02.andres_guzman\06.microservices_netflix_eureka\config-server-repo` vamos a crear
nuevos archivos de configuración.

Para el `item-service` crearemos el archivo para el perfil `dev` llamado `item-service-dev.yml` y agregamos las
siguientes configuraciones.

````yml
custom:
  text: item-service-dev.yml en config server con perfil dev
  author:
    name: Martín
    email: magadiflo@gmail.com
````

Para el `item-service` crearemos el archivo para el perfil `prod` llamado `item-service-prod.yml` y agregamos las
siguientes configuraciones.

````yml
server:
  port: 8007
custom:
  text: item-service-prod.yml en config server con perfil prod
````

Luego guardamos los cambios haciendo el commit al repositorio.

````bash
magadiflo@SysEngJava:/mnt/d/programming/spring/01.udemy/02.andres_guzman/06.microservices_netflix_eureka/config-server-repo$ git add .
magadiflo@SysEngJava:/mnt/d/programming/spring/01.udemy/02.andres_guzman/06.microservices_netflix_eureka/config-server-repo$ git commit -m "Agrega perfil dev y prod para el item-service"
````

Ahora, vamos a levantar el `config-server` y a consultar por cada uno de los perfiles que agregamos para ver que nuestro
servidor de configuraciones los esté leyendo correctamente.

Consultamos por el perfil `dev` del `item-service`.

````bash
$ curl -v http://localhost:8888/item-service/dev | jq
>
< HTTP/1.1 200
< Content-Type: application/json
< Transfer-Encoding: chunked
< Date: Mon, 14 Apr 2025 21:18:24 GMT
<
{
  "name": "item-service",
  "profiles": [
    "dev"
  ],
  "label": null,
  "version": "0d4d6870661e85f9ec4df79a6b439254a365d0c2",
  "state": "",
  "propertySources": [
    {
      "name": "file:///D:/programming/spring/01.udemy/02.andres_guzman/06.microservices_netflix_eureka/config-server-repo/item-service-dev.yml",
      "source": {
        "custom.text": "item-service-dev.yml en config server con perfil dev",
        "custom.author.name": "Martín",
        "custom.author.email": "magadiflo@gmail.com"
      }
    },
    {
      "name": "file:///D:/programming/spring/01.udemy/02.andres_guzman/06.microservices_netflix_eureka/config-server-repo/item-service.yml",
      "source": {
        "server.port": 8085,
        "custom.text": "item-service.yml en config server con perfil por defecto"
      }
    }
  ]
}
````

Consultamos por el perfil `prod` del `item-service`.

````bash
$ curl -v http://localhost:8888/item-service/prod | jq
>
< HTTP/1.1 200
< Content-Type: application/json
< Transfer-Encoding: chunked
< Date: Mon, 14 Apr 2025 21:19:37 GMT
<
{
  "name": "item-service",
  "profiles": [
    "prod"
  ],
  "label": null,
  "version": "0d4d6870661e85f9ec4df79a6b439254a365d0c2",
  "state": "",
  "propertySources": [
    {
      "name": "file:///D:/programming/spring/01.udemy/02.andres_guzman/06.microservices_netflix_eureka/config-server-repo/item-service-prod.yml",
      "source": {
        "server.port": 8007,
        "custom.text": "item-service-prod.yml en config server con perfil prod"
      }
    },
    {
      "name": "file:///D:/programming/spring/01.udemy/02.andres_guzman/06.microservices_netflix_eureka/config-server-repo/item-service.yml",
      "source": {
        "server.port": 8085,
        "custom.text": "item-service.yml en config server con perfil por defecto"
      }
    }
  ]
}
````

## Configurando profiles en item-service

En el `application.yml` del `item-service` agregamos la configuración `spring.profiles.active` para definir el perfil
que ejecutaremos. En este caso, ejecutaremos la aplicación con el perfil `dev`.

````yml
spring:
  application:
    name: item-service
  profiles:
    active: dev
````

Para ver la información que estamos recibiendo de los archivos de propiedades, vamos a apoyarnos de la interface
`Environment`, mismo que lo inyectaremos a través del constructor. Luego, usaremos su método `getProperty()` para
obtener el valor de la propiedad.

````java

@Slf4j
@RestController
@RequestMapping(path = "/api/v1/items")
public class ItemController {

    private final ItemService itemService;
    private final CircuitBreakerFactory circuitBreakerFactory;
    private final Environment environment;

    @Value("${custom.text}")
    private String text;

    /* code */

    @GetMapping(path = "/retrieve-configs")
    public ResponseEntity<Map<String, Object>> retrieveConfig(@Value("${server.port}") int port) {
        log.info("server.port: {}", port);
        log.info("custom.text: {}", this.text);
        log.info("custom.author.name: {}", this.environment.getProperty("custom.author.name"));
        log.info("custom.author.email: {}", this.environment.getProperty("custom.author.email"));

        return ResponseEntity.ok(Map.of(
                "custom.text", this.text,
                "server.port", port,
                "custom.author.name", this.environment.getProperty("custom.author.name"),
                "custom.author.email", this.environment.getProperty("custom.author.email"))
        );
    }
    /* code */
}
````

Ejecutamos las aplicaciones en el siguiente orden.

- config-server
- discovery-server
- item-service

Ahora realizamos una petición al `item-service`. Como resultado, podemos ver que los valores corresponden a las
configuraciones realizadas en el `item-service-dev.yml`, a excepción del `server.port`, que corresponde al archivo
por default `item-service.yml`

````bash
$ curl -v http://localhost:8085/api/v1/items/retrieve-configs | jq
>
< HTTP/1.1 200
< Content-Type: application/json
< Transfer-Encoding: chunked
< Date: Mon, 14 Apr 2025 21:42:36 GMT
<
{
  "custom.author.name": "Martín",
  "custom.text": "item-service-dev.yml en config server con perfil dev",
  "server.port": 8085,
  "custom.author.email": "magadiflo@gmail.com"
}
````

Si ahora cambiamos el `spring.profile.active` a `prod`, podremos ver las configuraciones correspondientes a dicho
perfil.

````yml
spring:
  application:
    name: item-service
  profiles:
    active: prod
````

Si seleccionamos el perfil `prod`, nos muestra en consola las configuraciones de prod. Obviamente, las configuraciones
que aparecen con `null` son configuraciones que este perfil no las tiene ni tampoco las tiene el perfil por defecto.

````bash
d.m.item.app.controller.ItemController   : server.port: 8007
d.m.item.app.controller.ItemController   : custom.text: item-service-prod.yml en config server con perfil prod
d.m.item.app.controller.ItemController   : custom.author.name: null
d.m.item.app.controller.ItemController   : custom.author.email: null
````
