# Sección 02: Comenzando con los microservicios

---

## Creando nuestro microservicio products

Iniciamos creando el `product-service` desde
[Spring Initializr](https://start.spring.io/#!type=maven-project&language=java&platformVersion=3.4.4&packaging=jar&jvmVersion=21&groupId=dev.magadiflo&artifactId=product-service&name=product-service&description=Product%20Service%20Project&packageName=dev.magadiflo.product.app&dependencies=web,data-jpa,lombok,mysql,cloud-starter)
con las siguientes dependencias.

````xml
<!--Spring Boot 3.4.4-->
<!--Java 21-->
<!--Spring Cloud Version 2024.0.1-->
<dependencies>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-data-jpa</artifactId>
    </dependency>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-web</artifactId>
    </dependency>
    <dependency>
        <groupId>org.springframework.cloud</groupId>
        <artifactId>spring-cloud-starter</artifactId>
    </dependency>

    <dependency>
        <groupId>com.mysql</groupId>
        <artifactId>mysql-connector-j</artifactId>
        <scope>runtime</scope>
    </dependency>
    <dependency>
        <groupId>org.projectlombok</groupId>
        <artifactId>lombok</artifactId>
        <optional>true</optional>
    </dependency>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-test</artifactId>
        <scope>test</scope>
    </dependency>
</dependencies>
````

**Nota**
> En `spring initializr` agregamos la dependencia `Cloud Bootstrap` simplemente para que desde el principio tengamos la
> versión de `Spring Cloud`.

**Importante**
> Cada versión de `Spring Boot` tiene su correspondiente versión específica de `Spring Cloud`.

Configuramos el `application.yml` del `product-service` con las siguientes propiedades:

````yml
server:
  port: 8001
  error:
    include-message: always

spring:
  application:
    name: product-service
````

## Añadiendo la clase Entity JPA

Creamos la entidad `Product` con anotaciones de `jpa`. Además, nos apoyamos de las anotaciones de `Lombok` para evitar
el boilerplate (código repetitivo).

````java

@ToString
@AllArgsConstructor
@NoArgsConstructor
@Builder
@Getter
@Setter
@Entity
@Table(name = "products")
public class Product {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    private String name;
    private BigDecimal price;
    private LocalDateTime createAt;
}
````

## Creando el repositorio JPA con Spring Data JPA

En el microservicio `product-service`, creamos el repositorio `ProductRepository` para la entidad `Product`.

````java
public interface ProductRepository extends CrudRepository<Product, Long> {
}
````

## Creando el Servicio para la lógica de negocio

En este apartado crearemos la capa de servicio para nuestro `product-service`, pero para eso, necesitamos crear
clases de utilidades adicionales.

Empezamos creando la clase dto para mapear la información que se envía al endpoint.

````java
public record ProductRequest(String name,
                             BigDecimal price) {
}
````

El dto que nos permitirá enviar información a través de los endpoints.

````java
public record ProductResponse(Long id,
                              String name,
                              BigDecimal price,
                              LocalDateTime createAt) {
}
````

También es necesario crear una clase donde almacenaremos las distintas constantes para todo lo relacionado con
productos.

````java

@UtilityClass
public class ProductConstant {
    public static final String NO_SUCH_ELEMENT_MESSAGE = "The product with id %d does not exist";
}
````

**Importante**
> La anotación `@UtilityClass`:<br>
> - Hace la clase final (no se puede extender).<br>
> - Agrega un constructor privado, para que no se pueda instanciar.<br>
> - Convierte todos los métodos y campos en static.<br>

Una clase importante es la clase de utilidad que nos permitirá mapear nuestra entidad a un dto y viceversa. Según la
información proporcionada por Chat-GPT, es mejor definir esta clase de utilidad como un `@Component` dado que estamos
trabajando con Spring Boot, además Spring promueve trabajar con `instancias` y `beans` para favorecer la flexibilidad y
el testing. Podría haber optado por hacer la clase con método estáticos, es decir, usar la anotación de `Lombok` como
el `@UtilityClass`, pero según la recomendación es mejor hacerlo como un componente de spring.

````java

@Component
public class ProductMapper {

    public ProductResponse toProductResponse(Product product) {
        return new ProductResponse(product.getId(), product.getName(), product.getPrice(), product.getCreateAt());
    }

    public Product toProduct(ProductRequest request) {
        return Product.builder()
                .name(request.name())
                .price(request.price())
                .createAt(LocalDateTime.now().truncatedTo(ChronoUnit.SECONDS))
                .build();
    }

    public Product toUpdateProduct(Product productDB, ProductRequest request) {
        productDB.setName(request.name());
        productDB.setPrice(request.price());
        return productDB;
    }
}
````

**Donde**

`LocalDateTime.now().truncatedTo(ChronoUnit.SECONDS)`, esta instrucción obtiene la fecha y hora actual del sistema
`(LocalDateTime.now())`, pero truncada a nivel de segundos, eliminando cualquier precisión menor (como milisegundos,
microsegundos y nanosegundos).

**¿Por qué se utiliza?**

- Para evitar diferencias de precisión entre el valor generado en la aplicación y el valor realmente almacenado en la
  base de datos (por ejemplo, `MySQL` suele almacenar solo hasta microsegundos).
- Para mantener un formato uniforme de fecha y hora en los registros `(yyyy-MM-ddTHH:mm:ss)`.
- Facilita la comparación de fechas y mejora la legibilidad de los datos.
- Ejemplo: `LocalDateTime.now().truncatedTo(ChronoUnit.SECONDS); //2025-04-07T11:49:16`

Finalmente, implementamos la clase de servicio del producto.

````java

@Slf4j
@RequiredArgsConstructor
@Service
@Transactional(readOnly = true)
public class ProductServiceImpl implements ProductService {

    private final ProductMapper productMapper;
    private final ProductRepository productRepository;

    @Override
    public List<ProductResponse> findProducts() {
        return ((List<Product>) this.productRepository.findAll()).stream()
                .map(this.productMapper::toProductResponse)
                .toList();
    }

    @Override
    public ProductResponse findProduct(Long productId) {
        return this.productRepository.findById(productId)
                .map(this.productMapper::toProductResponse)
                .orElseThrow(() -> new NoSuchElementException(ProductConstant.NO_SUCH_ELEMENT_MESSAGE.formatted(productId)));
    }

    @Override
    @Transactional
    public ProductResponse saveProduct(ProductRequest request) {
        Product productDB = this.productRepository.save(this.productMapper.toProduct(request));
        return this.productMapper.toProductResponse(productDB);
    }

    @Override
    @Transactional
    public ProductResponse updateProduct(Long productId, ProductRequest request) {
        return this.productRepository.findById(productId)
                .map(productDB -> this.productMapper.toUpdateProduct(productDB, request))
                .map(this.productRepository::save)
                .map(this.productMapper::toProductResponse)
                .orElseThrow(() -> new NoSuchElementException(ProductConstant.NO_SUCH_ELEMENT_MESSAGE.formatted(productId)));
    }

    @Override
    @Transactional
    public void deleteProduct(Long productId) {
        Product productDB = this.productRepository.findById(productId)
                .orElseThrow(() -> new NoSuchElementException(ProductConstant.NO_SUCH_ELEMENT_MESSAGE.formatted(productId)));
        this.productRepository.deleteById(productDB.getId());
    }
}
````

**Importante:<br>
[The best way to use the Spring Transactional annotation](https://vladmihalcea.com/spring-transactional-annotation/)**

> Notar que estamos definiendo la anotación `@Transactional(readOnly = true)` al nivel de clase, lo que significa que,
> por defecto, todos los métodos de servicio usarán esta configuración y se ejecutarán en una transacción de solo
> lectura, a menos que el método anule la configuración transaccional con su propia definición de `@Transactional`, tal
> como se ve en los métodos `saveProduct(), updateProduct() y deleteProduct()`.

## Creando el controlador Rest

Creamos el controlador para nuestro `product-service`.

````java

@Slf4j
@RequiredArgsConstructor
@RestController
@RequestMapping(path = "/api/v1/products")
public class ProductController {

    private final ProductService productService;

    @GetMapping
    public ResponseEntity<List<ProductResponse>> findProducts() {
        return ResponseEntity.ok(this.productService.findProducts());
    }

    @GetMapping(path = "/{productId}")
    public ResponseEntity<ProductResponse> findProduct(@PathVariable Long productId) {
        return ResponseEntity.ok(this.productService.findProduct(productId));
    }

    @PostMapping
    public ResponseEntity<ProductResponse> saveProduct(@RequestBody ProductRequest productRequest) {
        ProductResponse productResponse = this.productService.saveProduct(productRequest);
        URI location = URI.create("/api/v1/products/%d".formatted(productResponse.id()));
        return ResponseEntity.created(location).body(productResponse);
    }

    @PutMapping(path = "/{productId}")
    public ResponseEntity<ProductResponse> updateProduct(@PathVariable Long productId, @RequestBody ProductRequest productRequest) {
        return ResponseEntity.ok(this.productService.updateProduct(productId, productRequest));
    }

    @DeleteMapping(path = "/{productId}")
    public ResponseEntity<Void> deleteProduct(@PathVariable Long productId) {
        this.productService.deleteProduct(productId);
        return ResponseEntity.noContent().build();
    }
}
````

## Configurando conexión a MySQL en el application.yml

En el `application.yml` del `product-service` agregamos las siguientes configuraciones.

````yml
server:
  port: 8001
  error:
    include-message: always

spring:
  application:
    name: product-service
  datasource:
    url: jdbc:mysql://localhost:3306/db_product_service?serverTimezone=America/Lima
    username: root
    password: magadiflo
  jpa:
    hibernate:
      ddl-auto: update
    properties:
      hibernate:
        format_sql: true
    defer-datasource-initialization: true
  sql:
    init:
      mode: always

logging:
  level:
    org.hibernate.SQL: debug
````

Además, para poblar la tabla `products` en la base de datos, vamos a crear un archivo llamado `data.sql` en el
`/resources`. El contenido del script será el siguiente:

````sql
TRUNCATE TABLE products;
ALTER TABLE products AUTO_INCREMENT = 1;

INSERT INTO products(id, name, price, create_at)
VALUES(1, 'Panasonic', 800, NOW()),
(2, 'Sony', 700, NOW()),
(3, 'Apple', 1000, NOW()),
(4, 'Sony Notebook', 1000, NOW()),
(5, 'Hewlett Packard', 500, NOW()),
(6, 'Bianchi', 600, NOW()),
(7, 'Nike', 100, NOW()),
(8, 'Adidas', 200, NOW()),
(9, 'Reebok', 300, NOW());
````

Observar que estamos usando el `ALTER TABLE` al inicio del script para reiniciar la tabla. Esto lo hacemos, porque
cada vez que iniciemos la aplicación, en la tabla aparezcan siempre los mismos registros.

Como vamos a apoyarnos del archivo `data.sql` para poblar la tabla `products`, es que en las configuraciones anteriores
hemos agregado las que se muestran a continuación.

````yml
spring:
  jpa:
    defer-datasource-initialization: true
  sql:
    init:
      mode: always
````

[Guía rápida sobre cómo cargar datos iniciales con Spring Boot](https://www.baeldung.com/spring-boot-data-sql-and-schema-sql)

- `spring.jpa.defer-datasource-initialization=true`, evita que el `data.sql` se ejecute antes de que hibernate cree las
  tablas, digamos que retrasa esa ejecución.
- `spring.sql.init.mode=always`, permite la inicialización basada en scripts, es decir, insertar datos a través de
  `data.sql` o crear un esquema a través de `schema.sql`.

## Probando la conexión a MySQL (crea la BBDD y tabla)

Creamos la base de datos llamada `db_product_service` utilizando `DBeaver`.

![01.png](assets/section-02/01.png)

Luego de dar en `Aceptar`, ejecutamos la aplicación. Hibernate, será quien cree la tabla `products` gracias las
anotaciones que definimos en la entidad `Product`. Luego, nuestro script `data.sql` será ejecutada poblando la tabla
`products`.

A continuación se muestra los logs que aparecen en IntelliJ IDEA al ejecutar nuestra aplicación.

````bash
  .   ____          _            __ _ _
 /\\ / ___'_ __ _ _(_)_ __  __ _ \ \ \ \
( ( )\___ | '_ | '_| | '_ \/ _` | \ \ \ \
 \\/  ___)| |_)| | | | | || (_| |  ) ) ) )
  '  |____| .__|_| |_|_| |_\__, | / / / /
 =========|_|==============|___/=/_/_/_/

 :: Spring Boot ::                (v3.4.4)

2025-04-07T11:17:15.046-05:00  INFO 19144 --- [product-service] [           main] d.m.p.app.ProductServiceApplication      : Starting ProductServiceApplication using Java 21.0.6 with PID 19144 (D:\programming\spring\01.udemy\02.andres_guzman\06.microservices_netflix_eureka\microservices-project\business-domain\product-service\target\classes started by magadiflo in D:\programming\spring\01.udemy\02.andres_guzman\06.microservices_netflix_eureka\microservices-project)
2025-04-07T11:17:15.050-05:00  INFO 19144 --- [product-service] [           main] d.m.p.app.ProductServiceApplication      : No active profile set, falling back to 1 default profile: "default"
...
2025-04-07T11:17:16.102-05:00  INFO 19144 --- [product-service] [           main] .s.d.r.c.RepositoryConfigurationDelegate : Finished Spring Data repository scanning in 69 ms. Found 1 JPA repository interface.
2025-04-07T11:17:16.267-05:00  INFO 19144 --- [product-service] [           main] o.s.cloud.context.scope.GenericScope     : BeanFactory id=ea0cfd3b-8b8c-3869-9338-662393805086
2025-04-07T11:17:16.836-05:00  INFO 19144 --- [product-service] [           main] o.s.b.w.embedded.tomcat.TomcatWebServer  : Tomcat initialized with port 8001 (http)
...
2025-04-07T11:17:16.854-05:00  INFO 19144 --- [product-service] [           main] o.apache.catalina.core.StandardEngine    : Starting Servlet engine: [Apache Tomcat/10.1.39]
...
2025-04-07T11:17:17.311-05:00  INFO 19144 --- [product-service] [           main] org.hibernate.Version                    : HHH000412: Hibernate ORM core version 6.6.11.Final
...
2025-04-07T11:17:17.734-05:00  INFO 19144 --- [product-service] [           main] o.s.o.j.p.SpringPersistenceUnitInfo      : No LoadTimeWeaver setup: ignoring JPA class transformer
2025-04-07T11:17:17.779-05:00  INFO 19144 --- [product-service] [           main] com.zaxxer.hikari.HikariDataSource       : HikariPool-1 - Starting...
2025-04-07T11:17:18.216-05:00  INFO 19144 --- [product-service] [           main] com.zaxxer.hikari.pool.HikariPool        : HikariPool-1 - Added connection com.mysql.cj.jdbc.ConnectionImpl@51cca357
2025-04-07T11:17:18.218-05:00  INFO 19144 --- [product-service] [           main] com.zaxxer.hikari.HikariDataSource       : HikariPool-1 - Start completed.
2025-04-07T11:17:18.315-05:00  INFO 19144 --- [product-service] [           main] org.hibernate.orm.connections.pooling    : HHH10001005: Database info:
	Database JDBC URL [Connecting through datasource 'HikariDataSource (HikariPool-1)']
	Database driver: undefined/unknown
	Database version: 8.0.41
	Autocommit mode: undefined/unknown
	Isolation level: undefined/unknown
	Minimum pool size: undefined/unknown
	Maximum pool size: undefined/unknown
2025-04-07T11:17:19.214-05:00  INFO 19144 --- [product-service] [           main] o.h.e.t.j.p.i.JtaPlatformInitiator       : HHH000489: No JTA platform available (set 'hibernate.transaction.jta.platform' to enable JTA platform integration)
2025-04-07T11:17:19.255-05:00 DEBUG 19144 --- [product-service] [           main] org.hibernate.SQL                        : 
    create table products (
        id bigint not null auto_increment,
        create_at datetime(6),
        name varchar(255),
        price decimal(38,2),
        primary key (id)
    ) engine=InnoDB
2025-04-07T11:17:19.282-05:00  INFO 19144 --- [product-service] [           main] j.LocalContainerEntityManagerFactoryBean : Initialized JPA EntityManagerFactory for persistence unit 'default'
2025-04-07T11:17:19.728-05:00  WARN 19144 --- [product-service] [           main] JpaBaseConfiguration$JpaWebConfiguration : spring.jpa.open-in-view is enabled by default. Therefore, database queries may be performed during view rendering. Explicitly configure spring.jpa.open-in-view to disable this warning
2025-04-07T11:17:20.234-05:00  INFO 19144 --- [product-service] [           main] o.s.b.w.embedded.tomcat.TomcatWebServer  : Tomcat started on port 8001 (http) with context path '/'
2025-04-07T11:17:20.252-05:00  INFO 19144 --- [product-service] [           main] d.m.p.app.ProductServiceApplication      : Started ProductServiceApplication in 5.956 seconds (process running for 6.848)
````

Si revisamos la tabla `products` vemos que se han poblado sin problemas con los datos colocados en el `data.sql`.

![02.png](assets/section-02/02.png)

## Probando nuestra API products

- Listar todos los productos

````bash
$ curl -v http://localhost:8001/api/v1/products | jq
>
< HTTP/1.1 200
< Content-Type: application/json
< Transfer-Encoding: chunked
< Date: Mon, 07 Apr 2025 16:36:21 GMT
<
[
  {
    "id": 1,
    "name": "Panasonic",
    "price": 800.00,
    "createAt": "2025-04-07T11:30:27"
  },
  {...},
  {
    "id": 9,
    "name": "Reebok",
    "price": 300.00,
    "createAt": "2025-04-07T11:30:27"
  }
]
````

- Buscar un producto

````bash
$ curl -v http://localhost:8001/api/v1/products/5 | jq
>
< HTTP/1.1 200
< Content-Type: application/json
< Transfer-Encoding: chunked
< Date: Mon, 07 Apr 2025 16:40:07 GMT
<
{
  "id": 5,
  "name": "Hewlett Packard",
  "price": 500.00,
  "createAt": "2025-04-07T11:30:27"
}
````

- Guardar un producto

````bash
$ curl -v -X POST -H "Content-Type: application/json" -d "{\"name\": \"Auricular Halio\", \"price\": 60}" http://localhost:8001/api/v1/products | jq
>
< HTTP/1.1 201
< Location: /api/v1/products/10
< Content-Type: application/json
< Transfer-Encoding: chunked
< Date: Mon, 07 Apr 2025 17:03:51 GMT
<
{
  "id": 10,
  "name": "Auricular Halio",
  "price": 60,
  "createAt": "2025-04-07T12:03:51"
}
````

- Editar un producto

````bash
$ curl -v -X PUT -H "Content-Type: application/json" -d "{\"name\": \"Auricular Halio Wireless\", \"price\": 90.50}" http://localhost:8001/api/v1/products/10 | jq
>
< HTTP/1.1 200
< Content-Type: application/json
< Transfer-Encoding: chunked
< Date: Mon, 07 Apr 2025 17:05:14 GMT
<
{
  "id": 10,
  "name": "Auricular Halio Wireless",
  "price": 90.50,
  "createAt": "2025-04-07T12:03:51"
}
````

- Eliminar un producto

````bash
$ curl -v -X DELETE http://localhost:8001/api/v1/products/10 | jq
>
< HTTP/1.1 204
< Date: Mon, 07 Apr 2025 17:06:05 GMT
<
````

## Crea el microservicio item-service

Iniciamos creando nuestro proyecto desde
[Spring Initlizr](https://start.spring.io/#!type=maven-project&language=java&platformVersion=3.4.4&packaging=jar&jvmVersion=21&groupId=dev.magadiflo&artifactId=item-service&name=item-service&description=Item%20Service%20Project&packageName=dev.magadiflo.item.app&dependencies=web,lombok,cloud-starter,cloud-feign)
con las siguientes dependencias:

````xml
<!--Spring Boot 3.4.4-->
<!--Java 21-->
<!--Spring Cloud Version 2024.0.1-->
<dependencies>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-web</artifactId>
    </dependency>
    <dependency>
        <groupId>org.springframework.cloud</groupId>
        <artifactId>spring-cloud-starter</artifactId>
    </dependency>
    <dependency>
        <groupId>org.springframework.cloud</groupId>
        <artifactId>spring-cloud-starter-openfeign</artifactId>
    </dependency>

    <dependency>
        <groupId>org.projectlombok</groupId>
        <artifactId>lombok</artifactId>
        <optional>true</optional>
    </dependency>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-test</artifactId>
        <scope>test</scope>
    </dependency>
</dependencies>
````

En el `application.yml` del `item-service` agregamos las siguientes configuraciones:

````yml
server:
  port: 8002
  error:
    include-message: always

spring:
  application:
    name: item-service
````

## Creando clase Model Product e Item

En nuestro `item-serivice` creamos nuestro dto `Product`, con los mismos atributos que nos retorna el endpoint del
`product-service`.

````java
public record Product(Long id,
                      String name,
                      BigDecimal price,
                      LocalDateTime createAt) {
}
````

Ahora, crearemos un dto llamado `Item`, que tendrá como campos, el dto `Product` y la cantidad.

````java
public record Item(Product product, int quantity) {
    @JsonProperty
    public BigDecimal total() {
        return product.price().multiply(BigDecimal.valueOf(quantity));
    }
}
````

En este record, vamos a agregar un método que nos retorne el producto del precio por la cantidad. Además, vamos a
utilizar este record `Item` para exponerlo vía endpoints, por lo tanto, necesitaremos agregar la anotación
`@JsonProperty` en el método `total()` para que también sea considerado al momento de generar `JSON` de respuesta, es
decir, cuando se llame a un endpoint que envía un `Item`, el json generado estará formado por los atributos de product,
el quantity y el total. En caso de que no usemos la anotación `@JsonProperty` en el método del record, sencillamente,
el método no se enviará como respuesta en el json.

Antes de finalizar este apartado, vamos a crear una interfaz donde definiremos dos métodos para retornar los items o un
item en específico a partir del id del producto.

````java
public interface ItemService {
    List<Item> findItems();

    Item findItemByProductId(Long productId, int quantity);
}
````

## Implementando Client Http con OpenFeign

En este apartado configuraremos el `Feign Client` en nuestro `item-service` para realizar peticiones hacia el
`product-service`.

Como primer paso, debemos anotar con `@EnableFeignClients` nuestra clase principal para habilitar el uso de este cliente
en nuestra aplicación.

````java

@EnableFeignClients
@SpringBootApplication
public class ItemServiceApplication {

    public static void main(String[] args) {
        SpringApplication.run(ItemServiceApplication.class, args);
    }

}
````

A continuación, creamos la interfaz `ProductFeignClient` donde definiremos los distintos métodos que serán construídos
por debajo para la realización de peticiones hacia el microservicio de productos.

````java

@FeignClient(name = "product-service", url = "127.0.0.1:8001", path = "/api/v1/products")
public interface ProductFeignClient {
    @GetMapping
    List<Product> findProducts();

    @GetMapping(path = "/{productId}")
    Optional<Product> findProduct(@PathVariable Long productId);
}
````

`@FeignClient`, anotación para interfaces que declara la creación de un cliente REST con dicha interfaz (p. ej.,
la conexión automática a otro componente). Si SC LoadBalancer está disponible, se usará para equilibrar la carga de las
solicitudes del backend. El balanceador de carga puede configurarse con el mismo nombre (es decir, valor) que el
cliente de feign.

## Implementando el servicio con Feign Client Http

Iniciamos creando una clase de constantes para nuestro `item-service`.

````java

@UtilityClass
public class ItemConstant {
    public static final String NO_SUCH_ELEMENT_MESSAGE = "The item cannot be displayed because the product with id %d does not exist";
}
````

Finalmente, implementamos el servicio `ItemServiceImpl`. Notar que aquí estamos haciendo uso del `ProductFeignClient`
quien será el encargado de realizar la petición al `product-service`.

````java

@Slf4j
@RequiredArgsConstructor
@Service
public class ItemServiceImpl implements ItemService {

    private final ProductFeignClient productFeignClient;

    @Override
    public List<Item> findItems() {
        return this.productFeignClient.findProducts().stream()
                .map(product -> new Item(product, 1))
                .toList();
    }

    @Override
    public Item findItemByProductId(Long productId, int quantity) {
        return this.productFeignClient.findProduct(productId)
                .map(product -> new Item(product, quantity))
                .orElseThrow(() -> new NoSuchElementException(ItemConstant.NO_SUCH_ELEMENT_MESSAGE.formatted(productId)));
    }
}
````

## Creando controlador de items

Definimos el controlador `ItemController` de nuestro `item-service`.

````java

@Slf4j
@RequiredArgsConstructor
@RestController
@RequestMapping(path = "/api/v1/items")
public class ItemController {

    private final ItemService itemService;

    @GetMapping
    public ResponseEntity<List<Item>> findProducts() {
        return ResponseEntity.ok(this.itemService.findItems());
    }

    @GetMapping(path = "/{productId}")
    public ResponseEntity<Item> findProduct(@PathVariable Long productId, @RequestParam int quantity) {
        return ResponseEntity.ok(this.itemService.findItemByProductId(productId, quantity));
    }
}
````

## Probando nuestra API items (cliente)

Hasta este momento tenemos dos aplicaciones en nuestro proyecto: `product-service` e `item-service`. Estos dos proyectos
los ejecutamos para realizar las pruebas de comunicación que implementamos con `Feign Client`.

- Listamos todos los items.

````bash
$ curl -v http://localhost:8002/api/v1/items | jq
>
< HTTP/1.1 200
< Content-Type: application/json
< Transfer-Encoding: chunked
< Date: Mon, 07 Apr 2025 20:27:22 GMT
<
[
  {
    "product": {
      "id": 1,
      "name": "Panasonic",
      "price": 800.00,
      "createAt": "2025-04-07T15:26:30"
    },
    "quantity": 1,
    "total": 800.00
  },
  {...},
  {
    "product": {
      "id": 9,
      "name": "Reebok",
      "price": 300.00,
      "createAt": "2025-04-07T15:26:30"
    },
    "quantity": 1,
    "total": 300.00
  }
]
````

- Listando un item enviándole una cantidad específica.

````bash
$ curl -v -G --data "quantity=10" http://localhost:8002/api/v1/items/5 | jq
>
< HTTP/1.1 200
< Content-Type: application/json
< Transfer-Encoding: chunked
< Date: Mon, 07 Apr 2025 20:26:57 GMT
<
{
  "product": {
    "id": 5,
    "name": "Hewlett Packard",
    "price": 500.00,
    "createAt": "2025-04-07T15:26:30"
  },
  "quantity": 10,
  "total": 5000.00
}
````

- Listando un item cuyo id de producto no existe.

````bash
$ curl -v -G --data "quantity=10" http://localhost:8002/api/v1/items/50 | jq
>
< HTTP/1.1 500
< Content-Type: application/json
< Transfer-Encoding: chunked
< Date: Mon, 07 Apr 2025 20:44:32 GMT
< Connection: close
<
{
  "timestamp": "2025-04-07T20:44:32.198+00:00",
  "status": 500,
  "error": "Internal Server Error",
  "message": "[500] during [GET] to [http://127.0.0.1:8001/api/v1/products/50] [ProductFeignClient#findProduct(Long)]: [{\"timestamp\":\"2025-04-07T20:44:32.145+00:00\",\"status\":500,\"error\":\"Internal Server Error\",\"message\":\"The product with id 50 does not exist\",\"path\":\"/api/v1/products/50\"}]",
  "path": "/api/v1/items/50"
}
````

## Configurando puertos en product-service para balanceo de carga

En este apartado vamos a agregar el atributo `port` al dto que nos retorna el `product-service`, de esa manera sabremos
qué instancia del `product-service` estamos usando. Esto simplemente lo hacemos de manera educativa para darnos cuenta
que estamos utilizando balanceo de carga y que en cada llamada se utiliza una instancia distinta del conjunto de
instancias levantadas de nuestro `product-service`.

En nuestro `application.yml` del `product-service` modificamos el puerto con un valor de cero (0). Este valor indica
que el puerto se generará de manera aleatoria cada vez que levantemos la aplicación.

````yml
server:
  port: 0
````

Creamos una clase de utilidad en nuestro `product-service`.

````java

@UtilityClass
public class Util {
    public static int getInt(String value) {
        return Integer.parseInt(value);
    }
}
````

En el dto `ProductResponse` agregamos el atributo `port`.

````java
public record ProductResponse(Long id,
                              String name,
                              BigDecimal price,
                              LocalDateTime createAt,
                              int port) {
}
````

Al haber hecho el cambio anterior, vamos a tener que realizar ciertas modificaciones a otras clases, como en el
`ProductMapper`.

````java

@Component
public class ProductMapper {

    public ProductResponse toProductResponse(Product product, int port) {
        return new ProductResponse(product.getId(), product.getName(), product.getPrice(), product.getCreateAt(), port);
    }

    /* other code */
}
````

También necesitamos realizar las modificaciones a la clase `ProductServiceImpl` donde usamos la interfaz `Environment`
de `Spring` que nos permitirá obtener el puerto de la instancia del `product-service` que se llame en la petición.

````java

@Slf4j
@RequiredArgsConstructor
@Service
@Transactional(readOnly = true)
public class ProductServiceImpl implements ProductService {

    private final ProductMapper productMapper;
    private final ProductRepository productRepository;
    private final Environment environment;

    @Override
    public List<ProductResponse> findProducts() {
        return ((List<Product>) this.productRepository.findAll()).stream()
                .map(product -> this.productMapper.toProductResponse(product, this.getLocalServerPort()))
                .toList();
    }

    @Override
    public ProductResponse findProduct(Long productId) {
        return this.productRepository.findById(productId)
                .map(product -> this.productMapper.toProductResponse(product, this.getLocalServerPort()))
                .orElseThrow(() -> new NoSuchElementException(ProductConstant.NO_SUCH_ELEMENT_MESSAGE.formatted(productId)));
    }

    @Override
    @Transactional
    public ProductResponse saveProduct(ProductRequest request) {
        Product productDB = this.productRepository.save(this.productMapper.toProduct(request));
        return this.productMapper.toProductResponse(productDB, this.getLocalServerPort());
    }

    @Override
    @Transactional
    public ProductResponse updateProduct(Long productId, ProductRequest request) {
        return this.productRepository.findById(productId)
                .map(productDB -> this.productMapper.toUpdateProduct(productDB, request))
                .map(this.productRepository::save)
                .map(product -> this.productMapper.toProductResponse(product, this.getLocalServerPort()))
                .orElseThrow(() -> new NoSuchElementException(ProductConstant.NO_SUCH_ELEMENT_MESSAGE.formatted(productId)));
    }

    @Override
    @Transactional
    public void deleteProduct(Long productId) {
        Product productDB = this.productRepository.findById(productId)
                .orElseThrow(() -> new NoSuchElementException(ProductConstant.NO_SUCH_ELEMENT_MESSAGE.formatted(productId)));
        this.productRepository.deleteById(productDB.getId());
    }

    private int getLocalServerPort() {
        return Util.getInt(this.environment.getProperty("local.server.port"));
    }
}
````

## Balanceo de carga del lado del cliente con Cloud LoadBalancer

En el `pom.xml` del `item-service` agregamos la dependencia de LoadBalancer.

````xml

<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-loadbalancer</artifactId>
</dependency>
````

Necesitamos agregar el atributo `port` al dto `Product`, dado que necesitamos ese atributo para mapear al atributo port
que nos envían desde el `product-service`.

````java
public record Product(Long id,
                      String name,
                      BigDecimal price,
                      LocalDateTime createAt,
                      int port) {
}
````

En el `ProductFeignClient` eliminamos el atributo `url = "127.0.0.1:8001"` que teníamos definido anteriormente en la
anotación `@FeignClient`. Esto lo eliminamos porque ahora haremos más dinámica la aplicación, por esa razón es que
agregamos la dependencia `LoadBalancer`.

````java

@FeignClient(name = "product-service", path = "/api/v1/products")
public interface ProductFeignClient {
    @GetMapping
    List<Product> findProducts();

    @GetMapping(path = "/{productId}")
    Optional<Product> findProduct(@PathVariable Long productId);
}
````

Ahora, en el `application.yml` del `item-service` agregamos la configuración del `LoadBalancer` donde definimos
explícitamente tres uris correspondientes a las instancias que levantaremos de nuestro `product-service`. Es decir,
vamos a levantar tres instancias del `product-service` cada una de estas instancias estará corriendo en un puerto fijo
distinto uno del otro. Estos puertos los agregaremos manualmente al levantar las instancias.

````yml
server:
  port: 8002
  error:
    include-message: always

spring:
  application:
    name: item-service
  cloud:
    discovery:
      client:
        simple:
          instances:
            product-service:
              - uri: http://localhost:8010
              - uri: http://localhost:8011
              - uri: http://localhost:8012
````

Cuando hagamos una petición desde nuestro `item-service` al `product-service` el `LoadBalancer` escogerá aplicando el
algoritmo de `Round Robin` la instancia correspondiente.

**Importante**
> En el `ProductFeignClient` hemos definido como  `name="product-service"`, ese valor debe ser el mismo que el que se
> tiene que definir en el `application.yml` del `item-service` para la configuración del `LoadBalancer`.
>
> Ahora, esta configuración del `LoadBalancer` lo estamos haciendo manualmente, es decir, definiéndo explícitamente las
> instancias que habrá, pero más adelante utilizaremos `Eureka` quien se encargará de manejar esta configuración por
> nosotros.

## Ejecutando múltiples instancias en IntelliJ IDEA (definiendo puerto)

Para ejecutar múltiples instancias, pero definiendo un puerto específico realizaremos los siguientes pasos tal como
se muestra en la siguiente imagen.

![03.png](assets/section-02/03.png)

## Ejecutando múltiples instancias en IntelliJ IDEA (Puerto dinámico)

Primero debemos agregar la siguiente configuración en la aplicación que queremos ejecutar con puerto aleatorio.

````yml
server:
  port: 0
````

El valor cero (0) es un valor especial en Spring Boot. Al usar cero (0), el servidor web seleccionará automáticamente
un puerto disponible al azar.

Luego, para ejecutar múltiples instancias, realizamos la siguiente configuración en nuestro IntelliJ IDEA.

![04.png](assets/section-02/04.png)

## Probando el balanceo de carga

Realizamos una petición al `item-service` solicitando un item a partir del id de un producto. Vemos que el resultado
nos retorna el `puerto 8011`.

````bash
$ curl -v -G --data "quantity=10" http://localhost:8002/api/v1/items/2 | jq
>
< HTTP/1.1 200
< Content-Type: application/json
< Transfer-Encoding: chunked
< Date: Mon, 07 Apr 2025 21:43:33 GMT
<
{
  "product": {
    "id": 2,
    "name": "Sony",
    "price": 700.00,
    "createAt": "2025-04-07T16:38:32",
    "port": 8011
  },
  "quantity": 10,
  "total": 7000.00
}
````

Ahora, si realizamos otra petición vemos que el puerto es otro `8012`.

````bash
$ curl -v -G --data "quantity=10" http://localhost:8002/api/v1/items/2 | jq
>
< HTTP/1.1 200
< Content-Type: application/json
< Transfer-Encoding: chunked
< Date: Mon, 07 Apr 2025 21:43:46 GMT
<
{
  "product": {
    "id": 2,
    "name": "Sony",
    "price": 700.00,
    "createAt": "2025-04-07T16:38:32",
    "port": 8012
  },
  "quantity": 10,
  "total": 7000.00
}
````

Finalmente, realizamos una tercera petición y vemos que el puerto es el `8010`.

````bash
$ curl -v -G --data "quantity=10" http://localhost:8002/api/v1/items/2 | jq
>
< HTTP/1.1 200
< Content-Type: application/json
< Transfer-Encoding: chunked
< Date: Mon, 07 Apr 2025 21:43:49 GMT
<
{
  "product": {
    "id": 2,
    "name": "Sony",
    "price": 700.00,
    "createAt": "2025-04-07T16:38:32",
    "port": 8010
  },
  "quantity": 10,
  "total": 7000.00
}
````

En resumen, podemos ver que se está aplicando correctamente el balanceo de carga, dado que por cada petición, la
instancia que se ejecuta siempre es uno distinto. Aquí se está aplicando el algoritmo de `Round Robin` para seleccionar
la instancia que ejecutará la petición.
