# Sección 02: Comenzando con los microservicios

---

## Creando nuestro microservicio products

Iniciamos creando el `product-service` desde
[Spring Initializr](https://start.spring.io/#!type=maven-project&language=java&platformVersion=3.4.4&packaging=jar&jvmVersion=21&groupId=dev.magadiflo&artifactId=product-service&name=product-service&description=Product%20Service%20Project&packageName=dev.magadiflo.product.app&dependencies=web,data-jpa,lombok,mysql,cloud-starter)
con las siguientes dependencias.

````xml
<!--Spring Boot 3.4.4-->
<!--Java 21-->
<!--Spring Cloud Version 2024.0.1-->
<dependencies>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-data-jpa</artifactId>
    </dependency>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-web</artifactId>
    </dependency>
    <dependency>
        <groupId>org.springframework.cloud</groupId>
        <artifactId>spring-cloud-starter</artifactId>
    </dependency>

    <dependency>
        <groupId>com.mysql</groupId>
        <artifactId>mysql-connector-j</artifactId>
        <scope>runtime</scope>
    </dependency>
    <dependency>
        <groupId>org.projectlombok</groupId>
        <artifactId>lombok</artifactId>
        <optional>true</optional>
    </dependency>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-test</artifactId>
        <scope>test</scope>
    </dependency>
</dependencies>
````

**Nota**
> En `spring initializr` agregamos la dependencia `Cloud Bootstrap` simplemente para que desde el principio tengamos la
> versión de `Spring Cloud`.

**Importante**
> Cada versión de `Spring Boot` tiene su correspondiente versión específica de `Spring Cloud`.

Configuramos el `application.yml` del `product-service` con las siguientes propiedades:

````yml
server:
  port: 8001
  error:
    include-message: always

spring:
  application:
    name: product-service
````

## Añadiendo la clase Entity JPA

Creamos la entidad `Product` con anotaciones de `jpa`. Además, nos apoyamos de las anotaciones de `Lombok` para evitar
el boilerplate (código repetitivo).

````java

@ToString
@AllArgsConstructor
@NoArgsConstructor
@Builder
@Getter
@Setter
@Entity
@Table(name = "products")
public class Product {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    private String name;
    private BigDecimal price;
    private LocalDateTime createAt;
}
````

## Creando el repositorio JPA con Spring Data JPA

En el microservicio `product-service`, creamos el repositorio `ProductRepository` para la entidad `Product`.

````java
public interface ProductRepository extends CrudRepository<Product, Long> {
}
````

## Creando el Servicio para la lógica de negocio

En este apartado crearemos la capa de servicio para nuestro `product-service`, pero para eso, necesitamos crear
clases de utilidades adicionales.

Empezamos creando la clase dto para mapear la información que se envía al endpoint.

````java
public record ProductRequest(String name,
                             BigDecimal price) {
}
````

El dto que nos permitirá enviar información a través de los endpoints.

````java
public record ProductResponse(Long id,
                              String name,
                              BigDecimal price,
                              LocalDateTime createAt) {
}
````

También es necesario crear una clase donde almacenaremos las distintas constantes para todo lo relacionado con
productos.

````java

@UtilityClass
public class ProductConstant {
    public static final String NO_SUCH_ELEMENT_MESSAGE = "The product with id %d does not exist";
}
````

**Importante**
> La anotación `@UtilityClass`:<br>
> - Hace la clase final (no se puede extender).<br>
> - Agrega un constructor privado, para que no se pueda instanciar.<br>
> - Convierte todos los métodos y campos en static.<br>

Una clase importante es la clase de utilidad que nos permitirá mapear nuestra entidad a un dto y viceversa. Según la
información proporcionada por Chat-GPT, es mejor definir esta clase de utilidad como un `@Component` dado que estamos
trabajando con Spring Boot, además Spring promueve trabajar con `instancias` y `beans` para favorecer la flexibilidad y
el testing. Podría haber optado por hacer la clase con método estáticos, es decir, usar la anotación de `Lombok` como
el `@UtilityClass`, pero según la recomendación es mejor hacerlo como un componente de spring.

````java

@Component
public class ProductMapper {

    public ProductResponse toProductResponse(Product product) {
        return new ProductResponse(product.getId(), product.getName(), product.getPrice(), product.getCreateAt());
    }

    public Product toProduct(ProductRequest request) {
        return Product.builder()
                .name(request.name())
                .price(request.price())
                .createAt(LocalDateTime.now())
                .build();
    }

    public Product toUpdateProduct(Product productDB, ProductRequest request) {
        productDB.setName(request.name());
        productDB.setPrice(request.price());
        return productDB;
    }
}
````

Finalmente, implementamos la clase de servicio del producto.

````java

@Slf4j
@RequiredArgsConstructor
@Service
@Transactional(readOnly = true)
public class ProductServiceImpl implements ProductService {

    private final ProductMapper productMapper;
    private final ProductRepository productRepository;

    @Override
    public List<ProductResponse> findProducts() {
        return ((List<Product>) this.productRepository.findAll()).stream()
                .map(this.productMapper::toProductResponse)
                .toList();
    }

    @Override
    public ProductResponse findProduct(Long productId) {
        return this.productRepository.findById(productId)
                .map(this.productMapper::toProductResponse)
                .orElseThrow(() -> new NoSuchElementException(ProductConstant.NO_SUCH_ELEMENT_MESSAGE.formatted(productId)));
    }

    @Override
    @Transactional
    public ProductResponse saveProduct(ProductRequest request) {
        Product productDB = this.productRepository.save(this.productMapper.toProduct(request));
        return this.productMapper.toProductResponse(productDB);
    }

    @Override
    @Transactional
    public ProductResponse updateProduct(Long productId, ProductRequest request) {
        return this.productRepository.findById(productId)
                .map(productDB -> this.productMapper.toUpdateProduct(productDB, request))
                .map(this.productRepository::save)
                .map(this.productMapper::toProductResponse)
                .orElseThrow(() -> new NoSuchElementException(ProductConstant.NO_SUCH_ELEMENT_MESSAGE.formatted(productId)));
    }

    @Override
    @Transactional
    public void deleteProduct(Long productId) {
        Product productDB = this.productRepository.findById(productId)
                .orElseThrow(() -> new NoSuchElementException(ProductConstant.NO_SUCH_ELEMENT_MESSAGE.formatted(productId)));
        this.productRepository.deleteById(productDB.getId());
    }
}
````

**Importante:<br>
[The best way to use the Spring Transactional annotation](https://vladmihalcea.com/spring-transactional-annotation/)**

> Notar que estamos definiendo la anotación `@Transactional(readOnly = true)` al nivel de clase, lo que significa que,
> por defecto, todos los métodos de servicio usarán esta configuración y se ejecutarán en una transacción de solo
> lectura, a menos que el método anule la configuración transaccional con su propia definición de `@Transactional`, tal
> como se ve en los métodos `saveProduct(), updateProduct() y deleteProduct()`.

## Creando el controlador Rest

Creamos el controlador para nuestro `product-service`.

````java

@Slf4j
@RequiredArgsConstructor
@RestController
@RequestMapping(path = "/api/v1/products")
public class ProductController {

    private final ProductService productService;

    @GetMapping
    public ResponseEntity<List<ProductResponse>> findProducts() {
        return ResponseEntity.ok(this.productService.findProducts());
    }

    @GetMapping(path = "/{productId}")
    public ResponseEntity<ProductResponse> findProduct(@PathVariable Long productId) {
        return ResponseEntity.ok(this.productService.findProduct(productId));
    }

    @PostMapping
    public ResponseEntity<ProductResponse> saveProduct(@RequestBody ProductRequest productRequest) {
        ProductResponse productResponse = this.productService.saveProduct(productRequest);
        URI location = URI.create("/api/v1/products/%d".formatted(productResponse.id()));
        return ResponseEntity.created(location).body(productResponse);
    }

    @PutMapping(path = "/{productId}")
    public ResponseEntity<ProductResponse> updateProduct(@PathVariable Long productId, @RequestBody ProductRequest productRequest) {
        return ResponseEntity.ok(this.productService.updateProduct(productId, productRequest));
    }

    @DeleteMapping(path = "/{productId}")
    public ResponseEntity<Void> deleteProduct(@PathVariable Long productId) {
        this.productService.deleteProduct(productId);
        return ResponseEntity.noContent().build();
    }
}
````
