# Secci√≥n 10: Spring Authorization Server (OAuth 2.1)

---

## Creando microservicio Spring Authorization Server (OAuth 2.1)

Creamos el nuevo microservicio desde
[Spring Initializr](https://start.spring.io/#!type=maven-project&language=java&platformVersion=3.4.4&packaging=jar&jvmVersion=21&groupId=dev.magadiflo&artifactId=authorization-server&name=authorization-server&description=Authorization%20Server&packageName=dev.magadiflo.authorization.server.app&dependencies=web,lombok,cloud-eureka,security,oauth2-authorization-server)
donde definiremos las siguientes dependencias.

Al ser `Spring Authorization Server` una capa construida por encima de `Spring Security`, necesitamos a√±adir
tambi√©n esta dependencia, al igual que `Spring Web` para el manejo de solicitudes y respuestas HTTP que utiliza
`Spring Authorization Server` para realizar las tareas de autenticaci√≥n y autorizaci√≥n.

````xml
<!--Spring Boot 3.4.4-->
<!--Spring Cloud 2024.0.1-->
<!--Java 21-->
<dependencies>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-oauth2-authorization-server</artifactId>
    </dependency>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-security</artifactId>
    </dependency>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-web</artifactId>
    </dependency>
    <dependency>
        <groupId>org.springframework.cloud</groupId>
        <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>
    </dependency>

    <dependency>
        <groupId>org.projectlombok</groupId>
        <artifactId>lombok</artifactId>
        <optional>true</optional>
    </dependency>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-test</artifactId>
        <scope>test</scope>
    </dependency>
    <dependency>
        <groupId>org.springframework.security</groupId>
        <artifactId>spring-security-test</artifactId>
        <scope>test</scope>
    </dependency>
</dependencies>
````

En el `application.yml` del `authorization-server` agregamos las siguientes configuraciones iniciales.

````yml
server:
  port: 9000
  error:
    include-message: always

spring:
  application:
    name: authorization-server

eureka:
  instance:
    prefer-ip-address: true
    instance-id: ${spring.cloud.client.hostname}:${spring.application.name}:${random.value}
  client:
    service-url:
      defaultZone: http://localhost:8761/eureka/
````

## Configurando el Servidor de Autorizaci√≥n

En este apartado utilizaremos la
[gu√≠a de la documentaci√≥n de Spring Authorization Server](https://docs.spring.io/spring-authorization-server/reference/getting-started.html)
para definir los componentes requeridos en la configuraci√≥n de nuestro servidor de autorizaci√≥n.

El c√≥digo siguiente es tal cual se muestra en la documentaci√≥n, con algunos peque√±os cambios para ajustar al proyecto de
microservicios que venimos realizando. Este es el t√≠pico ejemplo que muestra c√≥mo levantar un `Authorization Server`
b√°sico con `OAuth 2.1` y soporte `OIDC (OpenID Connect)`.

**Nota**
> La anotaci√≥n `@EnableWebSecurity` sobre nuestra clase de configuraci√≥n `SecurityConfig` no es necesario (aunque en el
> c√≥digo de la documentaci√≥n s√≠ lo usa).
>
> `¬øPor qu√© no es necesaria?`, `Spring Boot auto-configura Spring Security` si encuentra uno o m√°s `SecurityFilterChain`
> definidos como `@Bean`.
>
> A partir de `Spring Security 5.7` (usado en `Spring Boot 3`), se recomienda usar el enfoque basado en beans,
> es decir: `@Bean public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {}`.
>
> Con este enfoque moderno, `Spring Security` se registra autom√°ticamente sin necesidad de `@EnableWebSecurity`.
>
> Antes (`Spring Boot 2.x` y versiones anteriores), la anotaci√≥n `@EnableWebSecurity` era necesaria para habilitar la
> configuraci√≥n de seguridad web en `Spring Security`. Si no la us√°bamos, Spring no aplicaba la configuraci√≥n de
> seguridad correctamente.
>
> Ahora, en `Spring Boot 3.x`, `Spring Boot` se encarga de habilitar la configuraci√≥n de seguridad autom√°ticamente si
> detecta `SecurityFilterChain` como beans en el contexto de la aplicaci√≥n, y si no la necesitas expl√≠citamente, Spring
> Boot se encarga de la configuraci√≥n por debajo.
>
> Esto significa que podemos prescindir de la anotaci√≥n `@EnableWebSecurity` y `Spring Security` funciona bien solo con
> la definici√≥n de los `SecurityFilterChain` como beans.

````java

@Configuration
public class SecurityConfig {

    @Bean
    @Order(1)
    public SecurityFilterChain authorizationServerSecurityFilterChain(HttpSecurity http) throws Exception {
        OAuth2AuthorizationServerConfigurer authorizationServerConfigurer =
                OAuth2AuthorizationServerConfigurer.authorizationServer();

        http
                .securityMatcher(authorizationServerConfigurer.getEndpointsMatcher())
                .with(authorizationServerConfigurer, (authorizationServer) ->
                        authorizationServer
                                .oidc(Customizer.withDefaults())    // Enable OpenID Connect 1.0
                )
                .authorizeHttpRequests((authorize) ->
                        authorize
                                .anyRequest().authenticated()
                )
                // Redirect to the login page when not authenticated from the
                // authorization endpoint
                .exceptionHandling((exceptions) -> exceptions
                        .defaultAuthenticationEntryPointFor(
                                new LoginUrlAuthenticationEntryPoint("/login"),
                                new MediaTypeRequestMatcher(MediaType.TEXT_HTML)
                        )
                );

        return http.build();
    }

    @Bean
    @Order(2)
    public SecurityFilterChain defaultSecurityFilterChain(HttpSecurity http) throws Exception {
        http
                .authorizeHttpRequests((authorize) -> authorize
                        .anyRequest().authenticated()
                )
                .csrf(AbstractHttpConfigurer::disable)
                // Form login handles the redirect to the login page from the
                // authorization server filter chain
                .formLogin(Customizer.withDefaults());

        return http.build();
    }

    @Bean
    public UserDetailsService userDetailsService() {
        UserDetails admin = User.builder()
                .username("admin")
                .password("{noop}123456")
                .roles("USER", "ADMIN")
                .build();

        UserDetails martin = User.builder()
                .username("martin")
                .password("{noop}123456")
                .roles("USER")
                .build();

        return new InMemoryUserDetailsManager(admin, martin);
    }

    @Bean
    public RegisteredClientRepository registeredClientRepository() {
        RegisteredClient oidcClient = RegisteredClient.withId(UUID.randomUUID().toString())
                .clientId("gateway-app")
                .clientSecret("{noop}123456")
                .clientAuthenticationMethod(ClientAuthenticationMethod.CLIENT_SECRET_BASIC)
                .authorizationGrantType(AuthorizationGrantType.AUTHORIZATION_CODE)
                .authorizationGrantType(AuthorizationGrantType.REFRESH_TOKEN)
                .redirectUri("http://127.0.0.1:8090/authorized")
                .redirectUri("https://oauthdebugger.com/debug")
                .postLogoutRedirectUri("http://127.0.0.1:8090/logout")
                .scope(OidcScopes.OPENID)
                .scope(OidcScopes.PROFILE)
                .clientSettings(ClientSettings.builder().requireAuthorizationConsent(false).build())
                .build();

        return new InMemoryRegisteredClientRepository(oidcClient);
    }

    @Bean
    public JWKSource<SecurityContext> jwkSource() {
        KeyPair keyPair = generateRsaKey();
        RSAPublicKey publicKey = (RSAPublicKey) keyPair.getPublic();
        RSAPrivateKey privateKey = (RSAPrivateKey) keyPair.getPrivate();
        RSAKey rsaKey = new RSAKey.Builder(publicKey)
                .privateKey(privateKey)
                .keyID(UUID.randomUUID().toString())
                .build();
        JWKSet jwkSet = new JWKSet(rsaKey);
        return new ImmutableJWKSet<>(jwkSet);
    }

    private static KeyPair generateRsaKey() {
        KeyPair keyPair;
        try {
            KeyPairGenerator keyPairGenerator = KeyPairGenerator.getInstance("RSA");
            keyPairGenerator.initialize(2048);
            keyPair = keyPairGenerator.generateKeyPair();
        } catch (Exception ex) {
            throw new IllegalStateException(ex);
        }
        return keyPair;
    }

    @Bean
    public JwtDecoder jwtDecoder(JWKSource<SecurityContext> jwkSource) {
        return OAuth2AuthorizationServerConfiguration.jwtDecoder(jwkSource);
    }

    @Bean
    public AuthorizationServerSettings authorizationServerSettings() {
        return AuthorizationServerSettings.builder().issuer("http://127.0.0.1:9000").build();
    }

}
````

**D√≥nde**

1. `SecurityFilterChain authorizationServerSecurityFilterChain(...)`, este filtro es exclusivo para proteger los
   endpoints del `Authorization Server`, como `/oauth2/token`, `/oauth2/authorize`, etc.
    - Se usa `OAuth2AuthorizationServerConfigurer` para configurar los endpoints.
    - Se habilita `OIDC` con `.oidc(Customizer.withDefaults())`.
    - Redirige a `/login` si el usuario no est√° autenticado.
    - Se asegura que cualquier request a los endpoints est√© autenticada.


2. `SecurityFilterChain defaultSecurityFilterChain(...)`, este es el filtro para el resto de las rutas no manejadas por
   el `Authorzation Server`.
    - Simple: cualquier request requiere autenticaci√≥n.
    - Se activa `formLogin()` (pantalla de login por defecto de Spring Security).


3. `UserDetailsService `, estamos definiendo temporalmente usuarios que estar√°n almacenados en
   memoria. Estos usuarios ser√°n usuarios de prueba mientras desarrollamos el servidor de autorizaci√≥n. Recordemos que
   tenemos un `user-service`, precisamente ese servicio ser√° el que m√°s adelante usaremos para la gesti√≥n de los
   usuarios.


4. `RegisteredClientRepository`, definimos un `cliente OAuth2` registrado. Es el cliente que va a pedir autorizaci√≥n. En
   este `RegisteredClientRepository` vemos urls definidas, de las cuales:
    - `.redirectUri("http://127.0.0.1:8090/authorized")`, es una url personalizada que debemos crear, dado que el tutor
      del curso lo crea para poder recibir el c√≥digo de autorizaci√≥n. Sin embargo, en mi caso usar√© la url de
      `oauthdebugger.com` para obtener dicho c√≥digo de autorizaci√≥n.
    - `.redirectUri("https://oauthdebugger.com/debug")`, definimos esta p√°gina que nos ayudar√° a realizar el flujo para
      la obtenci√≥n del c√≥digo de autorizaci√≥n.
    - `.postLogoutRedirectUri("http://127.0.0.1:8090/logout")`, es una url personalizada que debemos crear.

   Adem√°s, colocamos en `false` el `requireAuthorizationConsent()` para que no pida el consentimiento de los scopes.


5. `JWKSource`, este bean genera un par de llaves `RSA (p√∫blica y privada)` para firmar `tokens JWT`. Luego, las
   convierte a formato `JWK` para que el `Authorization Server` pueda publicarlas en su endpoint
   `.well-known/jwks.json`.


6. `generateRsaKey()`, genera la llave `RSA` de `2048 bits`. Es puro Java b√°sico para criptograf√≠a.


7. `JwtDecoder`, `Spring Authorization Server` necesita un `JwtDecoder` para validar y decodificar los tokens que emite.
   Aqu√≠ lo construyes a partir del `JWKSource`.


8. `AuthorizationServerSettings`, en la configuraci√≥n del servidor de autorizaci√≥n, he agregado una personalizaci√≥n
   para establecer el `issuer URI` (el identificador del emisor del token). El `AuthorizationServerSettings` es un bean
   que define las configuraciones del servidor de autorizaci√≥n, y por defecto,
   `Spring Security OAuth2 Authorization Server` expone los endpoints est√°ndar como `/oauth2/authorize`,
   `/oauth2/token`, etc. En nuestro caso, he personalizado el `issuer URI`, que es un valor importante en el contexto de
   `JWT (JSON Web Tokens)`. El `issuer` es utilizado por los clientes para identificar la autoridad que ha emitido un
   token y es com√∫nmente parte de los metadatos de configuraci√≥n en un servidor de autorizaci√≥n.

Ahora, nos vamos al `gateway-server` y configuramos la ruta hacia nuestro servidor de autorizaci√≥n.

````yml
spring:
  application:
    name: gateway-server
  cloud:
    gateway:
      routes:
        - id: authorization-server-route
          uri: lb://authorization-server
          predicates:
            - Path=/api/v1/authorization-server/**
          filters:
            - RewritePath=/api/v1/authorization-server/(?<path>.*), /$\{path}
````

**D√≥nde**

- `uri: lb://authorization-server`, esto indica que la solicitud se enviar√° a un servicio llamado `authorization-server`
  registrado en `Eureka` (porque usamos `lb://`, es decir, `load balancer via discovery`). Debemos asegurarnos de que el
  `spring.application.name` del servidor de autorizaci√≥n lo hayamos definido como `authorization-server`
- `Path=/api/v1/authorization-server/**`, solo las rutas que empiecen con `/api/v1/authorization-server/` ser√°n
  redirigidas al `Authorization Server`.
- `RewritePath`, este filtro elimina el prefijo `/api/v1/authorization-server/` antes de enviar la solicitud al
  `Authorization Server`. Por ejemplo:
    - Petici√≥n del cliente: `GET /api/v1/authorization-server/oauth2/token`
    - Se reescribe como: `GET /oauth2/token` (que es lo que espera `Spring Authorization Server`)

## Implementando endpoint /authorized y /logout en Gateway Server

Recordemos que en el `SecurityConfig` del `authorization-server` creamos un bean `RegisteredClientRepository`. Dentro
de este bean definimos las siguientes uris que dijimos, deb√≠amos crear:

- http://127.0.0.1:8090/authorized
- http://127.0.0.1:8090/logout

Entonces, en este apartado implementaremos esas uris en nuestro `gateway-server`, dado que el puerto que definimos
es precisamente el puerto del `gateway-server`.

````java

@RestController
public class AppController {

    @GetMapping(path = "/authorized")
    public ResponseEntity<Map<String, String>> authorized(@RequestParam String code) {
        return ResponseEntity.ok(Collections.singletonMap("code", code));
    }

    @PostMapping(path = "/logout")
    public ResponseEntity<Map<String, String>> logout() {
        return ResponseEntity.ok(Collections.singletonMap("logout", "OK"));
    }
}
````

**Importante**

> Hemos agregado un controlador al `gateway-server` con dos uris `/authorized` y `/logout`. Pero recordemos que en el
> `application.yml` de este `gateway-server` tenemos definidas rutas de microservicios a las que `gateway` redirigir√°.
> La pregunta es `¬øqui√©n responde primero? ¬øSpring Cloud Gateway o Spring WebFlux (Spring Web MVC si fuera Servlet)?`
>
> `Spring Cloud Gateway` primero eval√∫a las rutas configuradas en el `application.yml` mediante el componente
> `RoutePredicateHandlerMapping`.
> - Si una ruta coincide, el `gateway` maneja la solicitud, es decir, la enruta al microservicio correspondiente, aplica
    filtros, etc.
> - Si ninguna ruta coincide, Spring WebFlux contin√∫a buscando coincidencias entre los `@RestController` definidos en el
    `Gateway` usando el `WebFluxHandlerMapping`.

## Configurando Resource Server y Cliente OAuth2 en yml

Nuestro `gateway-server` va a cumplir dos papeles:

1. Ser√° un `cliente OAuth2` del `authorization-server`, para iniciar el flujo de autenticaci√≥n del usuario (por ejemplo,
   mediante `spring-security-oauth2-client`). El usuario se podr√° loguear y obtener un `access token` que le permitir√°
   acceder a los distintos microservicios.


2. Tambi√©n actuar√° como un `resource server`, encargado de validar el `access token` incluido en las peticiones
   (generalmente mediante un encabezado `Authorization: Bearer <token>`). Para esto, utiliza la configuraci√≥n del
   `authorization-server` (como el `issuer-uri` o las `JWKs`) para validar que el token sea v√°lido y no haya expirado.
   Esto protege las rutas del gateway y evita que usuarios no autorizados accedan a los microservicios.

‚ö†Ô∏è Importante
> El `gateway` no tiene que llamar al `authorization server` en cada solicitud para validar el token. Es decir,
> no necesita preguntar al `authorization server` en cada solicitud si el token es v√°lido. Porque puede verificar la
> firma localmente usando la clave p√∫blica del `authorization server`. Es decir, usa una
> `clave p√∫blica (JWK)` publicada por el `authorization-server` para validar localmente la `firma del token JWT`. Esto
> es m√°s eficiente.
>
> El authorization server expone un endpoint JWK (JSON Web Key), normalmente accesible en una URL como:
> `http://localhost:9000/.well-known/jwks.json`
>
> Este endpoint contiene la(s) clave(s) p√∫blica(s) necesarias para que cualquier `resource server` pueda verificar
> las firmas de los `JWT` emitidos. Entonces el flow es as√≠:
>
> üîÅ Primera vez que el resource server recibe un token ‚Üí si no tiene la clave p√∫blica, consulta el endpoint JWK y la
> guarda en memoria (cach√©).
>
> üì¶ Despu√©s ‚Üí usa la clave en memoria para validar los siguientes tokens sin tener que llamar otra vez al `authorization
> server`.

As√≠ que iniciamos agregando las siguientes dependencias al `pom.xml` del `gateway-server`.

````xml

<dependencies>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-oauth2-client</artifactId>
    </dependency>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-oauth2-resource-server</artifactId>
    </dependency>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-security</artifactId>
    </dependency>
</dependencies>
````

Luego, vamos al `application.yml` del `gateway-server` para configurar nuestro servidor `gateway` como
`cliente de OAuth2` y como `servidor de recursos`.

````yml

spring:
  application:
    name: gateway-server
  security:
    oauth2:
      resourceserver:
        jwt:
          issuer-uri: http://127.0.0.1:9000
      client:
        registration:
          my-oauth2-client:
            provider: my-auth-server
            client-id: gateway-app
            client-secret: 123456
            authorization-grant-type: authorization_code
            redirect-uri: http://127.0.0.1:8090/authorized
            scope: openid, profile
        provider:
          my-auth-server:
            issuer-uri: http://127.0.0.1:9000
````

Las configuraciones anteriores muestran los dos papeles que estar√≠a cumpliendo nuestro `gateway-server`, veamos uno por
uno.

### 1. Como Resource Server

````yml
spring:
  security:
    oauth2:
      resourceserver:
        jwt:
          issuer-uri: http://127.0.0.1:9000
````

- Esto indica que el `gateway-server` usar√° `JWT` para validar tokens.
- Spring buscar√° autom√°ticamente el `JWK Set` en el endpoint `http://127.0.0.1:9000/.well-known/openid-configuration`.
- De ese endpoint obtendr√° el `jwks_uri`, por ejemplo `http://127.0.0.1:9000/oauth2/jwks`.
- `Spring` descargar√° la `clave p√∫blica` una sola vez y luego la `cachear√°` localmente para `validar los JWT` sin tener
  que llamar al `authorization server` en cada solicitud, justo como mencionamos antes.

### 2. Como OAuth2 Client

````yml
      client:
        registration:
          my-oauth2-client:
            provider: my-auth-server
            client-id: gateway-app
            client-secret: 123456
            authorization-grant-type: authorization_code
            redirect-uri: http://127.0.0.1:8090/authorized
            scope: openid, profile
        provider:
          my-auth-server:
            issuer-uri: http://127.0.0.1:9000
````

- Estamos registrando un cliente llamado `my-oauth2-client` que apunta al `authorization-server`.
- La propiedad `issuer-uri` es clave, ya que a partir de ah√≠ Spring podr√° autoconfigurar los endpoints necesarios
  `(/authorize, /token, etc.)`.
- No solo hemos configurado correctamente el `redirect-uri` de acuerdo con lo registrado en el `Authorization Server`
  (en la clase `SecurityConfig`), sino que adem√°s coinciden todos los valores clave del cliente: `client-id`,
  `client-secret`, `scopes` y el `authorization-grant-type`.

## Configurando clase Resource Server Security Endpoint

Ahora tenemos que implementar la clase `SecurityConfig` pero por el lado del `gateway-server` donde configuraremos la
protecci√≥n de las rutas, los endpoints, etc.

**Nota**
> Recordar que nuestro `gateway-server` est√° trabajando con `programaci√≥n reactiva`, por lo tanto la configuraci√≥n ser√°
> teniendo en cuenta ese detalle. Por ejemplo:
>
> En este caso usamos el `SecurityWebFilterChain` que se usa en `Spring WebFlux (Reactive stack)`, donde todo es
> reactivo.
>
> Si nuestro `gateway-server` fuera una aplicaci√≥n `Spring MVC (Servlet stack)`, como en aplicaciones cl√°sicas con
> Spring Boot, entonces usar√≠amos `SecurityFilterChain`.

A continuaci√≥n se muestra la configuraci√≥n inicial de nuestro `SecurityConfig`.

````java

@Configuration
public class SecurityConfig {

    @Bean
    public SecurityWebFilterChain securityWebFilterChain(ServerHttpSecurity http) {
        http
                .authorizeExchange(authorize -> authorize
                        .pathMatchers("/authorized", "/logout").permitAll()
                        .pathMatchers(HttpMethod.GET, "/api/v1/products", "/api/v1/items", "/api/v1/users").permitAll()
                        .pathMatchers(HttpMethod.GET, "/api/v1/products/{productId}", "/api/v1/items/{productId}", "/api/v1/users/{userId}", "/api/v1/users/username/{username}").hasAnyRole("ADMIN", "USER")
                        .pathMatchers("/api/v1/products/**", "/api/v1/items/**", "/api/v1/users/**").hasRole("ADMIN")
                        .anyExchange().authenticated()
                )
                .cors(ServerHttpSecurity.CorsSpec::disable)
                .securityContextRepository(NoOpServerSecurityContextRepository.getInstance())
                .oauth2Login(Customizer.withDefaults())
                .oauth2Client(Customizer.withDefaults())
                .oauth2ResourceServer(oauth2ResourceServer ->
                        oauth2ResourceServer.jwt(Customizer.withDefaults()));
        return http.build();
    }

}
````

1. Uso de `SecurityWebFilterChain`, esto es completamente correcto porque estamos usando `Spring WebFlux` (por eso es
   `SecurityWebFilterChain` y no `SecurityFilterChain` que es para `Spring MVC`).


2. Permitimos el acceso p√∫blico a endpoints espec√≠ficos:
    - `/authorized` y `/logout` ‚Üí acceso p√∫blico.
    - `GET` a `/api/v1/products`, `/items`, `/users` ‚Üí acceso p√∫blico.
    - `GET` a recursos individuales ‚Üí restringido a `ROLE_ADMIN` o `ROLE_USER`.
    - Otros m√©todos `(POST, PUT, DELETE, etc.)` a esos endpoints ‚Üí restringidos a `ROLE_ADMIN`.


3. Autenticaci√≥n `OAuth2`:
    - `oauth2Login()` y `oauth2Client()` ‚Üí esto permite que act√∫e como `cliente OAuth2`.
    - `oauth2ResourceServer()` ‚Üí protege las rutas con `tokens JWT`.


4. `CORS` deshabilitado (de momento), por ahora podemos mantenerlo deshabilitado si no tenemos frontend a√∫n. Pero cuando
   lo tengamos, asegurarnos de:
    - Habilitar CORS.
    - Especificar el origen del frontend (por ejemplo http://localhost:4200).
    - Probar llamadas desde el navegador para validar que no haya errores CORS.

5. `.securityContextRepository(NoOpServerSecurityContextRepository.getInstance())`, en aplicaciones reactivas con
   `Spring Security`, no se crean sesiones por defecto como s√≠ pasa con `Spring MVC`. Pero si queremos asegurarnos
   expl√≠citamente de que no se almacene nada en el `SecurityContext` de la sesi√≥n, podemos deshabilitarlo con esta
   configuraci√≥n. Entonces, esta configuraci√≥n le dice a Spring: *"No almacenes el contexto de seguridad en ning√∫n lado,
   ni en memoria ni en una sesi√≥n. Todo debe venir con cada petici√≥n (por ejemplo, en el JWT)."*

**Importante: ¬øQui√©n se ejecuta primero, el SecurityConfig o las rutas del gateway?**
> La seguridad se eval√∫a primero, antes de que el `RoutePredicateHandlerMapping` del `Gateway` intente hacer el
> enrutamiento.
>
> En otras palabras, cuando llega una petici√≥n al gateway, por ejemplo: `GET http://localhost:8090/api/v1/users/1`:
>
> 1. `Spring Security` (usando el `SecurityWebFilterChain`) intercepta la petici√≥n.
> 2. Eval√∫a los `pathMatchers()`:
> - En nuestro caso, `/api/v1/users/1` es una ruta protegida.
> - Seg√∫n la configuraci√≥n, necesita el rol `ADMIN` o `USER`.
> 3. Si el `token JWT` no est√° presente o no tiene el rol requerido, la petici√≥n es bloqueada ah√≠ mismo (con `401` o
     `403`), y nunca se intenta redirigir al microservicio `user-service`.
> 4. Si pasa la validaci√≥n de seguridad, entonces s√≠ se eval√∫a la configuraci√≥n de enrutamiento (`application.yml`) y la
     petici√≥n se reenv√≠a al microservicio correspondiente (usando `lb://user-service`).

**Conclusi√≥n**

> Primero eval√∫a lo configurado en el `SecurityConfig`, y solo si pasa, entonces se intenta hacer match con las rutas
> del `application.yml`.

## Probando implementaci√≥n del tipo de concesi√≥n de c√≥digo de autorizaci√≥n (Authorization Code Grant Type)

Vamos a ejecutar nuestros microservicios para ver que las configuraciones que hemos realizado hasta ahora est√©n
funcionando sin problemas. Como solo vamos a hacer pruebas, con el `user-service` ser√≠a suficiente, luego s√≠ es
necesario hacer uso del `discovery-server`, `authorization-server` y `gateway-server`.

Levantamos las aplicaciones en el siguiente orden.

- discovery-server
- authorization-server
- user-service
- gateway-server

Como tenemos levantado el `authorization-server` podemos ingresar a una ruta que este servidor nos proporciona como
parte de la especificaci√≥n de `OAuth 2.1 Authorization Server Metadata`. `Spring Authorization Server` la expone
autom√°ticamente si configuramos correctamente nuestro servidor de autorizaci√≥n.

````bash
http://127.0.0.1:9000/.well-known/oauth-authorization-server
````

Podemos observar que nos retorna un `JSON` con metadatos. Este documento permite a los `clientes OAuth` (como una app
`frontend` o `backend`) descubrir los endpoints del `servidor de autorizaci√≥n`.

![01.png](assets/section-10/01.png)

Del resultado anterior, utilizaremos los siguientes endpoints que nos permitir√° realizar el flujo del tipo de concesi√≥n
`authentication code`.

````bash
http://127.0.0.1:9000/oauth2/authorize
http://127.0.0.1:9000/oauth2/token
````

### Obteniendo c√≥digo de autorizaci√≥n

El primer paso para el tipo de concesi√≥n `Authorization code` es obtener un `c√≥digo` que luego lo intercambiaremos por
un `access token`. Entonces, para apoyarnos con el inicio de este flujo utilizaremos la siguiente web
`https://oauthdebugger.com/debug`.

A continuaci√≥n se muestra marcado en un cuadro rojo, los campos que se ingresaron manualmente. Adem√°s, es importante
notar que en el campo `Redirect URI (required)` estamos colocando la misma direcci√≥n de esta web
`https://oauthdebugger.com/debug` que es la misma que configuramos en el `SecurityConfig` del `authorization-server`.
Esto es relevante, porque cuando hagamos un `Send Request` la solicitud se enviar√° a
`http://127.0.0.1:9000/oauth2/authorize` (servidor de autorizaci√≥n) donde se generar√° el c√≥digo de autorizaci√≥n. Luego,
el servidor de autorizaci√≥n redireccionar√° a esta web el c√≥digo generado.

![02.png](assets/section-10/02.png)

Al hacer clic en `Send Request` y al ser la primera vez que hacemos la solicitud al `authorization-server`, nos pide
que nos autentiquemos. En este caso usamos una de las credenciales almacenadas en memoria dentro del servidor de
autorizaci√≥n.

![03.png](assets/section-10/03.png)

Luego de que la autenticaci√≥n sea exitosa, el servidor de autorizaci√≥n nos retornar√° el `Authorization Code` solicitado.

![04.png](assets/section-10/04.png)

### Obteniendo token de acceso

Ese c√≥digo de autorizaci√≥n lo utilizaremos para solicitar el `access token`.

````bash
$ curl -v -X POST -u gateway-app:123456 -d "grant_type=authorization_code&redirect_uri=https://oauthdebugger.com/debug&code=IoMHnjZoEG0K5zdWwUrW1BgDAPmdKGxtbg4eiusFRVf1TSJpMPZm1X3kzLfCN5xrcVS9jjxdjV-AonDqAh-6drejTw25wlqvkQjmVGuYcA7gqjSUXkjW19n-VprDm-1s" http://localhost:9000/oauth2/token | jq
>
< HTTP/1.1 200
< X-Content-Type-Options: nosniff
< X-XSS-Protection: 0
< Cache-Control: no-cache, no-store, max-age=0, must-revalidate
< Pragma: no-cache
< Expires: 0
< X-Frame-Options: DENY
< Content-Type: application/json;charset=UTF-8
< Transfer-Encoding: chunked
< Date: Mon, 21 Apr 2025 01:39:58 GMT
<
{
  "access_token": "eyJraWQiOiJmYmRhYWNjMC04ZjhkLTRmNDAtODVkYS1kZDU0MGY0OTdkMGQiLCJhbGciOiJSUzI1NiJ9.eyJzdWIiOiJhZG1pbiIsImF1ZCI6ImdhdGV3YXktYXBwIiwibmJmIjoxNzQ1MTk5NTk4LCJzY29wZSI6WyJvcGVuaWQiLCJwcm9maWxlIl0sImlzcyI6Imh0dHA6Ly8xMjcuMC4wLjE6OTAwMCIsImV4cCI6MTc0NTE5OTg5OCwiaWF0IjoxNzQ1MTk5NTk4LCJqdGkiOiJiMGZlMWIwZC0yODAxLTRmMzMtYWZiNi1lMDBmYTEwMWRkMGUifQ.Vq-I9fW5sGBQ_dfdPuNmyruZ96v9-KhUEjHtKdGrtzom8Fz_dQxE5hgUB6CCXREO8zH3arslvxvMRkSARpw4cN0Jz8DY7-s9-tCqcJ7RKhF8s0jcw_KlRcUAQ4X6qlbmZk52taxekF1emsNnq2yMqhQRBWJlZiJA0LMA7sLLHfRRbhNHJBBx7aM0eCJAs9Hy3_OuOGtX-0IfuqjFaaJOGsc1Q34C9Jt4zCtYIoVZ8O82jiNI9qmSxnNzCPWCGDOcs3-zPFYiUpWn64BqkJnhhvplI5RXaYeh9EYq-U66veEg-d5wt3c8ZQRWylOeEbNoWwwQtkYnUOnBbIH_xbEqog",
  "refresh_token": "dVcOL4LjKuFUF3j0SByescHRFjYtH9XOM3eDroiJR-JTtnFEreqW6CkzPqQM2xbcbd1FdzXMEtsr73qzKyxCqvYbnfwAGYJu-rX1uJcH3nQFG2rLDszJ1I7MsqgQZhoO",
  "scope": "openid profile",
  "id_token": "eyJraWQiOiJmYmRhYWNjMC04ZjhkLTRmNDAtODVkYS1kZDU0MGY0OTdkMGQiLCJhbGciOiJSUzI1NiJ9.eyJzdWIiOiJhZG1pbiIsImF1ZCI6ImdhdGV3YXktYXBwIiwiYXpwIjoiZ2F0ZXdheS1hcHAiLCJhdXRoX3RpbWUiOjE3NDUxOTk1NzcsImlzcyI6Imh0dHA6Ly8xMjcuMC4wLjE6OTAwMCIsImV4cCI6MTc0NTIwMTM5OCwiaWF0IjoxNzQ1MTk5NTk4LCJub25jZSI6Imsxa2k1OGVtYWFmIiwianRpIjoiZTM5NGMwMDAtNzZkOC00ZTBiLWE2ODMtNjNjNGQyZjI1ZjE1Iiwic2lkIjoiNWV1Ym51THVvbHlMbWRTM0ZIeHBuZHNyXzJ0Nmw1UFdxb1FfeWY5Y01HcyJ9.LM4heL-I2mR8KF_2nFX-eGs2utgT9p7hJ0Dtld3vaH2mCQgRiEEBSZFYyPz0pU7D1Vz68M6m5wPKCs7F009D48_s8N7v805YC-q_s3TzDbvANesxLAxrU8eM9PrQp3akLo3PzikoDSB9UT70aEXbVj4rj22u0pXbDqabrmuvKoRipvcd5RcSqWGVWZFACm4t-deE7RRtee3A8trZVWbnp_7XNcaFIbFXY2CYcybsZnjPkMoQuk9Emvx72GrOZqT3zgC1jbY4ZVGOrjPxbDhBXe5VH9NF5gMLNA0To10SxNSSI9uZtOTYs7qZQJ7LvgqVWCGbSCpfu8HD2Z1uMH652w",
  "token_type": "Bearer",
  "expires_in": 300
}
````

Si decodificamos el `access token` podemos observar que se corresponde con el usuario con el que iniciamos sesi√≥n.

![05.png](assets/section-10/05.png)

Si quisi√©ramos obtener un `access token` para otro usuario, debemos cerrar sesi√≥n ingresando a la siguiente url
`http://127.0.0.1:9000/logout`. Como vemos nos aparece el mensaje `se ha cerrado la sesi√≥n`, ahora s√≠ podemos volver a
iniciar sesi√≥n con otro usuario.

![06.png](assets/section-10/06.png)
