# Sección 10: Spring Authorization Server (OAuth 2.1)

---

## Creando microservicio Spring Authorization Server (OAuth 2.1)

Creamos el nuevo microservicio desde
[Spring Initializr](https://start.spring.io/#!type=maven-project&language=java&platformVersion=3.4.4&packaging=jar&jvmVersion=21&groupId=dev.magadiflo&artifactId=authorization-server&name=authorization-server&description=Authorization%20Server&packageName=dev.magadiflo.authorization.server.app&dependencies=web,lombok,cloud-eureka,security,oauth2-authorization-server)
donde definiremos las siguientes dependencias.

Al ser `Spring Authorization Server` una capa construida por encima de `Spring Security`, necesitamos añadir
también esta dependencia, al igual que `Spring Web` para el manejo de solicitudes y respuestas HTTP que utiliza
`Spring Authorization Server` para realizar las tareas de autenticación y autorización.

````xml
<!--Spring Boot 3.4.4-->
<!--Spring Cloud 2024.0.1-->
<!--Java 21-->
<dependencies>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-oauth2-authorization-server</artifactId>
    </dependency>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-security</artifactId>
    </dependency>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-web</artifactId>
    </dependency>
    <dependency>
        <groupId>org.springframework.cloud</groupId>
        <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>
    </dependency>

    <dependency>
        <groupId>org.projectlombok</groupId>
        <artifactId>lombok</artifactId>
        <optional>true</optional>
    </dependency>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-test</artifactId>
        <scope>test</scope>
    </dependency>
    <dependency>
        <groupId>org.springframework.security</groupId>
        <artifactId>spring-security-test</artifactId>
        <scope>test</scope>
    </dependency>
</dependencies>
````

En el `application.yml` del `authorization-server` agregamos las siguientes configuraciones iniciales.

````yml
server:
  port: 9000
  error:
    include-message: always

spring:
  application:
    name: authorization-server

eureka:
  instance:
    prefer-ip-address: true
    instance-id: ${spring.cloud.client.hostname}:${spring.application.name}:${random.value}
  client:
    service-url:
      defaultZone: http://localhost:8761/eureka/
````

## Configurando el Servidor de Autorización

En este apartado utilizaremos la
[guía de la documentación de Spring Authorization Server](https://docs.spring.io/spring-authorization-server/reference/getting-started.html)
para definir los componentes requeridos en la configuración de nuestro servidor de autorización.

El código siguiente es tal cual se muestra en la documentación, con algunos pequeños cambios para ajustar al proyecto de
microservicios que venimos realizando. Este es el típico ejemplo que muestra cómo levantar un `Authorization Server`
básico con `OAuth 2.1` y soporte `OIDC (OpenID Connect)`.

**Nota**
> La anotación `@EnableWebSecurity` sobre nuestra clase de configuración `SecurityConfig` no es necesario (aunque en el
> código de la documentación sí lo usa).
>
> `¿Por qué no es necesaria?`, `Spring Boot auto-configura Spring Security` si encuentra uno o más `SecurityFilterChain`
> definidos como `@Bean`.
>
> A partir de `Spring Security 5.7` (usado en `Spring Boot 3`), se recomienda usar el enfoque basado en beans,
> es decir: `@Bean public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {}`.
>
> Con este enfoque moderno, `Spring Security` se registra automáticamente sin necesidad de `@EnableWebSecurity`.
>
> Antes (`Spring Boot 2.x` y versiones anteriores), la anotación `@EnableWebSecurity` era necesaria para habilitar la
> configuración de seguridad web en `Spring Security`. Si no la usábamos, Spring no aplicaba la configuración de
> seguridad correctamente.
>
> Ahora, en `Spring Boot 3.x`, `Spring Boot` se encarga de habilitar la configuración de seguridad automáticamente si
> detecta `SecurityFilterChain` como beans en el contexto de la aplicación, y si no la necesitas explícitamente, Spring
> Boot se encarga de la configuración por debajo.
>
> Esto significa que podemos prescindir de la anotación `@EnableWebSecurity` y `Spring Security` funciona bien solo con
> la definición de los `SecurityFilterChain` como beans.

````java

@Configuration
public class SecurityConfig {

    @Bean
    @Order(1)
    public SecurityFilterChain authorizationServerSecurityFilterChain(HttpSecurity http) throws Exception {
        OAuth2AuthorizationServerConfigurer authorizationServerConfigurer =
                OAuth2AuthorizationServerConfigurer.authorizationServer();

        http
                .securityMatcher(authorizationServerConfigurer.getEndpointsMatcher())
                .with(authorizationServerConfigurer, (authorizationServer) ->
                        authorizationServer
                                .oidc(Customizer.withDefaults())    // Enable OpenID Connect 1.0
                )
                .authorizeHttpRequests((authorize) ->
                        authorize
                                .anyRequest().authenticated()
                )
                // Redirect to the login page when not authenticated from the
                // authorization endpoint
                .exceptionHandling((exceptions) -> exceptions
                        .defaultAuthenticationEntryPointFor(
                                new LoginUrlAuthenticationEntryPoint("/login"),
                                new MediaTypeRequestMatcher(MediaType.TEXT_HTML)
                        )
                );

        return http.build();
    }

    @Bean
    @Order(2)
    public SecurityFilterChain defaultSecurityFilterChain(HttpSecurity http) throws Exception {
        http
                .authorizeHttpRequests((authorize) -> authorize
                        .anyRequest().authenticated()
                )
                // Form login handles the redirect to the login page from the
                // authorization server filter chain
                .formLogin(Customizer.withDefaults());

        return http.build();
    }

    @Bean
    public UserDetailsService userDetailsService() {
        UserDetails admin = User.builder()
                .username("admin")
                .password("{noop}123456")
                .roles("USER", "ADMIN")
                .build();

        UserDetails martin = User.builder()
                .username("martin")
                .password("{noop}123456")
                .roles("USER")
                .build();

        return new InMemoryUserDetailsManager(admin, martin);
    }

    @Bean
    public RegisteredClientRepository registeredClientRepository() {
        RegisteredClient oidcClient = RegisteredClient.withId(UUID.randomUUID().toString())
                .clientId("gateway-app")
                .clientSecret("{noop}123456")
                .clientAuthenticationMethod(ClientAuthenticationMethod.CLIENT_SECRET_BASIC)
                .authorizationGrantType(AuthorizationGrantType.AUTHORIZATION_CODE)
                .authorizationGrantType(AuthorizationGrantType.REFRESH_TOKEN)
                .redirectUri("http://127.0.0.1:8090/login/oauth2/code/gateway-app")
                .redirectUri("http://127.0.0.1:8090/authorized")
                .postLogoutRedirectUri("http://127.0.0.1:8090/logout")
                .scope(OidcScopes.OPENID)
                .scope(OidcScopes.PROFILE)
                .clientSettings(ClientSettings.builder().requireAuthorizationConsent(false).build())
                .build();

        return new InMemoryRegisteredClientRepository(oidcClient);
    }

    @Bean
    public JWKSource<SecurityContext> jwkSource() {
        KeyPair keyPair = generateRsaKey();
        RSAPublicKey publicKey = (RSAPublicKey) keyPair.getPublic();
        RSAPrivateKey privateKey = (RSAPrivateKey) keyPair.getPrivate();
        RSAKey rsaKey = new RSAKey.Builder(publicKey)
                .privateKey(privateKey)
                .keyID(UUID.randomUUID().toString())
                .build();
        JWKSet jwkSet = new JWKSet(rsaKey);
        return new ImmutableJWKSet<>(jwkSet);
    }

    private static KeyPair generateRsaKey() {
        KeyPair keyPair;
        try {
            KeyPairGenerator keyPairGenerator = KeyPairGenerator.getInstance("RSA");
            keyPairGenerator.initialize(2048);
            keyPair = keyPairGenerator.generateKeyPair();
        } catch (Exception ex) {
            throw new IllegalStateException(ex);
        }
        return keyPair;
    }

    @Bean
    public JwtDecoder jwtDecoder(JWKSource<SecurityContext> jwkSource) {
        return OAuth2AuthorizationServerConfiguration.jwtDecoder(jwkSource);
    }

    @Bean
    public AuthorizationServerSettings authorizationServerSettings() {
        return AuthorizationServerSettings.builder().build();
    }

}
````

**Dónde**

1. `SecurityFilterChain authorizationServerSecurityFilterChain(...)`, este filtro es exclusivo para proteger los
   endpoints del `Authorization Server`, como `/oauth2/token`, `/oauth2/authorize`, etc.
    - Se usa `OAuth2AuthorizationServerConfigurer` para configurar los endpoints.
    - Se habilita `OIDC` con `.oidc(Customizer.withDefaults())`.
    - Redirige a `/login` si el usuario no está autenticado.
    - Se asegura que cualquier request a los endpoints esté autenticada.


2. `SecurityFilterChain defaultSecurityFilterChain(...)`, este es el filtro para el resto de las rutas no manejadas por
   el `Authorzation Server`.
    - Simple: cualquier request requiere autenticación.
    - Se activa `formLogin()` (pantalla de login por defecto de Spring Security).


3. `UserDetailsService `, estamos definiendo temporalmente usuarios que estarán almacenados en
   memoria. Estos usuarios serán usuarios de prueba mientras desarrollamos el servidor de autorización. Recordemos que
   tenemos un `user-service`, precisamente ese servicio será el que más adelante usaremos para la gestión de los
   usuarios.


4. `RegisteredClientRepository`, definimos un `cliente OAuth2` registrado. Es el cliente que va a pedir autorización. En
   este `RegisteredClientRepository` vemos tres urls definidas, de las cuales:
    - `.redirectUri("http://127.0.0.1:8090/login/oauth2/code/gateway-app")`, es una url propia de `OAuth 2.1`,
      simplemente configuramos el nombre del cliente registrado `gateway-app`.
    - `.redirectUri("http://127.0.0.1:8090/authorized")`, es una url personalizada que debemos crear.
    - `.postLogoutRedirectUri("http://127.0.0.1:8090/logout")`, es una url personalizada que debemos crear.
      Además, colocamos en `false` el `requireAuthorizationConsent()` para que no pida el consentimiento de los scopes.


5. `JWKSource`, este bean genera un par de llaves `RSA (pública y privada)` para firmar `tokens JWT`. Luego, las
   convierte a formato `JWK` para que el `Authorization Server` pueda publicarlas en su endpoint
   `.well-known/jwks.json`.


6. `generateRsaKey()`, genera la llave `RSA` de `2048 bits`. Es puro Java básico para criptografía.


7. `JwtDecoder`, `Spring Authorization Server` necesita un `JwtDecoder` para validar y decodificar los tokens que emite.
   Aquí lo construyes a partir del `JWKSource`.


8. `AuthorizationServerSettings`, construye la configuración del `Authorization Server`. Por defecto, expone los
   endpoints en `/oauth2/token`, `/oauth2/authorize`, etc. Se puede personalizar, pero aquí se usa la config por
   defecto.

Ahora, nos vamos al `gateway-server` y configuramos la ruta hacia nuestro servidor de autorización.

````yml
spring:
  application:
    name: gateway-server
  cloud:
    gateway:
      routes:
        - id: authorization-server-route
          uri: lb://authorization-server
          predicates:
            - Path=/api/v1/authorization-server/**
          filters:
            - RewritePath=/api/v1/authorization-server/(?<path>.*), /$\{path}
````

**Dónde**

- `uri: lb://authorization-server`, esto indica que la solicitud se enviará a un servicio llamado `authorization-server`
  registrado en `Eureka` (porque usamos `lb://`, es decir, `load balancer via discovery`). Debemos asegurarnos de que el
  `spring.application.name` del servidor de autorización lo hayamos definido como `authorization-server`
- `Path=/api/v1/authorization-server/**`, solo las rutas que empiecen con `/api/v1/authorization-server/` serán
  redirigidas al `Authorization Server`.
- `RewritePath`, este filtro elimina el prefijo `/api/v1/authorization-server/` antes de enviar la solicitud al
  `Authorization Server`. Por ejemplo:
    - Petición del cliente: `GET /api/v1/authorization-server/oauth2/token`
    - Se reescribe como: `GET /oauth2/token` (que es lo que espera `Spring Authorization Server`)

## Implementando endpoint /authorized y /logout en Gateway Server

Recordemos que en el `SecurityConfig` del `authorization-server` creamos un bean `RegisteredClientRepository`. Dentro
de este bean definimos las siguientes uris que dijimos, debíamos crear:

- http://127.0.0.1:8090/authorized
- http://127.0.0.1:8090/logout

Entonces, en este apartado implementaremos esas uris en nuestro `gateway-server`, dado que el puerto que definimos
es precisamente el puerto del `gateway-server`.

````java

@RestController
public class AppController {

    @GetMapping(path = "/authorized")
    public ResponseEntity<Map<String, String>> authorized(@RequestParam String code) {
        return ResponseEntity.ok(Collections.singletonMap("code", code));
    }

    @PostMapping(path = "/logout")
    public ResponseEntity<Map<String, String>> logout() {
        return ResponseEntity.ok(Collections.singletonMap("logout", "OK"));
    }
}
````

## Configurando Resource Server y Cliente OAuth2 en yml

Nuestro `gateway-server` va a cumplir dos papeles:

1. Será un `cliente OAuth2` del `authorization-server`, para iniciar el flujo de autenticación del usuario (por ejemplo,
   mediante `spring-security-oauth2-client`). El usuario se podrá loguear y obtener un `access token` que le permitirá
   acceder a los distintos microservicios.


2. También actuará como un `resource server`, encargado de validar el `access token` incluido en las peticiones
   (generalmente mediante un encabezado `Authorization: Bearer <token>`). Para esto, utiliza la configuración del
   `authorization-server` (como el `issuer-uri` o las `JWKs`) para validar que el token sea válido y no haya expirado.
   Esto protege las rutas del gateway y evita que usuarios no autorizados accedan a los microservicios.

⚠️ Importante
> El `gateway` no tiene que llamar al `authorization server` en cada solicitud para validar el token. Es decir,
> no necesita preguntar al `authorization server` en cada solicitud si el token es válido. Porque puede verificar la
> firma localmente usando la clave pública del `authorization server`. Es decir, usa una
> `clave pública (JWK)` publicada por el `authorization-server` para validar localmente la `firma del token JWT`. Esto
> es más eficiente.
>
> El authorization server expone un endpoint JWK (JSON Web Key), normalmente accesible en una URL como:
> `http://localhost:9000/.well-known/jwks.json`
>
> Este endpoint contiene la(s) clave(s) pública(s) necesarias para que cualquier `resource server` pueda verificar
> las firmas de los `JWT` emitidos. Entonces el flow es así:
>
> 🔁 Primera vez que el resource server recibe un token → si no tiene la clave pública, consulta el endpoint JWK y la
> guarda en memoria (caché).
>
> 📦 Después → usa la clave en memoria para validar los siguientes tokens sin tener que llamar otra vez al `authorization
> server`.

Así que iniciamos agregando las siguientes dependencias al `pom.xml` del `gateway-server`.

````xml

<dependencies>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-oauth2-client</artifactId>
    </dependency>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-oauth2-resource-server</artifactId>
    </dependency>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-security</artifactId>
    </dependency>
</dependencies>
````

Luego, vamos al `application.yml` del `gateway-server` para configurar nuestro servidor `gateway` como
`cliente de OAuth2` y como `servidor de recursos`.

````yml

spring:
  application:
    name: gateway-server
  security:
    oauth2:
      resourceserver:
        jwt:
          issuer-uri: http://127.0.0.1:9000
      client:
        registration:
          my-oauth2-client:
            provider: my-auth-server
            client-id: gateway-app
            client-secret: 123456
            authorization-grant-type: authorization_code
            redirect-uri: http://127.0.0.1:8090/authorized
            scope: openid, profile
        provider:
          my-auth-server:
            issuer-uri: http://127.0.0.1:9000
````

Las configuraciones anteriores muestran los dos papeles que estaría cumpliento nuestro `gateway-server`, veamos uno por
uno.

### 1. Como Resource Server

````yml
spring:
  security:
    oauth2:
      resourceserver:
        jwt:
          issuer-uri: http://127.0.0.1:9000
````

- Esto indica que el `gateway-server` usará `JWT` para validar tokens.
- Spring buscará automáticamente el `JWK Set` en el endpoint `http://127.0.0.1:9000/.well-known/openid-configuration`.
- De ese endpoint obtendrá el `jwks_uri`, por ejemplo `http://127.0.0.1:9000/oauth2/jwks`.
- `Spring` descargará la `clave pública` una sola vez y luego la `cacheará` localmente para `validar los JWT` sin tener
  que llamar al `authorization server` en cada solicitud, justo como mencionamos antes.

### 2. Como OAuth2 Client

````yml
      client:
        registration:
          my-oauth2-client:
            provider: my-auth-server
            client-id: gateway-app
            client-secret: 123456
            authorization-grant-type: authorization_code
            redirect-uri: http://127.0.0.1:8090/authorized
            scope: openid, profile
        provider:
          my-auth-server:
            issuer-uri: http://127.0.0.1:9000
````

- Estamos registrando un cliente llamado `my-oauth2-client` que apunta al `authorization-server`.
- La propiedad `issuer-uri` es clave, ya que a partir de ahí Spring podrá autoconfigurar los endpoints necesarios
  `(/authorize, /token, etc.)`.
- No solo hemos configurado correctamente el `redirect-uri` de acuerdo con lo registrado en el `Authorization Server`
  (en la clase `SecurityConfig`), sino que además coinciden todos los valores clave del cliente: `client-id`,
  `client-secret`, `scopes` y el `authorization-grant-type`.
