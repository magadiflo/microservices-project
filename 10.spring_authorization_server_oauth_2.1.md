# Secci√≥n 10: Spring Authorization Server (OAuth 2.1)

---

## Creando microservicio Spring Authorization Server (OAuth 2.1)

Creamos el nuevo microservicio desde
[Spring Initializr](https://start.spring.io/#!type=maven-project&language=java&platformVersion=3.4.4&packaging=jar&jvmVersion=21&groupId=dev.magadiflo&artifactId=authorization-server&name=authorization-server&description=Authorization%20Server&packageName=dev.magadiflo.authorization.server.app&dependencies=web,lombok,cloud-eureka,security,oauth2-authorization-server)
donde definiremos las siguientes dependencias.

Al ser `Spring Authorization Server` una capa construida por encima de `Spring Security`, necesitamos a√±adir
tambi√©n esta dependencia, al igual que `Spring Web` para el manejo de solicitudes y respuestas HTTP que utiliza
`Spring Authorization Server` para realizar las tareas de autenticaci√≥n y autorizaci√≥n.

````xml
<!--Spring Boot 3.4.4-->
<!--Spring Cloud 2024.0.1-->
<!--Java 21-->
<dependencies>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-oauth2-authorization-server</artifactId>
    </dependency>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-security</artifactId>
    </dependency>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-web</artifactId>
    </dependency>
    <dependency>
        <groupId>org.springframework.cloud</groupId>
        <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>
    </dependency>

    <dependency>
        <groupId>org.projectlombok</groupId>
        <artifactId>lombok</artifactId>
        <optional>true</optional>
    </dependency>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-test</artifactId>
        <scope>test</scope>
    </dependency>
    <dependency>
        <groupId>org.springframework.security</groupId>
        <artifactId>spring-security-test</artifactId>
        <scope>test</scope>
    </dependency>
</dependencies>
````

En el `application.yml` del `authorization-server` agregamos las siguientes configuraciones iniciales.

````yml
server:
  port: 9000
  error:
    include-message: always

spring:
  application:
    name: authorization-server

eureka:
  instance:
    prefer-ip-address: true
    instance-id: ${spring.cloud.client.hostname}:${spring.application.name}:${random.value}
  client:
    service-url:
      defaultZone: http://localhost:8761/eureka/
````

## Configurando el Servidor de Autorizaci√≥n

En este apartado utilizaremos la
[gu√≠a de la documentaci√≥n de Spring Authorization Server](https://docs.spring.io/spring-authorization-server/reference/getting-started.html)
para definir los componentes requeridos en la configuraci√≥n de nuestro servidor de autorizaci√≥n.

El c√≥digo siguiente es tal cual se muestra en la documentaci√≥n, con algunos peque√±os cambios para ajustar al proyecto de
microservicios que venimos realizando. Este es el t√≠pico ejemplo que muestra c√≥mo levantar un `Authorization Server`
b√°sico con `OAuth 2.1` y soporte `OIDC (OpenID Connect)`.

**Nota**
> La anotaci√≥n `@EnableWebSecurity` sobre nuestra clase de configuraci√≥n `SecurityConfig` no es necesario (aunque en el
> c√≥digo de la documentaci√≥n s√≠ lo usa).
>
> `¬øPor qu√© no es necesaria?`, `Spring Boot auto-configura Spring Security` si encuentra uno o m√°s `SecurityFilterChain`
> definidos como `@Bean`.
>
> A partir de `Spring Security 5.7` (usado en `Spring Boot 3`), se recomienda usar el enfoque basado en beans,
> es decir: `@Bean public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {}`.
>
> Con este enfoque moderno, `Spring Security` se registra autom√°ticamente sin necesidad de `@EnableWebSecurity`.
>
> Antes (`Spring Boot 2.x` y versiones anteriores), la anotaci√≥n `@EnableWebSecurity` era necesaria para habilitar la
> configuraci√≥n de seguridad web en `Spring Security`. Si no la us√°bamos, Spring no aplicaba la configuraci√≥n de
> seguridad correctamente.
>
> Ahora, en `Spring Boot 3.x`, `Spring Boot` se encarga de habilitar la configuraci√≥n de seguridad autom√°ticamente si
> detecta `SecurityFilterChain` como beans en el contexto de la aplicaci√≥n, y si no la necesitas expl√≠citamente, Spring
> Boot se encarga de la configuraci√≥n por debajo.
>
> Esto significa que podemos prescindir de la anotaci√≥n `@EnableWebSecurity` y `Spring Security` funciona bien solo con
> la definici√≥n de los `SecurityFilterChain` como beans.

````java

@Configuration
public class SecurityConfig {

    @Bean
    @Order(1)
    public SecurityFilterChain authorizationServerSecurityFilterChain(HttpSecurity http) throws Exception {
        OAuth2AuthorizationServerConfigurer authorizationServerConfigurer =
                OAuth2AuthorizationServerConfigurer.authorizationServer();

        http
                .securityMatcher(authorizationServerConfigurer.getEndpointsMatcher())
                .with(authorizationServerConfigurer, (authorizationServer) ->
                        authorizationServer
                                .oidc(Customizer.withDefaults())    // Enable OpenID Connect 1.0
                )
                .authorizeHttpRequests((authorize) ->
                        authorize
                                .anyRequest().authenticated()
                )
                // Redirect to the login page when not authenticated from the
                // authorization endpoint
                .exceptionHandling((exceptions) -> exceptions
                        .defaultAuthenticationEntryPointFor(
                                new LoginUrlAuthenticationEntryPoint("/login"),
                                new MediaTypeRequestMatcher(MediaType.TEXT_HTML)
                        )
                );

        return http.build();
    }

    @Bean
    @Order(2)
    public SecurityFilterChain defaultSecurityFilterChain(HttpSecurity http) throws Exception {
        http
                .authorizeHttpRequests((authorize) -> authorize
                        .anyRequest().authenticated()
                )
                .csrf(AbstractHttpConfigurer::disable)
                // Form login handles the redirect to the login page from the
                // authorization server filter chain
                .formLogin(Customizer.withDefaults());

        return http.build();
    }

    @Bean
    public UserDetailsService userDetailsService() {
        UserDetails admin = User.builder()
                .username("admin")
                .password("{noop}123456")
                .roles("USER", "ADMIN")
                .build();

        UserDetails martin = User.builder()
                .username("martin")
                .password("{noop}123456")
                .roles("USER")
                .build();

        return new InMemoryUserDetailsManager(admin, martin);
    }

    @Bean
    public RegisteredClientRepository registeredClientRepository() {
        RegisteredClient oidcClient = RegisteredClient.withId(UUID.randomUUID().toString())
                .clientId("gateway-app")
                .clientSecret("{noop}123456")
                .clientAuthenticationMethod(ClientAuthenticationMethod.CLIENT_SECRET_BASIC)
                .authorizationGrantType(AuthorizationGrantType.AUTHORIZATION_CODE)
                .authorizationGrantType(AuthorizationGrantType.REFRESH_TOKEN)
                .redirectUri("http://127.0.0.1:8090/authorized")
                .redirectUri("https://oauthdebugger.com/debug")
                .postLogoutRedirectUri("http://127.0.0.1:8090/logout")
                .scope(OidcScopes.OPENID)
                .scope(OidcScopes.PROFILE)
                .clientSettings(ClientSettings.builder().requireAuthorizationConsent(false).build())
                .build();

        return new InMemoryRegisteredClientRepository(oidcClient);
    }

    @Bean
    public JWKSource<SecurityContext> jwkSource() {
        KeyPair keyPair = generateRsaKey();
        RSAPublicKey publicKey = (RSAPublicKey) keyPair.getPublic();
        RSAPrivateKey privateKey = (RSAPrivateKey) keyPair.getPrivate();
        RSAKey rsaKey = new RSAKey.Builder(publicKey)
                .privateKey(privateKey)
                .keyID(UUID.randomUUID().toString())
                .build();
        JWKSet jwkSet = new JWKSet(rsaKey);
        return new ImmutableJWKSet<>(jwkSet);
    }

    private static KeyPair generateRsaKey() {
        KeyPair keyPair;
        try {
            KeyPairGenerator keyPairGenerator = KeyPairGenerator.getInstance("RSA");
            keyPairGenerator.initialize(2048);
            keyPair = keyPairGenerator.generateKeyPair();
        } catch (Exception ex) {
            throw new IllegalStateException(ex);
        }
        return keyPair;
    }

    @Bean
    public JwtDecoder jwtDecoder(JWKSource<SecurityContext> jwkSource) {
        return OAuth2AuthorizationServerConfiguration.jwtDecoder(jwkSource);
    }

    @Bean
    public AuthorizationServerSettings authorizationServerSettings() {
        return AuthorizationServerSettings.builder().issuer("http://127.0.0.1:9000").build();
    }

}
````

**D√≥nde**

1. `SecurityFilterChain authorizationServerSecurityFilterChain(...)`, este filtro es exclusivo para proteger los
   endpoints del `Authorization Server`, como `/oauth2/token`, `/oauth2/authorize`, etc.
    - Se usa `OAuth2AuthorizationServerConfigurer` para configurar los endpoints.
    - Se habilita `OIDC` con `.oidc(Customizer.withDefaults())`.
    - Redirige a `/login` si el usuario no est√° autenticado.
    - Se asegura que cualquier request a los endpoints est√© autenticada.


2. `SecurityFilterChain defaultSecurityFilterChain(...)`, este es el filtro para el resto de las rutas no manejadas por
   el `Authorzation Server`.
    - Simple: cualquier request requiere autenticaci√≥n.
    - Se activa `formLogin()` (pantalla de login por defecto de Spring Security).


3. `UserDetailsService `, estamos definiendo temporalmente usuarios que estar√°n almacenados en
   memoria. Estos usuarios ser√°n usuarios de prueba mientras desarrollamos el servidor de autorizaci√≥n. Recordemos que
   tenemos un `user-service`, precisamente ese servicio ser√° el que m√°s adelante usaremos para la gesti√≥n de los
   usuarios.


4. `RegisteredClientRepository`, definimos un `cliente OAuth2` registrado. Es el cliente que va a pedir autorizaci√≥n. En
   este `RegisteredClientRepository` vemos urls definidas, de las cuales:
    - `.redirectUri("http://127.0.0.1:8090/authorized")`, es una url personalizada que debemos crear, dado que el tutor
      del curso lo crea para poder recibir el c√≥digo de autorizaci√≥n. Sin embargo, en mi caso usar√© la url de
      `oauthdebugger.com` para obtener dicho c√≥digo de autorizaci√≥n.
    - `.redirectUri("https://oauthdebugger.com/debug")`, definimos esta p√°gina que nos ayudar√° a realizar el flujo para
      la obtenci√≥n del c√≥digo de autorizaci√≥n.
    - `.postLogoutRedirectUri("http://127.0.0.1:8090/logout")`, es una url personalizada que debemos crear.

   Adem√°s, colocamos en `false` el `requireAuthorizationConsent()` para que no pida el consentimiento de los scopes.


5. `JWKSource`, este bean genera un par de llaves `RSA (p√∫blica y privada)` para firmar `tokens JWT`. Luego, las
   convierte a formato `JWK` para que el `Authorization Server` pueda publicarlas en su endpoint
   `.well-known/jwks.json`.


6. `generateRsaKey()`, genera la llave `RSA` de `2048 bits`. Es puro Java b√°sico para criptograf√≠a.


7. `JwtDecoder`, `Spring Authorization Server` necesita un `JwtDecoder` para validar y decodificar los tokens que emite.
   Aqu√≠ lo construyes a partir del `JWKSource`.


8. `AuthorizationServerSettings`, en la configuraci√≥n del servidor de autorizaci√≥n, he agregado una personalizaci√≥n
   para establecer el `issuer URI` (el identificador del emisor del token). El `AuthorizationServerSettings` es un bean
   que define las configuraciones del servidor de autorizaci√≥n, y por defecto,
   `Spring Security OAuth2 Authorization Server` expone los endpoints est√°ndar como `/oauth2/authorize`,
   `/oauth2/token`, etc. En nuestro caso, he personalizado el `issuer URI`, que es un valor importante en el contexto de
   `JWT (JSON Web Tokens)`. El `issuer` es utilizado por los clientes para identificar la autoridad que ha emitido un
   token y es com√∫nmente parte de los metadatos de configuraci√≥n en un servidor de autorizaci√≥n.

Ahora, nos vamos al `gateway-server` y configuramos la ruta hacia nuestro servidor de autorizaci√≥n.

````yml
spring:
  application:
    name: gateway-server
  cloud:
    gateway:
      routes:
        - id: authorization-server-route
          uri: lb://authorization-server
          predicates:
            - Path=/api/v1/authorization-server/**
          filters:
            - RewritePath=/api/v1/authorization-server/(?<path>.*), /$\{path}
````

**D√≥nde**

- `uri: lb://authorization-server`, esto indica que la solicitud se enviar√° a un servicio llamado `authorization-server`
  registrado en `Eureka` (porque usamos `lb://`, es decir, `load balancer via discovery`). Debemos asegurarnos de que el
  `spring.application.name` del servidor de autorizaci√≥n lo hayamos definido como `authorization-server`
- `Path=/api/v1/authorization-server/**`, solo las rutas que empiecen con `/api/v1/authorization-server/` ser√°n
  redirigidas al `Authorization Server`.
- `RewritePath`, este filtro elimina el prefijo `/api/v1/authorization-server/` antes de enviar la solicitud al
  `Authorization Server`. Por ejemplo:
    - Petici√≥n del cliente: `GET /api/v1/authorization-server/oauth2/token`
    - Se reescribe como: `GET /oauth2/token` (que es lo que espera `Spring Authorization Server`)

## Implementando endpoint /authorized y /logout en Gateway Server

Recordemos que en el `SecurityConfig` del `authorization-server` creamos un bean `RegisteredClientRepository`. Dentro
de este bean definimos las siguientes uris que dijimos, deb√≠amos crear:

- http://127.0.0.1:8090/authorized
- http://127.0.0.1:8090/logout

Entonces, en este apartado implementaremos esas uris en nuestro `gateway-server`, dado que el puerto que definimos
es precisamente el puerto del `gateway-server`.

````java

@RestController
public class AppController {

    @GetMapping(path = "/authorized")
    public ResponseEntity<Map<String, String>> authorized(@RequestParam String code) {
        return ResponseEntity.ok(Collections.singletonMap("code", code));
    }

    @PostMapping(path = "/logout")
    public ResponseEntity<Map<String, String>> logout() {
        return ResponseEntity.ok(Collections.singletonMap("logout", "OK"));
    }
}
````

**Importante**

> Hemos agregado un controlador al `gateway-server` con dos uris `/authorized` y `/logout`. Pero recordemos que en el
> `application.yml` de este `gateway-server` tenemos definidas rutas de microservicios a las que `gateway` redirigir√°.
> La pregunta es `¬øqui√©n responde primero? ¬øSpring Cloud Gateway o Spring WebFlux (Spring Web MVC si fuera Servlet)?`
>
> `Spring Cloud Gateway` primero eval√∫a las rutas configuradas en el `application.yml` mediante el componente
> `RoutePredicateHandlerMapping`.
> - Si una ruta coincide, el `gateway` maneja la solicitud, es decir, la enruta al microservicio correspondiente, aplica
    filtros, etc.
> - Si ninguna ruta coincide, Spring WebFlux contin√∫a buscando coincidencias entre los `@RestController` definidos en el
    `Gateway` usando el `WebFluxHandlerMapping`.

## Configurando Resource Server y Cliente OAuth2 en yml

Nuestro `gateway-server` va a cumplir dos papeles:

1. Ser√° un `cliente OAuth2` del `authorization-server`, para iniciar el flujo de autenticaci√≥n del usuario (por ejemplo,
   mediante `spring-security-oauth2-client`). El usuario se podr√° loguear y obtener un `access token` que le permitir√°
   acceder a los distintos microservicios.


2. Tambi√©n actuar√° como un `resource server`, encargado de validar el `access token` incluido en las peticiones
   (generalmente mediante un encabezado `Authorization: Bearer <token>`). Para esto, utiliza la configuraci√≥n del
   `authorization-server` (como el `issuer-uri` o las `JWKs`) para validar que el token sea v√°lido y no haya expirado.
   Esto protege las rutas del gateway y evita que usuarios no autorizados accedan a los microservicios.

‚ö†Ô∏è Importante
> El `gateway` no tiene que llamar al `authorization server` en cada solicitud para validar el token. Es decir,
> no necesita preguntar al `authorization server` en cada solicitud si el token es v√°lido. Porque puede verificar la
> firma localmente usando la clave p√∫blica del `authorization server`. Es decir, usa una
> `clave p√∫blica (JWK)` publicada por el `authorization-server` para validar localmente la `firma del token JWT`. Esto
> es m√°s eficiente.
>
> El authorization server expone un endpoint JWK (JSON Web Key), normalmente accesible en una URL como:
> `http://localhost:9000/.well-known/jwks.json`
>
> Este endpoint contiene la(s) clave(s) p√∫blica(s) necesarias para que cualquier `resource server` pueda verificar
> las firmas de los `JWT` emitidos. Entonces el flow es as√≠:
>
> üîÅ Primera vez que el resource server recibe un token ‚Üí si no tiene la clave p√∫blica, consulta el endpoint JWK y la
> guarda en memoria (cach√©).
>
> üì¶ Despu√©s ‚Üí usa la clave en memoria para validar los siguientes tokens sin tener que llamar otra vez al `authorization
> server`.

As√≠ que iniciamos agregando las siguientes dependencias al `pom.xml` del `gateway-server`.

````xml

<dependencies>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-oauth2-client</artifactId>
    </dependency>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-oauth2-resource-server</artifactId>
    </dependency>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-security</artifactId>
    </dependency>
</dependencies>
````

Luego, vamos al `application.yml` del `gateway-server` para configurar nuestro servidor `gateway` como
`cliente de OAuth2` y como `servidor de recursos`.

````yml

spring:
  application:
    name: gateway-server
  security:
    oauth2:
      resourceserver:
        jwt:
          issuer-uri: http://127.0.0.1:9000
      client:
        registration:
          my-oauth2-client:
            provider: my-auth-server
            client-id: gateway-app
            client-secret: 123456
            authorization-grant-type: authorization_code
            redirect-uri: http://127.0.0.1:8090/authorized
            scope: openid, profile
        provider:
          my-auth-server:
            issuer-uri: http://127.0.0.1:9000
````

Las configuraciones anteriores muestran los dos papeles que estar√≠a cumpliendo nuestro `gateway-server`, veamos uno por
uno.

### 1. Como Resource Server

````yml
spring:
  security:
    oauth2:
      resourceserver:
        jwt:
          issuer-uri: http://127.0.0.1:9000
````

- Esto indica que el `gateway-server` usar√° `JWT` para validar tokens.
- Spring buscar√° autom√°ticamente el `JWK Set` en el endpoint `http://127.0.0.1:9000/.well-known/openid-configuration`.
- De ese endpoint obtendr√° el `jwks_uri`, por ejemplo `http://127.0.0.1:9000/oauth2/jwks`.
- `Spring` descargar√° la `clave p√∫blica` una sola vez y luego la `cachear√°` localmente para `validar los JWT` sin tener
  que llamar al `authorization server` en cada solicitud, justo como mencionamos antes.

### 2. Como OAuth2 Client

````yml
      client:
        registration:
          my-oauth2-client:
            provider: my-auth-server
            client-id: gateway-app
            client-secret: 123456
            authorization-grant-type: authorization_code
            redirect-uri: http://127.0.0.1:8090/authorized
            scope: openid, profile
        provider:
          my-auth-server:
            issuer-uri: http://127.0.0.1:9000
````

- Estamos registrando un cliente llamado `my-oauth2-client` que apunta al `authorization-server`.
- La propiedad `issuer-uri` es clave, ya que a partir de ah√≠ Spring podr√° autoconfigurar los endpoints necesarios
  `(/authorize, /token, etc.)`.
- No solo hemos configurado correctamente el `redirect-uri` de acuerdo con lo registrado en el `Authorization Server`
  (en la clase `SecurityConfig`), sino que adem√°s coinciden todos los valores clave del cliente: `client-id`,
  `client-secret`, `scopes` y el `authorization-grant-type`.

## Configurando clase Resource Server Security Endpoint

Ahora tenemos que implementar la clase `SecurityConfig` pero por el lado del `gateway-server` donde configuraremos la
protecci√≥n de las rutas, los endpoints, etc.

**Nota**
> Recordar que nuestro `gateway-server` est√° trabajando con `programaci√≥n reactiva`, por lo tanto la configuraci√≥n ser√°
> teniendo en cuenta ese detalle. Por ejemplo:
>
> En este caso usamos el `SecurityWebFilterChain` que se usa en `Spring WebFlux (Reactive stack)`, donde todo es
> reactivo.
>
> Si nuestro `gateway-server` fuera una aplicaci√≥n `Spring MVC (Servlet stack)`, como en aplicaciones cl√°sicas con
> Spring Boot, entonces usar√≠amos `SecurityFilterChain`.

A continuaci√≥n se muestra la configuraci√≥n inicial de nuestro `SecurityConfig`.

````java

@Configuration
public class SecurityConfig {

    @Bean
    public SecurityWebFilterChain securityWebFilterChain(ServerHttpSecurity http) {
        http
                .authorizeExchange(authorize -> authorize
                        .pathMatchers("/authorized", "/logout").permitAll()
                        .pathMatchers(HttpMethod.GET, "/api/v1/products", "/api/v1/items", "/api/v1/users").permitAll()
                        .pathMatchers(HttpMethod.GET, "/api/v1/products/{productId}", "/api/v1/items/{productId}", "/api/v1/users/{userId}", "/api/v1/users/username/{username}").hasAnyRole("ADMIN", "USER")
                        .pathMatchers("/api/v1/products/**", "/api/v1/items/**", "/api/v1/users/**").hasRole("ADMIN")
                        .anyExchange().authenticated()
                )
                .cors(ServerHttpSecurity.CorsSpec::disable)
                .securityContextRepository(NoOpServerSecurityContextRepository.getInstance())
                .oauth2Login(Customizer.withDefaults())
                .oauth2Client(Customizer.withDefaults())
                .oauth2ResourceServer(oauth2ResourceServer ->
                        oauth2ResourceServer.jwt(Customizer.withDefaults()));
        return http.build();
    }

}
````

1. Uso de `SecurityWebFilterChain`, esto es completamente correcto porque estamos usando `Spring WebFlux` (por eso es
   `SecurityWebFilterChain` y no `SecurityFilterChain` que es para `Spring MVC`).


2. Permitimos el acceso p√∫blico a endpoints espec√≠ficos:
    - `/authorized` y `/logout` ‚Üí acceso p√∫blico.
    - `GET` a `/api/v1/products`, `/items`, `/users` ‚Üí acceso p√∫blico.
    - `GET` a recursos individuales ‚Üí restringido a `ROLE_ADMIN` o `ROLE_USER`.
    - Otros m√©todos `(POST, PUT, DELETE, etc.)` a esos endpoints ‚Üí restringidos a `ROLE_ADMIN`.


3. Autenticaci√≥n `OAuth2`:
    - `oauth2Login()` y `oauth2Client()` ‚Üí esto permite que act√∫e como `cliente OAuth2`.
    - `oauth2ResourceServer()` ‚Üí protege las rutas con `tokens JWT`.


4. `CORS` deshabilitado (de momento), por ahora podemos mantenerlo deshabilitado si no tenemos frontend a√∫n. Pero cuando
   lo tengamos, asegurarnos de:
    - Habilitar CORS.
    - Especificar el origen del frontend (por ejemplo http://localhost:4200).
    - Probar llamadas desde el navegador para validar que no haya errores CORS.

5. `.securityContextRepository(NoOpServerSecurityContextRepository.getInstance())`, en aplicaciones reactivas con
   `Spring Security`, no se crean sesiones por defecto como s√≠ pasa con `Spring MVC`. Pero si queremos asegurarnos
   expl√≠citamente de que no se almacene nada en el `SecurityContext` de la sesi√≥n, podemos deshabilitarlo con esta
   configuraci√≥n. Entonces, esta configuraci√≥n le dice a Spring: *"No almacenes el contexto de seguridad en ning√∫n lado,
   ni en memoria ni en una sesi√≥n. Todo debe venir con cada petici√≥n (por ejemplo, en el JWT)."*

**Importante: ¬øQui√©n se ejecuta primero, el SecurityConfig o las rutas del gateway?**
> La seguridad se eval√∫a primero, antes de que el `RoutePredicateHandlerMapping` del `Gateway` intente hacer el
> enrutamiento.
>
> En otras palabras, cuando llega una petici√≥n al gateway, por ejemplo: `GET http://localhost:8090/api/v1/users/1`:
>
> 1. `Spring Security` (usando el `SecurityWebFilterChain`) intercepta la petici√≥n.
> 2. Eval√∫a los `pathMatchers()`:
> - En nuestro caso, `/api/v1/users/1` es una ruta protegida.
> - Seg√∫n la configuraci√≥n, necesita el rol `ADMIN` o `USER`.
> 3. Si el `token JWT` no est√° presente o no tiene el rol requerido, la petici√≥n es bloqueada ah√≠ mismo (con `401` o
     `403`), y nunca se intenta redirigir al microservicio `user-service`.
> 4. Si pasa la validaci√≥n de seguridad, entonces s√≠ se eval√∫a la configuraci√≥n de enrutamiento (`application.yml`) y la
     petici√≥n se reenv√≠a al microservicio correspondiente (usando `lb://user-service`).

**Conclusi√≥n**

> Primero eval√∫a lo configurado en el `SecurityConfig`, y solo si pasa, entonces se intenta hacer match con las rutas
> del `application.yml`.

## Probando implementaci√≥n del tipo de concesi√≥n de c√≥digo de autorizaci√≥n (Authorization Code Grant Type)

Vamos a ejecutar nuestros microservicios para ver que las configuraciones que hemos realizado hasta ahora est√©n
funcionando sin problemas. Como solo vamos a hacer pruebas, con el `user-service` ser√≠a suficiente, luego s√≠ es
necesario hacer uso del `discovery-server`, `authorization-server` y `gateway-server`.

Levantamos las aplicaciones en el siguiente orden.

- discovery-server
- authorization-server
- user-service
- gateway-server

Como tenemos levantado el `authorization-server` podemos ingresar a una ruta que este servidor nos proporciona como
parte de la especificaci√≥n de `OAuth 2.1 Authorization Server Metadata`. `Spring Authorization Server` la expone
autom√°ticamente si configuramos correctamente nuestro servidor de autorizaci√≥n.

````bash
http://127.0.0.1:9000/.well-known/oauth-authorization-server
````

Podemos observar que nos retorna un `JSON` con metadatos. Este documento permite a los `clientes OAuth` (como una app
`frontend` o `backend`) descubrir los endpoints del `servidor de autorizaci√≥n`.

![01.png](assets/section-10/01.png)

Del resultado anterior, utilizaremos los siguientes endpoints que nos permitir√° realizar el flujo del tipo de concesi√≥n
`authentication code`.

````bash
http://127.0.0.1:9000/oauth2/authorize
http://127.0.0.1:9000/oauth2/token
````

### Obteniendo c√≥digo de autorizaci√≥n

El primer paso para el tipo de concesi√≥n `Authorization code` es obtener un `c√≥digo` que luego lo intercambiaremos por
un `access token`. Entonces, para apoyarnos con el inicio de este flujo utilizaremos la siguiente web
`https://oauthdebugger.com/debug`.

A continuaci√≥n se muestra marcado en un cuadro rojo, los campos que se ingresaron manualmente. Adem√°s, es importante
notar que en el campo `Redirect URI (required)` estamos colocando la misma direcci√≥n de esta web
`https://oauthdebugger.com/debug` que es la misma que configuramos en el `SecurityConfig` del `authorization-server`.
Esto es relevante, porque cuando hagamos un `Send Request` la solicitud se enviar√° a
`http://127.0.0.1:9000/oauth2/authorize` (servidor de autorizaci√≥n) donde se generar√° el c√≥digo de autorizaci√≥n. Luego,
el servidor de autorizaci√≥n redireccionar√° a esta web el c√≥digo generado.

![02.png](assets/section-10/02.png)

Al hacer clic en `Send Request` y al ser la primera vez que hacemos la solicitud al `authorization-server`, nos pide
que nos autentiquemos. En este caso usamos una de las credenciales almacenadas en memoria dentro del servidor de
autorizaci√≥n.

![03.png](assets/section-10/03.png)

Luego de que la autenticaci√≥n sea exitosa, el servidor de autorizaci√≥n nos retornar√° el `Authorization Code` solicitado.

![04.png](assets/section-10/04.png)

### Obteniendo token de acceso

Ese c√≥digo de autorizaci√≥n lo utilizaremos para solicitar el `access token`.

````bash
$ curl -v -X POST -u gateway-app:123456 -d "grant_type=authorization_code&redirect_uri=https://oauthdebugger.com/debug&code=IoMHnjZoEG0K5zdWwUrW1BgDAPmdKGxtbg4eiusFRVf1TSJpMPZm1X3kzLfCN5xrcVS9jjxdjV-AonDqAh-6drejTw25wlqvkQjmVGuYcA7gqjSUXkjW19n-VprDm-1s" http://localhost:9000/oauth2/token | jq
>
< HTTP/1.1 200
< X-Content-Type-Options: nosniff
< X-XSS-Protection: 0
< Cache-Control: no-cache, no-store, max-age=0, must-revalidate
< Pragma: no-cache
< Expires: 0
< X-Frame-Options: DENY
< Content-Type: application/json;charset=UTF-8
< Transfer-Encoding: chunked
< Date: Mon, 21 Apr 2025 01:39:58 GMT
<
{
  "access_token": "eyJraWQiOiJmYmRhYWNjMC04ZjhkLTRmNDAtODVkYS1kZDU0MGY0OTdkMGQiLCJhbGciOiJSUzI1NiJ9.eyJzdWIiOiJhZG1pbiIsImF1ZCI6ImdhdGV3YXktYXBwIiwibmJmIjoxNzQ1MTk5NTk4LCJzY29wZSI6WyJvcGVuaWQiLCJwcm9maWxlIl0sImlzcyI6Imh0dHA6Ly8xMjcuMC4wLjE6OTAwMCIsImV4cCI6MTc0NTE5OTg5OCwiaWF0IjoxNzQ1MTk5NTk4LCJqdGkiOiJiMGZlMWIwZC0yODAxLTRmMzMtYWZiNi1lMDBmYTEwMWRkMGUifQ.Vq-I9fW5sGBQ_dfdPuNmyruZ96v9-KhUEjHtKdGrtzom8Fz_dQxE5hgUB6CCXREO8zH3arslvxvMRkSARpw4cN0Jz8DY7-s9-tCqcJ7RKhF8s0jcw_KlRcUAQ4X6qlbmZk52taxekF1emsNnq2yMqhQRBWJlZiJA0LMA7sLLHfRRbhNHJBBx7aM0eCJAs9Hy3_OuOGtX-0IfuqjFaaJOGsc1Q34C9Jt4zCtYIoVZ8O82jiNI9qmSxnNzCPWCGDOcs3-zPFYiUpWn64BqkJnhhvplI5RXaYeh9EYq-U66veEg-d5wt3c8ZQRWylOeEbNoWwwQtkYnUOnBbIH_xbEqog",
  "refresh_token": "dVcOL4LjKuFUF3j0SByescHRFjYtH9XOM3eDroiJR-JTtnFEreqW6CkzPqQM2xbcbd1FdzXMEtsr73qzKyxCqvYbnfwAGYJu-rX1uJcH3nQFG2rLDszJ1I7MsqgQZhoO",
  "scope": "openid profile",
  "id_token": "eyJraWQiOiJmYmRhYWNjMC04ZjhkLTRmNDAtODVkYS1kZDU0MGY0OTdkMGQiLCJhbGciOiJSUzI1NiJ9.eyJzdWIiOiJhZG1pbiIsImF1ZCI6ImdhdGV3YXktYXBwIiwiYXpwIjoiZ2F0ZXdheS1hcHAiLCJhdXRoX3RpbWUiOjE3NDUxOTk1NzcsImlzcyI6Imh0dHA6Ly8xMjcuMC4wLjE6OTAwMCIsImV4cCI6MTc0NTIwMTM5OCwiaWF0IjoxNzQ1MTk5NTk4LCJub25jZSI6Imsxa2k1OGVtYWFmIiwianRpIjoiZTM5NGMwMDAtNzZkOC00ZTBiLWE2ODMtNjNjNGQyZjI1ZjE1Iiwic2lkIjoiNWV1Ym51THVvbHlMbWRTM0ZIeHBuZHNyXzJ0Nmw1UFdxb1FfeWY5Y01HcyJ9.LM4heL-I2mR8KF_2nFX-eGs2utgT9p7hJ0Dtld3vaH2mCQgRiEEBSZFYyPz0pU7D1Vz68M6m5wPKCs7F009D48_s8N7v805YC-q_s3TzDbvANesxLAxrU8eM9PrQp3akLo3PzikoDSB9UT70aEXbVj4rj22u0pXbDqabrmuvKoRipvcd5RcSqWGVWZFACm4t-deE7RRtee3A8trZVWbnp_7XNcaFIbFXY2CYcybsZnjPkMoQuk9Emvx72GrOZqT3zgC1jbY4ZVGOrjPxbDhBXe5VH9NF5gMLNA0To10SxNSSI9uZtOTYs7qZQJ7LvgqVWCGbSCpfu8HD2Z1uMH652w",
  "token_type": "Bearer",
  "expires_in": 300
}
````

Si decodificamos el `access token` podemos observar que se corresponde con el usuario con el que iniciamos sesi√≥n.

![05.png](assets/section-10/05.png)

Si quisi√©ramos obtener un `access token` para otro usuario, debemos cerrar sesi√≥n ingresando a la siguiente url
`http://127.0.0.1:9000/logout`. Como vemos nos aparece el mensaje `se ha cerrado la sesi√≥n`, ahora s√≠ podemos volver a
iniciar sesi√≥n con otro usuario.

![06.png](assets/section-10/06.png)

## Autorizaci√≥n basada en Scopes en Spring Security con OAuth2

En una arquitectura basada en microservicios, el uso de `OAuth2` como mecanismo de autenticaci√≥n y autorizaci√≥n es una
pr√°ctica com√∫n. Dentro de este contexto, los `scopes` permiten definir granularmente qu√© recursos o acciones puede
acceder un cliente autenticado. En este apartado explicamos c√≥mo usar `scopes` como autoridades (`SCOPE_x`) en
`Spring Security` dentro de un `gateway reactivo`, siguiendo una implementaci√≥n real con un servidor de autorizaci√≥n
personalizado.

### ¬øQu√© son los scopes?

Un `scope` en `OAuth2` representa un nivel de acceso o un permiso que una aplicaci√≥n cliente puede solicitar durante el
proceso de autorizaci√≥n. Por ejemplo:

1. `Scopes est√°ndar (OpenID Connect)`
    - `openid`, este scope es obligatorio para indicar que la aplicaci√≥n cliente desea autenticarse mediante
      `OpenID Connect`. Su inclusi√≥n permite que se genere un `ID Token`, que contiene informaci√≥n del usuario
      autenticado.
    - `profile`, permite acceder a informaci√≥n b√°sica del perfil del usuario, como name, email, preferred_username, etc.
      Esto depende de c√≥mo configuremos el servidor de autorizaci√≥n y qu√© claims se devuelvan.

   > Estos scopes est√°n definidos por el est√°ndar OpenID Connect y no deben ser modificados.

2. `Scopes personalizados`
    - `write`, define que el cliente tiene permisos para crear, actualizar o eliminar recursos.
    - `read`, permite al cliente consultar o leer recursos protegidos.

   > Estos scopes no est√°n definidos por el est√°ndar y los creamos nosotros seg√∫n las necesidades de nuestra aplicaci√≥n.
   > En este caso, se usan para controlar el acceso a endpoints del gateway con `hasAuthority("SCOPE_write")` o
   > `hasAuthority("SCOPE_read")`.

### ¬øDe d√≥nde sale el prefijo SCOPE_?

Cuando se utiliza `Spring Security` con un `Resource Server JWT`, los scopes incluidos en el token se mapean
autom√°ticamente como autoridades con el prefijo `SCOPE_`.

`Ejemplo`: Si el token JWT contiene:
> "scope": ["read", "write"]

`Spring Security` los convierte en autoridades:
> SCOPE_read, SCOPE_write

Este comportamiento es interno de `Spring Security` cuando se configura como `oauth2ResourceServer().jwt()`. No
necesitamos hacerlo manualmente.

### [Authorization Server] Modificando nuestro proyecto para trabajar con SCOPE_

En la clase `SecurityConfig` del `authorization-server` vamos a agregar nuestros scopes personalizados `write` y `read`.
Estos scopes estar√°n en el bean `RegisteredClientRepository`, exactamente definidos en el `RegisteredClient` para el
cliente `gateway-app`. Esto indica que el cliente (`gateway-app`) puede solicitar esos permisos.

````java

@Configuration
public class SecurityConfig {

    /* code */

    @Bean
    public RegisteredClientRepository registeredClientRepository() {
        RegisteredClient oidcClient = RegisteredClient.withId(UUID.randomUUID().toString())
                .clientId("gateway-app")
                .clientSecret("{noop}123456")
                .clientAuthenticationMethod(ClientAuthenticationMethod.CLIENT_SECRET_BASIC)
                .authorizationGrantType(AuthorizationGrantType.AUTHORIZATION_CODE)
                .authorizationGrantType(AuthorizationGrantType.REFRESH_TOKEN)
                .redirectUri("http://127.0.0.1:8090/authorized")
                .redirectUri("https://oauthdebugger.com/debug")
                .postLogoutRedirectUri("http://127.0.0.1:8090/logout")
                .scope(OidcScopes.OPENID)
                .scope(OidcScopes.PROFILE)
                .scope("write")
                .scope("read")
                .clientSettings(ClientSettings.builder().requireAuthorizationConsent(false).build())
                .build();

        return new InMemoryRegisteredClientRepository(oidcClient);
    }

    /* code */
}
````

### [Gateway Server] Modificando nuestro proyecto para trabajar con SCOPE_

En el `application.yml` del `gateway-server` tenemos definido los datos del cliente que est√° registrado en el servidor
de autorizaci√≥n, por lo que debemos agregar los dos scopes personalizados que definimos (`write` y `read`).
Esto permitir√° que, al autenticarnos desde el navegador, el token incluya los scopes `read` y `write`.

````yml
spring:
  application:
    name: gateway-server
  security:
    oauth2:
      resourceserver:
        jwt:
          issuer-uri: http://127.0.0.1:9000
      client:
        registration:
          my-oauth2-client:
            provider: my-auth-server
            client-id: gateway-app
            client-secret: 123456
            authorization-grant-type: authorization_code
            redirect-uri: http://127.0.0.1:8090/authorized
            scope: openid, profile, write, read
        provider:
          my-auth-server:
            issuer-uri: http://127.0.0.1:9000
````

As√≠ mismo, en el `SecurityConfig` del `gateway-server` vamos a modificar los permisos asignados a los endpoints, por lo
que reemplazaremos el uso de `hasRole` / `hasAnyRole` por `hasAuthority` / `hasAnyAuthority` con el prefijo `SCOPE_`, ya
que ahora el control se basa en `scopes` del `token JWT`:

````java

@Configuration
public class SecurityConfig {

    @Bean
    public SecurityWebFilterChain securityWebFilterChain(ServerHttpSecurity http) {
        http
                .authorizeExchange(authorize -> authorize
                        .pathMatchers("/authorized", "/logout").permitAll()
                        .pathMatchers(HttpMethod.GET, "/api/v1/products", "/api/v1/items", "/api/v1/users").permitAll()
                        .pathMatchers(HttpMethod.GET, "/api/v1/products/{productId}", "/api/v1/items/{productId}", "/api/v1/users/{userId}", "/api/v1/users/username/{username}").hasAnyAuthority("SCOPE_write", "SCOPE_read")
                        .pathMatchers("/api/v1/products/**", "/api/v1/items/**", "/api/v1/users/**").hasAuthority("SCOPE_write")
                        .anyExchange().authenticated()
                )
                .cors(ServerHttpSecurity.CorsSpec::disable)
                .securityContextRepository(NoOpServerSecurityContextRepository.getInstance())
                .oauth2Login(Customizer.withDefaults())
                .oauth2Client(Customizer.withDefaults())
                .oauth2ResourceServer(oauth2ResourceServer ->
                        oauth2ResourceServer.jwt(Customizer.withDefaults()));
        return http.build();
    }

}
````

Esto permite que:

- Usuarios con token que tenga `scope: read` puedan acceder a consultas.
- Solo usuarios con `scope: write` puedan realizar modificaciones.

## Probando la autorizaci√≥n basada en Scopes

Levantamos las aplicaciones en el siguiente orden.

- discovery-server
- authorization-server
- user-service
- gateway-server

Ahora, realizamos el mismo flujo que hicimos para obtener un c√≥digo de autorizaci√≥n. Teniendo en cuenta que debemos
agregar los scopes personalizados tal como se muestra en la imagen.

![07.png](assets/section-10/07.png)

Con el c√≥digo de autorizaci√≥n solicitamos un `access token`.

````bash
$ curl -v -X POST -u gateway-app:123456 -d "grant_type=authorization_code&redirect_uri=https://oauthdebugger.com/debug&code=GxHdtiGaDFQ8eH_TmAXKAyYNAyoMYTLk7dKdIVDEvO8Uw6qz1UQ8-_cqBT7zJnNvgljWbYhuZoG_aTgWH4XiWlRhcJ7a2FZ1VmchBdpHqT7kf2MSsUJGZzDgROUf9b-n" http://localhost:9000/oauth2/token | jq
>
< HTTP/1.1 200
< X-Content-Type-Options: nosniff
< X-XSS-Protection: 0
< Cache-Control: no-cache, no-store, max-age=0, must-revalidate
< Pragma: no-cache
< Expires: 0
< X-Frame-Options: DENY
< Content-Type: application/json;charset=UTF-8
< Transfer-Encoding: chunked
< Date: Mon, 21 Apr 2025 01:59:18 GMT
<
{
  "access_token": "eyJraWQiOiJiZWVhYzg1Yy0zZjZjLTRhMTAtOTBlYy01ZjRmNDZjZDZmNjAiLCJhbGciOiJSUzI1NiJ9.eyJzdWIiOiJhZG1pbiIsImF1ZCI6ImdhdGV3YXktYXBwIiwibmJmIjoxNzQ1MjAwNzU4LCJzY29wZSI6WyJyZWFkIiwib3BlbmlkIiwicHJvZmlsZSIsIndyaXRlIl0sImlzcyI6Imh0dHA6Ly8xMjcuMC4wLjE6OTAwMCIsImV4cCI6MTc0NTIwMTA1OCwiaWF0IjoxNzQ1MjAwNzU4LCJqdGkiOiIyYWQyMWZjZi02NDFiLTQ4MzctYjlhZi1iMWMzY2JkN2IyZGMifQ.fiZLnzC0pTEQkc0BGiuyS1TQFeE44SgTI8On6wT5Xbw0ds8IA1z4t62vEVFJq3NMLnHrAKKvCfW-jFGVB0GGWH8RzfKlxZwPFknCNBT5QLTFJO_PBG1Dt-06DMvQPkC2qvTk23AlsfArANlp1z-_UYHzAzHlwMXZx9id31XPeL53KxVvL1sVtMzurnK2xoZEZC8smHkhXpASjwsDDseRUrti1CK0m1WhiVbFsp3aaUAXIUt4dGJ1XBHo-LiYuHOo76DSdPd99VBg3QOPLMmvQBfEuNXHhuwPQYYvdU5q2oT-ZgMs8MAVqMH66QSkgPWiuOSIlyScQeWDoMPj0rAuDA",
  "refresh_token": "uCKo3LyxYXLnQQPBWxumICITfBb5VZxCRph4mrwvHJjFW3VjBEhQpT8HUFx7Ww6lDA4mSPA0S8IXWe-07OUGu2cnGxot-JU8DaQqJwHY1QgmXb_rmRlt5_a5HKusZMza",
  "scope": "read openid profile write",
  "id_token": "eyJraWQiOiJiZWVhYzg1Yy0zZjZjLTRhMTAtOTBlYy01ZjRmNDZjZDZmNjAiLCJhbGciOiJSUzI1NiJ9.eyJzdWIiOiJhZG1pbiIsImF1ZCI6ImdhdGV3YXktYXBwIiwiYXpwIjoiZ2F0ZXdheS1hcHAiLCJhdXRoX3RpbWUiOjE3NDUyMDA3NTIsImlzcyI6Imh0dHA6Ly8xMjcuMC4wLjE6OTAwMCIsImV4cCI6MTc0NTIwMjU1OCwiaWF0IjoxNzQ1MjAwNzU4LCJub25jZSI6ImRuajZramVjbThoIiwianRpIjoiZWYxM2ExOWMtMzk0YS00OGZmLWFjNDMtYjYzZDg4NDQyNTYxIiwic2lkIjoiTV9hbzhvczFYN0F5akgzTGRTN1cyOWlmLUVnLU10T04tSHE0NVBtLW5iRSJ9.ejJAVw_HzzxVXaU5HM2Dt3sSVG-O9ZhoXnG0hf2Y0QNqKOtwiSgOTGkC4VwZjUrgq8rdQRKx2_5NXLzVdn4Bevxj2oBgFLeefvIasmcM0aSsQhTdoaeWm_NyHWFeO8fYAZu1oNjvmTiVMX7uFGEv7_qVImn9tcyUKv4Phr3ziY43uFwaePRrcgVIIK8zK4PdURNnrnIiQKxv0SFHmZvV2shPQjj4nY9dwGeDP1nnt0cD9M_Ua6lMiA5JFhpl4qI-MrGhpePDbNQptd3bOqoFmFf2aaHsYmc3-PXp6qW0FXiCe93CVrovCQEsQDXT3q9c0KugTXxlqixe15OukQxntg",
  "token_type": "Bearer",
  "expires_in": 300
}
````

Si decodificamos el `access token`, vemos que nuestros scopes personalizados fueron agregados.

![08.png](assets/section-10/08.png)

Ahora, realizamos una petici√≥n a un endpoint protegido por el `SCOPE_write` envi√°ndole el `access token` en las
cabeceras.

````bash
$ curl -v -H "Authorization: Bearer eyJraWQiOiJiZWVhYzg1Yy0zZjZjLTRhMTAtOTBlYy01ZjRmNDZjZDZmNjAiLCJhbGciOiJSUzI1NiJ9.eyJzdWIiOiJhZG1pbiIsImF1ZCI6ImdhdGV3YXktYXBwIiwibmJmIjoxNzQ1MjAwNzU4LCJzY29wZSI6WyJyZWFkIiwib3BlbmlkIiwicHJvZmlsZSIsIndyaXRlIl0sImlzcyI6Imh0dHA6Ly8xMjcuMC4wLjE6OTAwMCIsImV4cCI6MTc0NTIwMTA1OCwiaWF0IjoxNzQ1MjAwNzU4LCJqdGkiOiIyYWQyMWZjZi02NDFiLTQ4MzctYjlhZi1iMWMzY2JkN2IyZGMifQ.fiZLnzC0pTEQkc0BGiuyS1TQFeE44SgTI8On6wT5Xbw0ds8IA1z4t62vEVFJq3NMLnHrAKKvCfW-jFGVB0GGWH8RzfKlxZwPFknCNBT5QLTFJO_PBG1Dt-06DMvQPkC2qvTk23AlsfArANlp1z-_UYHzAzHlwMXZx9id31XPeL53KxVvL1sVtMzurnK2xoZEZC8smHkhXpASjwsDDseRUrti1CK0m1WhiVbFsp3aaUAXIUt4dGJ1XBHo-LiYuHOo76DSdPd99VBg3QOPLMmvQBfEuNXHhuwPQYYvdU5q2oT-ZgMs8MAVqMH66QSkgPWiuOSIlyScQeWDoMPj0rAuDA" http://localhost:8090/api/v1/users/1 | jq
>
< HTTP/1.1 200 OK
< transfer-encoding: chunked
< Content-Type: application/json
< Date: Mon, 21 Apr 2025 02:01:01 GMT
< token-response: 123456
< Cache-Control: no-cache, no-store, max-age=0, must-revalidate
< Pragma: no-cache
< Expires: 0
< X-Content-Type-Options: nosniff
< X-Frame-Options: DENY
< X-XSS-Protection: 0
< Referrer-Policy: no-referrer
< set-cookie: color=red
<
{
  "id": 1,
  "username": "admin",
  "enabled": true,
  "email": "admin@gmail.com",
  "roles": [
    {
      "id": 2,
      "name": "ROLE_USER"
    },
    {
      "id": 1,
      "name": "ROLE_ADMIN"
    }
  ]
}
````

## Eliminando scopes personalizados

En el apartado anterior *Autorizaci√≥n basada en Scopes en Spring Security con OAuth2* realizamos algunos cambios para
trabajar con el `SCOPE_`, pero ese apartado fue solo para ver c√≥mo trabajar con `scopes`. Ahora, en los siguientes
apartados continuaremos trabajando con roles, pero para eso dejaremos limpio los cambios que realizamos anteriormente.

En primer lugar, en el `SecurityConfig` del `authorization-server` vamos a quitar los scopes personalizados que
agregamos dejando √∫nicamente los scopes que vienen por defecto `openid` y `profile`.

````java

@Configuration
public class SecurityConfig {
    /* code */
    @Bean
    public RegisteredClientRepository registeredClientRepository() {
        RegisteredClient oidcClient = RegisteredClient.withId(UUID.randomUUID().toString())
                .clientId("gateway-app")
                .clientSecret("{noop}123456")
                .clientAuthenticationMethod(ClientAuthenticationMethod.CLIENT_SECRET_BASIC)
                .authorizationGrantType(AuthorizationGrantType.AUTHORIZATION_CODE)
                .authorizationGrantType(AuthorizationGrantType.REFRESH_TOKEN)
                .redirectUri("http://127.0.0.1:8090/authorized")
                .redirectUri("https://oauthdebugger.com/debug")
                .postLogoutRedirectUri("http://127.0.0.1:8090/logout")
                .scope(OidcScopes.OPENID)
                .scope(OidcScopes.PROFILE)
                .clientSettings(ClientSettings.builder().requireAuthorizationConsent(false).build())
                .build();

        return new InMemoryRegisteredClientRepository(oidcClient);
    }
    /* code */
}
````

Luego, en el `application.yml` del `gateway-server` haremos lo mismo.

````yml
spring:
  application:
    name: gateway-server
  security:
    oauth2:
      resourceserver:
        jwt:
          issuer-uri: http://127.0.0.1:9000
      client:
        registration:
          my-oauth2-client:
            provider: my-auth-server
            client-id: gateway-app
            client-secret: 123456
            authorization-grant-type: authorization_code
            redirect-uri: http://127.0.0.1:8090/authorized
            scope: openid, profile
        provider:
          my-auth-server:
            issuer-uri: http://127.0.0.1:9000
````

## Registrando los claims roles al JWT

En este apartado implementaremos los `roles` en `Spring Security`, los cuales utilizan el prefijo `ROLE_`. Recordemos
que en los apartados anteriores trabajamos con los scopes (`SCOPE_`) del servidor de autorizaci√≥n, los cuales est√°n m√°s
orientados al `cliente OAuth`, en nuestro caso al `client-id: gateway-app`. En cambio, los roles (`ROLE_`) est√°n m√°s
relacionados con los permisos asignados a los usuarios, definiendo qu√© recursos pueden acceder seg√∫n su rol dentro
del sistema.

Como primer paso, realizaremos una modificaci√≥n en el `SecurityConfig` del `authorization-server`. En esta
etapa, personalizamos el `JWT` emitido por el `Authorization Server` para incluir los `roles del usuario` como `claims`
personalizados. Esto nos permitir√° luego usar `hasRole("...")` o `hasAnyRole("...")` en el `Gateway Server`
para aplicar reglas de seguridad basadas en `roles`, no solo en scopes.

Entonces, como cambio, agregamos el siguiente `@Bean` en la clase `SecurityConfig` del `Authorization Server`:

````java

@Configuration
public class SecurityConfig {

    /* code */

    @Bean
    public OAuth2TokenCustomizer<JwtEncodingContext> tokenCustomizer() {
        return context -> {
            Authentication principal = context.getPrincipal();
            Set<String> roles = principal.getAuthorities().stream()
                    .map(GrantedAuthority::getAuthority)
                    .collect(Collectors.toSet());

            if (context.getTokenType().getValue().equals("access_token")) {
                context.getClaims()
                        .claim("roles", roles)
                        .claim("token_type", "Access Token")
                        .build();
            }

            if (context.getTokenType().getValue().equals("id_token")) {
                context.getClaims()
                        .claim("roles", roles)
                        .claim("token_type", "Id Token")
                        .build();
            }
        };
    }

}
````

### ¬øQu√© hace este bean?

- Este `OAuth2TokenCustomizer<JwtEncodingContext>` permite modificar el contenido del `JWT` antes de que se firme y
  entregue al cliente.
- Extrae los roles del usuario autenticado (`GrantedAuthority`) y los inserta como un claim llamado `roles` en el
  `access_token` y el `id_token`.
- Tambi√©n agrega un `claim adicional` llamado `token_type` solo con fines informativos.

### Resultado

Una vez emitido el token, el `payload` de por ejemplo el `access_token` incluir√≠a algo as√≠.

````json
{
  "sub": "admin",
  "roles": [
    "ROLE_ADMIN",
    "ROLE_USER"
  ],
  "token_type": "Access Token"
}
````

Como segundo paso, en el `SecurityConfig` del `gateway-server` realizamos modificaciones al `SecurityWebFilterChain`.
Este cambio es clave para que el `Gateway Server` pueda interpretar correctamente los `roles` enviados en el `JWT`, y
as√≠ aplicar seguridad con `hasRole(...)` / `hasAnyRole(...)`.

Luego de haber agregado el `claim "roles"` en el `JWT` desde el `Authorization Server`, ahora debemos configurar el
`Gateway Server` para:

1. Leer ese claim `roles` del `JWT` recibido.
2. Convertir cada rol en una `GrantedAuthority` v√°lida.
3. Usar `hasRole(...)` o `hasAnyRole(...)` en la configuraci√≥n de seguridad.

En el `SecurityConfig` del `Gateway Server`, personalizamos el comportamiento del `JwtAuthenticationConverter` dentro
del `oauth2ResourceServer`.

````java

@Configuration
public class SecurityConfig {

    @Bean
    public SecurityWebFilterChain securityWebFilterChain(ServerHttpSecurity http) {
        http
                .authorizeExchange(authorize -> authorize
                        .pathMatchers("/authorized", "/logout").permitAll()
                        .pathMatchers(HttpMethod.GET, "/api/v1/products", "/api/v1/items", "/api/v1/users").permitAll()
                        .pathMatchers(HttpMethod.GET, "/api/v1/products/{productId}", "/api/v1/items/{productId}", "/api/v1/users/{userId}", "/api/v1/users/username/{username}").hasAnyRole("ADMIN", "USER")
                        .pathMatchers("/api/v1/products/**", "/api/v1/items/**", "/api/v1/users/**").hasRole("ADMIN")
                        .anyExchange().authenticated()
                )
                .cors(ServerHttpSecurity.CorsSpec::disable)
                .securityContextRepository(NoOpServerSecurityContextRepository.getInstance())
                .oauth2Login(Customizer.withDefaults())
                .oauth2Client(Customizer.withDefaults())
                .oauth2ResourceServer(oauth2ResourceServer ->
                        oauth2ResourceServer.jwt(jwt -> {
                            jwt.jwtAuthenticationConverter(source -> {
                                Collection<String> roles = source.getClaimAsStringList("roles");

                                Collection<GrantedAuthority> authorities = roles.stream()
                                        .map(SimpleGrantedAuthority::new)
                                        .collect(Collectors.toSet());

                                return Mono.just(new JwtAuthenticationToken(source, authorities));
                            });
                        }));
        return http.build();
    }

}
````

Lo que hace esta modificaci√≥n es:

- Lee el claim `roles` que viene en el JWT (por ejemplo: `["ROLE_USER", "ROLE_ADMIN"]`).
- Convierte cada rol en una `SimpleGrantedAuthority`.
- Asocia esas autoridades al `JwtAuthenticationToken` para que puedan ser usadas con `hasRole(...)` o `hasAnyRole(...)`.

Ahora, gracias a esa conversi√≥n de roles, se puede proteger rutas usando `hasRole` y `hasAnyRole`, tal como lo hicimos
anteriormente.

````bash
.pathMatchers(HttpMethod.GET, "/api/v1/products/{productId}", ...).hasAnyRole("ADMIN", "USER")
.pathMatchers("/api/v1/products/**", ...).hasRole("ADMIN")
````

> `‚ö†Ô∏è Importante`: No es necesario anteponer `ROLE_` en el `hasRole(...)`, ya que `Spring Security` internamente lo
> a√±ade. Por ejemplo, `hasRole("ADMIN")` busca la autoridad `ROLE_ADMIN`.

### ¬øQu√© pasar√≠a si no personalizamos el `jwtAuthenticationConverter` en el `Gateway Server`?

Aunque el `Authorization Server` agregue correctamente el claim `roles` al `token JWT`, `Spring Security` no sabr√° c√≥mo
interpretar ese claim a menos que t√∫ se lo indiques expl√≠citamente.

Por defecto:

- `Spring Security` espera que las autoridades (roles o scopes) vengan en el `claim "scope"` (como `SCOPE_read`,
  `SCOPE_write`), o en `authorities` si es una aplicaci√≥n personalizada.
- No analiza autom√°ticamente un claim llamado "roles" a menos que lo configures.

üî¥ Sin el `jwtAuthenticationConverter` personalizado:

- El Gateway no extraer√° los roles desde el claim `roles`.
- El `Authentication` generado no tendr√° ninguna `GrantedAuthority` como `ROLE_ADMIN` o `ROLE_USER`.
- Como consecuencia, todas las rutas que dependan de `.hasRole(...)` o `.hasAnyRole(...)` fallar√°n con un
  `403 Forbidden`, incluso si el token tiene correctamente el claim `roles`.

üü¢ Con el `jwtAuthenticationConverter` personalizado:

- Se extraen los valores del claim `roles` y se convierten en `GrantedAuthority` (por ejemplo, `ROLE_ADMIN`).
- Entonces, las verificaciones con `.hasRole("ADMIN")` funcionan correctamente.

## Probando roles en jwt

Levantamos las aplicaciones en el siguiente orden.

- discovery-server
- authorization-server
- user-service
- gateway-server

Ahora, realizamos el mismo flujo que hicimos para obtener un c√≥digo de autorizaci√≥n utilizando la p√°gina
[OAuth 2.0 Debugger](https://oauthdebugger.com/debug). Teniendo en cuenta que los scopes volver√°n a ser √∫nicamente
`openid` y `profile`.

![09.png](assets/section-10/09.png)

Con el c√≥digo de autorizaci√≥n obtenido, realizamos una petici√≥n para obtener el `access token`. Es importante precisar
que al momento de obtener el c√≥digo de autorizaci√≥n nos logueamos con el usuario `ADMIN`.

````bash
$ curl -v -X POST -u gateway-app:123456 -d "grant_type=authorization_code&redirect_uri=https://oauthdebugger.com/debug&code=xv6kAg_WgHiATsJ5LDHnnAzLp8ExLUOfMBck1kXOOTqydp52c94qCyUYOCBCyAzioF_AqxXfju48RGCiJzYk0JCHrkZnxoRtKykTl4sPsJgmhh3tc0-a9t4zcj8DVCs1" http://localhost:9000/oauth2/token | jq
>
< HTTP/1.1 200
< X-Content-Type-Options: nosniff
< X-XSS-Protection: 0
< Cache-Control: no-cache, no-store, max-age=0, must-revalidate
< Pragma: no-cache
< Expires: 0
< X-Frame-Options: DENY
< Content-Type: application/json;charset=UTF-8
< Transfer-Encoding: chunked
< Date: Mon, 21 Apr 2025 16:33:56 GMT
<
{
  "access_token": "eyJraWQiOiJjZWIxNDNjOS03OTJhLTRkMTctOTI3OC04MGM0ZDY0MjVhNWIiLCJhbGciOiJSUzI1NiJ9.eyJzdWIiOiJhZG1pbiIsImF1ZCI6ImdhdGV3YXktYXBwIiwibmJmIjoxNzQ1MjUzMjM2LCJzY29wZSI6WyJvcGVuaWQiLCJwcm9maWxlIl0sInJvbGVzIjpbIlJPTEVfVVNFUiIsIlJPTEVfQURNSU4iXSwiaXNzIjoiaHR0cDovLzEyNy4wLjAuMTo5MDAwIiwiZXhwIjoxNzQ1MjUzNTM2LCJ0b2tlbl90eXBlIjoiQWNjZXNzIFRva2VuIiwiaWF0IjoxNzQ1MjUzMjM2LCJqdGkiOiJlZWRmNDA4Ny03YWU2LTQyMGYtYWI0NS0yNDM1NDFiZmJlN2QifQ.GIIiXrdRDv9yATtlygoZGK_-6CGat-LAxx58lrehUpRX7OtllVxFy1iORkKPHypDTc81fs-unB4lSiafsxT8rT2KfBg_JQ5Hk7pCcHKd5scC0wx88VAVjzv66yNYpGGNVu9OySDdjTJ9ATjm-pplnRFq9Ay6qk7mb8cpw9LPHYymAJPawjXO5bcaHvaIhm6CLyFnnTHKvknd9wW5ZIh_YOTEg62oCokkRXepoCuIrw_QG2XBqfEoDFYOKx_isxKD0URCoOJsI57qUK-vyOBPUKdqPshscT-MjJkeEh_QyIPFmzhA75wnfEeK5OhcZ8JNVgy6dDRQ_FVkpOWqhg89Pg",
  "refresh_token": "EpfBqhhi_jFpbQI_sIQjqrHuKUBMiVGSYSJ3dtiQmkdjyfk-Ua4mMuWZH8_YYnXJvyDHZFMFISTuFGHT3_DThBmK9aWFFUlDOEp104GHoQGEgTn1rKmxyhJ5XhEI4K6H",
  "scope": "openid profile",
  "id_token": "eyJraWQiOiJjZWIxNDNjOS03OTJhLTRkMTctOTI3OC04MGM0ZDY0MjVhNWIiLCJhbGciOiJSUzI1NiJ9.eyJzdWIiOiJhZG1pbiIsImF1ZCI6ImdhdGV3YXktYXBwIiwiYXpwIjoiZ2F0ZXdheS1hcHAiLCJhdXRoX3RpbWUiOjE3NDUyNTMyMzIsInJvbGVzIjpbIlJPTEVfVVNFUiIsIlJPTEVfQURNSU4iXSwiaXNzIjoiaHR0cDovLzEyNy4wLjAuMTo5MDAwIiwiZXhwIjoxNzQ1MjU1MDM2LCJ0b2tlbl90eXBlIjoiSWQgVG9rZW4iLCJpYXQiOjE3NDUyNTMyMzYsIm5vbmNlIjoia2YwMG02bzI0eGEiLCJqdGkiOiJmZTlmMmY4Mi1lOGRhLTQ1YzMtYTkxYi0wOTUzMzg0MmZlMmUiLCJzaWQiOiI2NFF2TnMtbGJIQlhjTFl6N0VMcmNGZ1U3MWp6OF9ldi15UENFbzFYOTU4In0.B4nOOKMX__DkFx-rHoUnIBSS2roU6UTdA_qaHzhlBkRgmaaMGzblRCvrN72c_qQeXCMLH0IcJUGlnXoss-LjPhMkp-gqZLL4esFnDYQUgBuy4KYXMLdZ6qgm_FZPu8G1OCU55GSZPMVGoEyaUivO1I8EGA9nBnjuFNIrOYO0GeX_PLx9NQsZjsP5TPoZgQZ734ZxqOCQNI6TUPyCZNlHUNWaT9Zv9ZDwf5BNeyt264jnaIIWkbNm1dipukMoIpsc0kvF__YQ8ahaI-zBn4Fg8NBkje1wUxntbakGJuaX2-8p3rGQLPInSEzav_w04Um9_5smcL2StQC-PrgWKxFW0A",
  "token_type": "Bearer",
  "expires_in": 300
}
````

Si decodificamos el `access_token` podemos ver que nuestros roles se han agregado correctamente.

![10.png](assets/section-10/10.png)

Con el access token podemos realizar una petici√≥n a uno de nuestros endpoints protegidos.

````bash
$ curl -v -H "Authorization: Bearer eyJraWQiOiJjZWIxNDNjOS03OTJhLTRkMTctOTI3OC04MGM0ZDY0MjVhNWIiLCJhbGciOiJSUzI1NiJ9.eyJzdWIiOiJhZG1pbiIsImF1ZCI6ImdhdGV3YXktYXBwIiwibmJmIjoxNzQ1MjUzMjM2LCJzY29wZSI6WyJvcGVuaWQiLCJwcm9maWxlIl0sInJvbGVzIjpbIlJPTEVfVVNFUiIsIlJPTEVfQURNSU4iXSwiaXNzIjoiaHR0cDovLzEyNy4wLjAuMTo5MDAwIiwiZXhwIjoxNzQ1MjUzNTM2LCJ0b2tlbl90eXBlIjoiQWNjZXNzIFRva2VuIiwiaWF0IjoxNzQ1MjUzMjM2LCJqdGkiOiJlZWRmNDA4Ny03YWU2LTQyMGYtYWI0NS0yNDM1NDFiZmJlN2QifQ.GIIiXrdRDv9yATtlygoZGK_-6CGat-LAxx58lrehUpRX7OtllVxFy1iORkKPHypDTc81fs-unB4lSiafsxT8rT2KfBg_JQ5Hk7pCcHKd5scC0wx88VAVjzv66yNYpGGNVu9OySDdjTJ9ATjm-pplnRFq9Ay6qk7mb8cpw9LPHYymAJPawjXO5bcaHvaIhm6CLyFnnTHKvknd9wW5ZIh_YOTEg62oCokkRXepoCuIrw_QG2XBqfEoDFYOKx_isxKD0URCoOJsI57qUK-vyOBPUKdqPshscT-MjJkeEh_QyIPFmzhA75wnfEeK5OhcZ8JNVgy6dDRQ_FVkpOWqhg89Pg" http://localhost:8090/api/v1/users/1 | jq
>
< HTTP/1.1 200 OK
< transfer-encoding: chunked
< Content-Type: application/json
< Date: Mon, 21 Apr 2025 16:34:18 GMT
< token-response: 123456
< Cache-Control: no-cache, no-store, max-age=0, must-revalidate
< Pragma: no-cache
< Expires: 0
< X-Content-Type-Options: nosniff
< X-Frame-Options: DENY
< X-XSS-Protection: 0
< Referrer-Policy: no-referrer
< set-cookie: color=red
<
{
  "id": 1,
  "username": "admin",
  "enabled": true,
  "email": "admin@gmail.com",
  "roles": [
    {
      "id": 2,
      "name": "ROLE_USER"
    },
    {
      "id": 1,
      "name": "ROLE_ADMIN"
    }
  ]
}
````

## Configurando PasswordEncoder y RestClient

Iniciaremos agregando una configuraci√≥n personalizada al `application.yml` del `authorization-server`. Esa configuraci√≥n
lo utilizaremos en el `RestClient` para poder comunicarnos con el `user-service`.

````yml
custom:
  base-url:
    user-service: lb://user-service/api/v1/users
````

En este mismo servidor agregaremos una clase de configuraci√≥n donde inyectamos la configuraci√≥n anterior y adem√°s,
definimos dos beans.

````java

@Configuration
public class AuthConfig {

    @Value("${custom.base-url.user-service}")
    private String userServiceBaseUrl;

    @LoadBalanced
    @Bean(name = "userRestClient")
    public RestClient.Builder restClientBuilder() {
        return RestClient.builder().baseUrl(this.userServiceBaseUrl);
    }

    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }
}
````

Hasta este punto hemos estado trabajando con dos usuarios registrados en memoria dentro del `authorization-server`,
esto lo podemos ver en el `SecurityConfig` en el siguiente bean.

````java

@Bean
public UserDetailsService userDetailsService() {
    UserDetails admin = User.builder()
            .username("admin")
            .password("{noop}123456")
            .roles("USER", "ADMIN")
            .build();

    UserDetails martin = User.builder()
            .username("martin")
            .password("{noop}123456")
            .roles("USER")
            .build();

    return new InMemoryUserDetailsManager(admin, martin);
}
````

En los siguientes apartados estaremos trabajando con los usuarios que tenemos registrados en el `user-service`, as√≠ que
el c√≥digo anterior lo podemos eliminar.

Por otro lado, en este mismo archivo `SecurityConfig` del `authorization-server` inyectamos el `PasswordEncoder` para
hashear la contrase√±a del cliente que registremos en OAuth.

````java

@RequiredArgsConstructor
@Configuration
public class SecurityConfig {

    private final PasswordEncoder passwordEncoder;

    /* code */

    @Bean
    public RegisteredClientRepository registeredClientRepository() {
        RegisteredClient oidcClient = RegisteredClient.withId(UUID.randomUUID().toString())
                .clientId("gateway-app")
                .clientSecret(this.passwordEncoder.encode("123456"))
                .clientAuthenticationMethod(ClientAuthenticationMethod.CLIENT_SECRET_BASIC)
                .authorizationGrantType(AuthorizationGrantType.AUTHORIZATION_CODE)
                .authorizationGrantType(AuthorizationGrantType.REFRESH_TOKEN)
                .redirectUri("http://127.0.0.1:8090/authorized")
                .redirectUri("https://oauthdebugger.com/debug")
                .postLogoutRedirectUri("http://127.0.0.1:8090/logout")
                .scope(OidcScopes.OPENID)
                .scope(OidcScopes.PROFILE)
                .clientSettings(ClientSettings.builder().requireAuthorizationConsent(false).build())
                .build();

        return new InMemoryRegisteredClientRepository(oidcClient);
    }

    /* code */
}
````

Finalmente, como adelanto de lo que veremos en el siguiente apartado vamos a crear una clase de servicio que implemente
el `UserDetailsService` de `Spring Security`.

````java

@Slf4j
@Service
public class UserServiceImpl implements UserDetailsService {

    private final RestClient userRestClient;

    public UserServiceImpl(@Qualifier("userRestClient") RestClient.Builder restClientBuilder) {
        this.userRestClient = restClientBuilder.build();
    }

    @Override
    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {
        return null;
    }
}
````

## Implementando UserDetailsService para login con el microservicio user

Lo primero que haremos ser√° agregar el `password` como parte de la respuesta que nos brinda el endpoint que
consultaremos en el `user-service`.

````java
public record UserResponse(Long id,
                           String username,
                           String password,
                           boolean enabled,
                           String email,
                           Set<RoleResponse> roles) {
}
````

Luego, en el mapper del `user-service` tambi√©n debemos realizar la modificaci√≥n para agregar el password proveniente
de la entidad User.

````java

@RequiredArgsConstructor
@Component
public class UserMapper {

    private final PasswordEncoder passwordEncoder;

    public UserResponse toUserResponse(User user) {
        Set<RoleResponse> rolesResponse = user.getRoles().stream()
                .map(role -> new RoleResponse(role.getId(), role.getName()))
                .collect(Collectors.toSet());
        return new UserResponse(user.getId(), user.getUsername(), user.getPassword(), user.isEnabled(), user.getEmail(), rolesResponse);
    }
    /* code */
}
````

Antes de realizar la implementaci√≥n del `UserDetailsService` en el `authorization-service`, necesitamos agregar algunas
clases de utilidad, modelos, constantes, etc. adicionales.

````java

@UtilityClass
public class AuthConstant {
    public static final String NO_FOUND_MESSAGE = "Login error. The user with id %s does not exist in user-service";
    public static final String COMMUNICATION_MESSAGE = "An error occurred in the user-service: %s";
}
````

````java
public class CommunicationException extends RuntimeException {
    public CommunicationException(String message) {
        super(message);
    }
}
````

````java
public record ErrorResponse(int status,
                            String error,
                            String message,
                            String path) {
    @JsonProperty
    public LocalDateTime timestamp() {
        return LocalDateTime.now().truncatedTo(ChronoUnit.SECONDS);
    }
}
````

````java

@RestControllerAdvice
public class GlobalExceptionHandler {

    @ExceptionHandler({NoSuchElementException.class, UsernameNotFoundException.class})
    public ResponseEntity<ErrorResponse> apiException(NoSuchElementException exception, HttpServletRequest request) {
        ErrorResponse error = new ErrorResponse(HttpStatus.NOT_FOUND.value(), HttpStatus.NOT_FOUND.getReasonPhrase(), exception.getMessage(), request.getRequestURI());
        return new ResponseEntity<>(error, HttpStatus.NOT_FOUND);
    }

    @ExceptionHandler(CommunicationException.class)
    public ResponseEntity<ErrorResponse> apiException(CommunicationException exception, HttpServletRequest request) {
        ErrorResponse error = new ErrorResponse(HttpStatus.INTERNAL_SERVER_ERROR.value(), HttpStatus.INTERNAL_SERVER_ERROR.getReasonPhrase(), exception.getMessage(), request.getRequestURI());
        return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(error);
    }

    @ExceptionHandler(Exception.class)
    public ResponseEntity<ErrorResponse> apiException(Exception exception, HttpServletRequest request) {
        ErrorResponse error = new ErrorResponse(HttpStatus.INTERNAL_SERVER_ERROR.value(), HttpStatus.INTERNAL_SERVER_ERROR.getReasonPhrase(), exception.getMessage(), request.getRequestURI());
        return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(error);
    }
}
````

````java

@UtilityClass
public class Util {
    public static String readInputStream(InputStream inputStream) throws IOException {
        try (BufferedReader reader = new BufferedReader(new InputStreamReader(inputStream))) {
            StringBuilder stringBuilder = new StringBuilder();
            String line;
            while ((line = reader.readLine()) != null) {
                stringBuilder.append(line);
            }
            return stringBuilder.toString();
        }
    }
}
````

Finalmente, definimos nuestras clases dtos `Role` y `User` que nos permitir√° mapear la respuesta que nos retorna el
`user-service`.

````java
public record Role(Long id,
                   String name) {
}
````

````java
public record User(Long id,
                   String username,
                   String password,
                   boolean enabled,
                   String email,
                   Set<Role> roles) {
}
````

Finalizaremos este apartado realizando la implementaci√≥n del `UserDetailsService`.

````java

@Service
public class UserServiceImpl implements UserDetailsService {

    private final RestClient userRestClient;

    public UserServiceImpl(@Qualifier("userRestClient") RestClient.Builder restClientBuilder) {
        this.userRestClient = restClientBuilder.build();
    }

    @Override
    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {
        User user = this.userRestClient.get()
                .uri("/username/{username}", username)
                .exchange((request, response) -> {
                    HttpStatusCode statusCode = response.getStatusCode();
                    if (statusCode == HttpStatus.OK) {
                        return response.bodyTo(User.class);
                    }

                    if (statusCode == HttpStatus.NOT_FOUND) {
                        throw new UsernameNotFoundException(AuthConstant.NO_FOUND_MESSAGE.formatted(username));
                    }

                    String bodyMessage = Util.readInputStream(response.getBody());
                    throw new CommunicationException(AuthConstant.COMMUNICATION_MESSAGE.formatted(bodyMessage));
                });

        Set<GrantedAuthority> authorities = user.roles().stream()
                .map(role -> new SimpleGrantedAuthority(role.name()))
                .collect(Collectors.toSet());

        return new org.springframework.security.core.userdetails.User(user.username(), user.password(), user.enabled(), true, true, true, authorities);
    }
}
````

## Probando implementaci√≥n del UserDetailsService

Levantamos las aplicaciones en el siguiente orden.

- discovery-server
- authorization-server
- user-service
- gateway-server

Ahora, realizamos el mismo flujo que hicimos para obtener un c√≥digo de autorizaci√≥n utilizando la p√°gina
[OAuth 2.0 Debugger](https://oauthdebugger.com/debug). En este punto, seremos redireccionados al servidor de
autorizaci√≥n para loguearnos. Aqu√≠ utilizaremos uno de los usuarios registrados en la base de datos del `user-service`,
en nuestro caso usaremos el usuario `admin`.

Con el c√≥digo de autorizaci√≥n obtenido, realizamos una petici√≥n para obtener el `access token`.

````bash
$ curl -v -X POST -u gateway-app:123456 -d "grant_type=authorization_code&redirect_uri=https://oauthdebugger.com/debug&code=yQWwmHS9Kisc8EjDo-GRPQw1AxfX9LTsT3gvVb-5nGYy9qUgAIGFMDBo-tKNRiX8inowW0p0ZNTJT4qBt-FanQriTZwSyvcg4LD4NWDBEbKip2DaurJbjtP8AjQ6zsXy" http://localhost:9000/oauth2/token | jq
>
< HTTP/1.1 200
< X-Content-Type-Options: nosniff
< X-XSS-Protection: 0
< Cache-Control: no-cache, no-store, max-age=0, must-revalidate
< Pragma: no-cache
< Expires: 0
< X-Frame-Options: DENY
< Content-Type: application/json;charset=UTF-8
< Transfer-Encoding: chunked
< Date: Mon, 21 Apr 2025 20:11:43 GMT
<
{
  "access_token": "eyJraWQiOiJlODEwZDMwYi0wMTUwLTQ5MjUtYmE4YS1lNDIyMGY0Y2IwMDQiLCJhbGciOiJSUzI1NiJ9.eyJzdWIiOiJhZG1pbiIsImF1ZCI6ImdhdGV3YXktYXBwIiwibmJmIjoxNzQ1MjY2MzAzLCJzY29wZSI6WyJvcGVuaWQiLCJwcm9maWxlIl0sInJvbGVzIjpbIlJPTEVfVVNFUiIsIlJPTEVfQURNSU4iXSwiaXNzIjoiaHR0cDovLzEyNy4wLjAuMTo5MDAwIiwiZXhwIjoxNzQ1MjY2NjAzLCJ0b2tlbl90eXBlIjoiQWNjZXNzIFRva2VuIiwiaWF0IjoxNzQ1MjY2MzAzLCJqdGkiOiIyNjU1NjczNi02Nzc3LTQ2OTktYjY0ZC02MTZjZDc0MzQ0YTIifQ.AH-1J4m-wsiZwzbNqg3Idm_Zk6UE99WhSbe8C-vDDDBL5-zY_lfTJe8thUey1sid6ej-z0h0AxGNQp0vmNB_IFLj0V9oIvKBqlU6758qYiBvt_eb9jOk-O46I5KZdLDP8zMqs3P20H_Dr7oaMbp9BYR8Jal-hPpgrfNrg9v-tACLslMA1wdk6DQgeS53tbASqOLU4KJFbcUed0FspB5jeXzHoKL89FoCDuS-B0A_bPLagm7-AnFifIypfvygLgJmu2CcyM_e7B53MFNcIOemzMOaLW7mP3TYA0wqDUQjFS4HaJmtbsYtOKxiYzgnDQdx-wQEWpqbBHscyXou46AheQ",
  "refresh_token": "XUDY9AM6a8TMij62Vd0RcjqxX3IzvqiFNi-mDUreToRxYpzQk0XvSm4OmnHCCBegxjXVia98DktVOYBkskH7A4SrUU7ppgS23Dt-UW9BpI8ojtOw_FPHkuyc1GEZFU_z",
  "scope": "openid profile",
  "id_token": "eyJraWQiOiJlODEwZDMwYi0wMTUwLTQ5MjUtYmE4YS1lNDIyMGY0Y2IwMDQiLCJhbGciOiJSUzI1NiJ9.eyJzdWIiOiJhZG1pbiIsImF1ZCI6ImdhdGV3YXktYXBwIiwiYXpwIjoiZ2F0ZXdheS1hcHAiLCJhdXRoX3RpbWUiOjE3NDUyNjYwNjAsInJvbGVzIjpbIlJPTEVfVVNFUiIsIlJPTEVfQURNSU4iXSwiaXNzIjoiaHR0cDovLzEyNy4wLjAuMTo5MDAwIiwiZXhwIjoxNzQ1MjY4MTAzLCJ0b2tlbl90eXBlIjoiSWQgVG9rZW4iLCJpYXQiOjE3NDUyNjYzMDMsIm5vbmNlIjoiNjM1NHN3ZWh4MWIiLCJqdGkiOiI1NjY0NTgwNi1lOTgyLTRiODctODE5Zi1iYjBkMzk1NGYxMjgiLCJzaWQiOiIxN0l1SlFQQk4zcmlWTGVmeTcwT2FBOW53SFo0MU1JSzZ3RGJTdGpMMzFZIn0.Lgh5Mugs__L8u8XcK4mtturixuPDIt7x7YR89zjcISfSni8LhOJOuZhhubWHfgEfmdj3JgOWin6E0hmtz2Fu_qRxwd-oKWB5F_KHx56Shu-jsxyS8E50FenOnQfmvQOrQrGHWxxWZr9wLmQcljb7W6VNmu1vtQJNFpOxcfgWN23VsZHggMJo4s0li-UGSvWvcbvO0dUr8IxhERaxW4m8Q-yPy3Dq2dwpgcXSthoCoRIURuzjMN-YbErOYbCJWIf5Ldk9MgMikt1aUrlxECMk55mkkx2hZKywS1neflSj98sZQZcBVeS8TyDrVc2aR7eKo44AjzJzUPUzCB0QV251Vg",
  "token_type": "Bearer",
  "expires_in": 299
}
````

Con el `access token` obtenido ya podemos realizar peticiones a endpoints que se encuentran protegidos como en el
siguiente ejemplo.

````bash
$ curl -v -X POST -H "Authorization: Bearer eyJraWQiOiJlODEwZDMwYi0wMTUwLTQ5MjUtYmE4YS1lNDIyMGY0Y2IwMDQiLCJhbGciOiJSUzI1NiJ9.eyJzdWIiOiJhZG1pbiIsImF1ZCI6ImdhdGV3YXktYXBwIiwibmJmIjoxNzQ1MjY2MzAzLCJzY29wZSI6WyJvcGVuaWQiLCJwcm9maWxlIl0sInJvbGVzIjpbIlJPTEVfVVNFUiIsIlJPTEVfQURNSU4iXSwiaXNzIjoiaHR0cDovLzEyNy4wLjAuMTo5MDAwIiwiZXhwIjoxNzQ1MjY2NjAzLCJ0b2tlbl90eXBlIjoiQWNjZXNzIFRva2VuIiwiaWF0IjoxNzQ1MjY2MzAzLCJqdGkiOiIyNjU1NjczNi02Nzc3LTQ2OTktYjY0ZC02MTZjZDc0MzQ0YTIifQ.AH-1J4m-wsiZwzbNqg3Idm_Zk6UE99WhSbe8C-vDDDBL5-zY_lfTJe8thUey1sid6ej-z0h0AxGNQp0vmNB_IFLj0V9oIvKBqlU6758qYiBvt_eb9jOk-O46I5KZdLDP8zMqs3P20H_Dr7oaMbp9BYR8Jal-hPpgrfNrg9v-tACLslMA1wdk6DQgeS53tbASqOLU4KJFbcUed0FspB5jeXzHoKL89FoCDuS-B0A_bPLagm7-AnFifIypfvygLgJmu2CcyM_e7B53MFNcIOemzMOaLW7mP3TYA0wqDUQjFS4HaJmtbsYtOKxiYzgnDQdx-wQEWpqbBHscyXou46AheQ" -H "Content-type: application/json" -d "{\"username\": \"userAa\", \"password\": \"123456\", \"email\": \"userAa@gmail.com\"}" http://localhost:8090/api/v1/users | jq
>
< HTTP/1.1 201 Created
< transfer-encoding: chunked
< Location: /api/v1/users/3
< Content-Type: application/json
< Date: Mon, 21 Apr 2025 20:12:04 GMT
< token-response: 123456
< Cache-Control: no-cache, no-store, max-age=0, must-revalidate
< Pragma: no-cache
< Expires: 0
< X-Content-Type-Options: nosniff
< X-Frame-Options: DENY
< X-XSS-Protection: 0
< Referrer-Policy: no-referrer
< set-cookie: color=red
<
{
  "id": 3,
  "username": "userAa",
  "password": "$2a$10$y1fYtXnVqI06tLWFhTsBL.HkTnK5UKYr.S378a02S99jv1.J5M47C",
  "enabled": true,
  "email": "userAa@gmail.com",
  "roles": [
    {
      "id": 2,
      "name": "ROLE_USER"
    }
  ]
}
````

## Configurar el tiempo de expiraci√≥n del token

Para modificar el tiempo de vida del `access_token` y del `refresh_token` tenemos que agregar c√≥digo adicional al
cliente registrado en el `RegisteredClientRepository` del `SecurityConfig` del `authorization-server`. Estas
modificaciones ser√°n agregadas en el m√©todo concatenado `.tokenSettings(...)`.

````java

@RequiredArgsConstructor
@Configuration
public class SecurityConfig {

    /* code */

    @Bean
    public RegisteredClientRepository registeredClientRepository() {
        RegisteredClient oidcClient = RegisteredClient.withId(UUID.randomUUID().toString())
                .clientId("gateway-app")
                .clientSecret(this.passwordEncoder.encode("123456"))
                .clientAuthenticationMethod(ClientAuthenticationMethod.CLIENT_SECRET_BASIC)
                .authorizationGrantType(AuthorizationGrantType.AUTHORIZATION_CODE)
                .authorizationGrantType(AuthorizationGrantType.REFRESH_TOKEN)
                .redirectUri("http://127.0.0.1:8090/authorized")
                .redirectUri("https://oauthdebugger.com/debug")
                .postLogoutRedirectUri("http://127.0.0.1:8090/logout")
                .scope(OidcScopes.OPENID)
                .scope(OidcScopes.PROFILE)
                .tokenSettings(TokenSettings.builder()
                        .accessTokenTimeToLive(Duration.ofHours(1L))
                        .refreshTokenTimeToLive(Duration.ofDays(1L))
                        .build())
                .clientSettings(ClientSettings.builder().requireAuthorizationConsent(false).build())
                .build();

        return new InMemoryRegisteredClientRepository(oidcClient);
    }

}
````

Si luego de haber realizado estos cambios obtenemos un `access token` y lo decodificamos, veremos que el tiempo de
expiraci√≥n ha cambiado a 1 hora, esto lo podemos observar en el payload `exp`.

![11.png](assets/section-10/11.png)

