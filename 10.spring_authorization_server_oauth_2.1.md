# Sección 10: Spring Authorization Server (OAuth 2.1)

---

## Creando microservicio Spring Authorization Server (OAuth 2.1)

Creamos el nuevo microservicio desde
[Spring Initializr](https://start.spring.io/#!type=maven-project&language=java&platformVersion=3.4.4&packaging=jar&jvmVersion=21&groupId=dev.magadiflo&artifactId=authorization-server&name=authorization-server&description=Authorization%20Server&packageName=dev.magadiflo.authorization.server.app&dependencies=web,lombok,cloud-eureka,security,oauth2-authorization-server)
donde definiremos las siguientes dependencias.

Al ser `Spring Authorization Server` una capa construida por encima de `Spring Security`, necesitamos añadir
también esta dependencia, al igual que `Spring Web` para el manejo de solicitudes y respuestas HTTP que utiliza
`Spring Authorization Server` para realizar las tareas de autenticación y autorización.

````xml
<!--Spring Boot 3.4.4-->
<!--Spring Cloud 2024.0.1-->
<!--Java 21-->
<dependencies>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-oauth2-authorization-server</artifactId>
    </dependency>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-security</artifactId>
    </dependency>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-web</artifactId>
    </dependency>
    <dependency>
        <groupId>org.springframework.cloud</groupId>
        <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>
    </dependency>

    <dependency>
        <groupId>org.projectlombok</groupId>
        <artifactId>lombok</artifactId>
        <optional>true</optional>
    </dependency>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-test</artifactId>
        <scope>test</scope>
    </dependency>
    <dependency>
        <groupId>org.springframework.security</groupId>
        <artifactId>spring-security-test</artifactId>
        <scope>test</scope>
    </dependency>
</dependencies>
````

En el `application.yml` del `authorization-server` agregamos las siguientes configuraciones iniciales.

````yml
server:
  port: 9000
  error:
    include-message: always

spring:
  application:
    name: authorization-server

eureka:
  instance:
    prefer-ip-address: true
    instance-id: ${spring.cloud.client.hostname}:${spring.application.name}:${random.value}
  client:
    service-url:
      defaultZone: http://localhost:8761/eureka/
````

## Configurando el Servidor de Autorización

En este apartado utilizaremos la
[guía de la documentación de Spring Authorization Server](https://docs.spring.io/spring-authorization-server/reference/getting-started.html)
para definir los componentes requeridos en la configuración de nuestro servidor de autorización.

El código siguiente es tal cual se muestra en la documentación, con algunos pequeños cambios para ajustar al proyecto de
microservicios que venimos realizando. Este es el típico ejemplo que muestra cómo levantar un `Authorization Server`
básico con `OAuth 2.1` y soporte `OIDC (OpenID Connect)`.

**Nota**
> La anotación `@EnableWebSecurity` sobre nuestra clase de configuración `SecurityConfig` no es necesario (aunque en el
> código de la documentación sí lo usa).
>
> `¿Por qué no es necesaria?`, `Spring Boot auto-configura Spring Security` si encuentra uno o más `SecurityFilterChain`
> definidos como `@Bean`.
>
> A partir de `Spring Security 5.7` (usado en `Spring Boot 3`), se recomienda usar el enfoque basado en beans,
> es decir: `@Bean public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {}`.
>
> Con este enfoque moderno, `Spring Security` se registra automáticamente sin necesidad de `@EnableWebSecurity`.
>
> Antes (`Spring Boot 2.x` y versiones anteriores), la anotación `@EnableWebSecurity` era necesaria para habilitar la
> configuración de seguridad web en `Spring Security`. Si no la usábamos, Spring no aplicaba la configuración de
> seguridad correctamente.
>
> Ahora, en `Spring Boot 3.x`, `Spring Boot` se encarga de habilitar la configuración de seguridad automáticamente si
> detecta `SecurityFilterChain` como beans en el contexto de la aplicación, y si no la necesitas explícitamente, Spring
> Boot se encarga de la configuración por debajo.
>
> Esto significa que podemos prescindir de la anotación `@EnableWebSecurity` y `Spring Security` funciona bien solo con
> la definición de los `SecurityFilterChain` como beans.

````java

@Configuration
public class SecurityConfig {

    @Bean
    @Order(1)
    public SecurityFilterChain authorizationServerSecurityFilterChain(HttpSecurity http) throws Exception {
        OAuth2AuthorizationServerConfigurer authorizationServerConfigurer =
                OAuth2AuthorizationServerConfigurer.authorizationServer();

        http
                .securityMatcher(authorizationServerConfigurer.getEndpointsMatcher())
                .with(authorizationServerConfigurer, (authorizationServer) ->
                        authorizationServer
                                .oidc(Customizer.withDefaults())    // Enable OpenID Connect 1.0
                )
                .authorizeHttpRequests((authorize) ->
                        authorize
                                .anyRequest().authenticated()
                )
                // Redirect to the login page when not authenticated from the
                // authorization endpoint
                .exceptionHandling((exceptions) -> exceptions
                        .defaultAuthenticationEntryPointFor(
                                new LoginUrlAuthenticationEntryPoint("/login"),
                                new MediaTypeRequestMatcher(MediaType.TEXT_HTML)
                        )
                );

        return http.build();
    }

    @Bean
    @Order(2)
    public SecurityFilterChain defaultSecurityFilterChain(HttpSecurity http) throws Exception {
        http
                .authorizeHttpRequests((authorize) -> authorize
                        .anyRequest().authenticated()
                )
                // Form login handles the redirect to the login page from the
                // authorization server filter chain
                .formLogin(Customizer.withDefaults());

        return http.build();
    }

    @Bean
    public UserDetailsService userDetailsService() {
        UserDetails admin = User.builder()
                .username("admin")
                .password("{noop}123456")
                .roles("USER", "ADMIN")
                .build();

        UserDetails martin = User.builder()
                .username("martin")
                .password("{noop}123456")
                .roles("USER")
                .build();

        return new InMemoryUserDetailsManager(admin, martin);
    }

    @Bean
    public RegisteredClientRepository registeredClientRepository() {
        RegisteredClient oidcClient = RegisteredClient.withId(UUID.randomUUID().toString())
                .clientId("gateway-app")
                .clientSecret("{noop}123456")
                .clientAuthenticationMethod(ClientAuthenticationMethod.CLIENT_SECRET_BASIC)
                .authorizationGrantType(AuthorizationGrantType.AUTHORIZATION_CODE)
                .authorizationGrantType(AuthorizationGrantType.REFRESH_TOKEN)
                .redirectUri("http://127.0.0.1:8090/login/oauth2/code/gateway-app")
                .redirectUri("http://127.0.0.1:8090/authorized")
                .postLogoutRedirectUri("http://127.0.0.1:8090/logout")
                .scope(OidcScopes.OPENID)
                .scope(OidcScopes.PROFILE)
                .clientSettings(ClientSettings.builder().requireAuthorizationConsent(false).build())
                .build();

        return new InMemoryRegisteredClientRepository(oidcClient);
    }

    @Bean
    public JWKSource<SecurityContext> jwkSource() {
        KeyPair keyPair = generateRsaKey();
        RSAPublicKey publicKey = (RSAPublicKey) keyPair.getPublic();
        RSAPrivateKey privateKey = (RSAPrivateKey) keyPair.getPrivate();
        RSAKey rsaKey = new RSAKey.Builder(publicKey)
                .privateKey(privateKey)
                .keyID(UUID.randomUUID().toString())
                .build();
        JWKSet jwkSet = new JWKSet(rsaKey);
        return new ImmutableJWKSet<>(jwkSet);
    }

    private static KeyPair generateRsaKey() {
        KeyPair keyPair;
        try {
            KeyPairGenerator keyPairGenerator = KeyPairGenerator.getInstance("RSA");
            keyPairGenerator.initialize(2048);
            keyPair = keyPairGenerator.generateKeyPair();
        } catch (Exception ex) {
            throw new IllegalStateException(ex);
        }
        return keyPair;
    }

    @Bean
    public JwtDecoder jwtDecoder(JWKSource<SecurityContext> jwkSource) {
        return OAuth2AuthorizationServerConfiguration.jwtDecoder(jwkSource);
    }

    @Bean
    public AuthorizationServerSettings authorizationServerSettings() {
        return AuthorizationServerSettings.builder().build();
    }

}
````

**Dónde**

1. `SecurityFilterChain authorizationServerSecurityFilterChain(...)`, este filtro es exclusivo para proteger los
   endpoints del `Authorization Server`, como `/oauth2/token`, `/oauth2/authorize`, etc.
    - Se usa `OAuth2AuthorizationServerConfigurer` para configurar los endpoints.
    - Se habilita `OIDC` con `.oidc(Customizer.withDefaults())`.
    - Redirige a `/login` si el usuario no está autenticado.
    - Se asegura que cualquier request a los endpoints esté autenticada.


2. `SecurityFilterChain defaultSecurityFilterChain(...)`, este es el filtro para el resto de las rutas no manejadas por
   el `Authorzation Server`.
    - Simple: cualquier request requiere autenticación.
    - Se activa `formLogin()` (pantalla de login por defecto de Spring Security).


3. `UserDetailsService `, estamos definiendo temporalmente usuarios que estarán almacenados en
   memoria. Estos usuarios serán usuarios de prueba mientras desarrollamos el servidor de autorización. Recordemos que
   tenemos un `user-service`, precisamente ese servicio será el que más adelante usaremos para la gestión de los
   usuarios.


4. `RegisteredClientRepository`, definimos un `cliente OAuth2` registrado. Es el cliente que va a pedir autorización. En
   este `RegisteredClientRepository` vemos tres urls definidas, de las cuales:
    - `.redirectUri("http://127.0.0.1:8090/login/oauth2/code/gateway-app")`, es una url propia de `OAuth 2.1`,
      simplemente configuramos el nombre del cliente registrado `gateway-app`.
    - `.redirectUri("http://127.0.0.1:8090/authorized")`, es una url personalizada que debemos crear.
    - `.postLogoutRedirectUri("http://127.0.0.1:8090/logout")`, es una url personalizada que debemos crear.
   Además, colocamos en `false` el `requireAuthorizationConsent()` para que no pida el consentimiento de los scopes.


5. `JWKSource`, este bean genera un par de llaves `RSA (pública y privada)` para firmar `tokens JWT`. Luego, las
   convierte a formato `JWK` para que el `Authorization Server` pueda publicarlas en su endpoint
   `.well-known/jwks.json`.


6. `generateRsaKey()`, genera la llave `RSA` de `2048 bits`. Es puro Java básico para criptografía.


7. `JwtDecoder`, `Spring Authorization Server` necesita un `JwtDecoder` para validar y decodificar los tokens que emite.
   Aquí lo construyes a partir del `JWKSource`.


8. `AuthorizationServerSettings`, construye la configuración del `Authorization Server`. Por defecto, expone los
   endpoints en `/oauth2/token`, `/oauth2/authorize`, etc. Se puede personalizar, pero aquí se usa la config por
   defecto.

Ahora, nos vamos al `gateway-server` y configuramos la ruta hacia nuestro servidor de autorización.

````yml
spring:
  application:
    name: gateway-server
  cloud:
    gateway:
      routes:
        - id: authorization-server-route
          uri: lb://authorization-server
          predicates:
            - Path=/api/v1/authorization-server/**
          filters:
            - RewritePath=/api/v1/authorization-server/(?<path>.*), /$\{path}
````

**Dónde**

- `uri: lb://authorization-server`, esto indica que la solicitud se enviará a un servicio llamado `authorization-server`
  registrado en `Eureka` (porque usamos `lb://`, es decir, `load balancer via discovery`). Debemos asegurarnos de que el
  `spring.application.name` del servidor de autorización lo hayamos definido como `authorization-server`
- `Path=/api/v1/authorization-server/**`, solo las rutas que empiecen con `/api/v1/authorization-server/` serán
  redirigidas al `Authorization Server`.
- `RewritePath`, este filtro elimina el prefijo `/api/v1/authorization-server/` antes de enviar la solicitud al
  `Authorization Server`. Por ejemplo:
    - Petición del cliente: `GET /api/v1/authorization-server/oauth2/token`
    - Se reescribe como: `GET /oauth2/token` (que es lo que espera `Spring Authorization Server`)

