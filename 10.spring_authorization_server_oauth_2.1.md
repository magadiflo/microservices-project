# Sección 10: Spring Authorization Server (OAuth 2.1)

---

## Creando microservicio Spring Authorization Server (OAuth 2.1)

Creamos el nuevo microservicio desde
[Spring Initializr](https://start.spring.io/#!type=maven-project&language=java&platformVersion=3.4.4&packaging=jar&jvmVersion=21&groupId=dev.magadiflo&artifactId=authorization-server&name=authorization-server&description=Authorization%20Server&packageName=dev.magadiflo.authorization.server.app&dependencies=web,lombok,cloud-eureka,security,oauth2-authorization-server)
donde definiremos las siguientes dependencias.

Al ser `Spring Authorization Server` una capa construida por encima de `Spring Security`, necesitamos añadir
también esta dependencia, al igual que `Spring Web` para el manejo de solicitudes y respuestas HTTP que utiliza
`Spring Authorization Server` para realizar las tareas de autenticación y autorización.

````xml
<!--Spring Boot 3.4.4-->
<!--Spring Cloud 2024.0.1-->
<!--Java 21-->
<dependencies>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-oauth2-authorization-server</artifactId>
    </dependency>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-security</artifactId>
    </dependency>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-web</artifactId>
    </dependency>
    <dependency>
        <groupId>org.springframework.cloud</groupId>
        <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>
    </dependency>

    <dependency>
        <groupId>org.projectlombok</groupId>
        <artifactId>lombok</artifactId>
        <optional>true</optional>
    </dependency>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-test</artifactId>
        <scope>test</scope>
    </dependency>
    <dependency>
        <groupId>org.springframework.security</groupId>
        <artifactId>spring-security-test</artifactId>
        <scope>test</scope>
    </dependency>
</dependencies>
````

En el `application.yml` del `authorization-server` agregamos las siguientes configuraciones iniciales.

````yml
server:
  port: 9000
  error:
    include-message: always

spring:
  application:
    name: authorization-server

eureka:
  instance:
    prefer-ip-address: true
    instance-id: ${spring.cloud.client.hostname}:${spring.application.name}:${random.value}
  client:
    service-url:
      defaultZone: http://localhost:8761/eureka/
````

## Configurando el Servidor de Autorización

En este apartado utilizaremos la
[guía de la documentación de Spring Authorization Server](https://docs.spring.io/spring-authorization-server/reference/getting-started.html)
para definir los componentes requeridos en la configuración de nuestro servidor de autorización.

El código siguiente es tal cual se muestra en la documentación, con algunos pequeños cambios para ajustar al proyecto de
microservicios que venimos realizando. Este es el típico ejemplo que muestra cómo levantar un `Authorization Server`
básico con `OAuth 2.1` y soporte `OIDC (OpenID Connect)`.

**Nota**
> La anotación `@EnableWebSecurity` sobre nuestra clase de configuración `SecurityConfig` no es necesario (aunque en el
> código de la documentación sí lo usa).
>
> `¿Por qué no es necesaria?`, `Spring Boot auto-configura Spring Security` si encuentra uno o más `SecurityFilterChain`
> definidos como `@Bean`.
>
> A partir de `Spring Security 5.7` (usado en `Spring Boot 3`), se recomienda usar el enfoque basado en beans,
> es decir: `@Bean public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {}`.
>
> Con este enfoque moderno, `Spring Security` se registra automáticamente sin necesidad de `@EnableWebSecurity`.
>
> Antes (`Spring Boot 2.x` y versiones anteriores), la anotación `@EnableWebSecurity` era necesaria para habilitar la
> configuración de seguridad web en `Spring Security`. Si no la usábamos, Spring no aplicaba la configuración de
> seguridad correctamente.
>
> Ahora, en `Spring Boot 3.x`, `Spring Boot` se encarga de habilitar la configuración de seguridad automáticamente si
> detecta `SecurityFilterChain` como beans en el contexto de la aplicación, y si no la necesitas explícitamente, Spring
> Boot se encarga de la configuración por debajo.
>
> Esto significa que podemos prescindir de la anotación `@EnableWebSecurity` y `Spring Security` funciona bien solo con
> la definición de los `SecurityFilterChain` como beans.

````java

@Configuration
public class SecurityConfig {

    @Bean
    @Order(1)
    public SecurityFilterChain authorizationServerSecurityFilterChain(HttpSecurity http) throws Exception {
        OAuth2AuthorizationServerConfigurer authorizationServerConfigurer =
                OAuth2AuthorizationServerConfigurer.authorizationServer();

        http
                .securityMatcher(authorizationServerConfigurer.getEndpointsMatcher())
                .with(authorizationServerConfigurer, (authorizationServer) ->
                        authorizationServer
                                .oidc(Customizer.withDefaults())    // Enable OpenID Connect 1.0
                )
                .authorizeHttpRequests((authorize) ->
                        authorize
                                .anyRequest().authenticated()
                )
                // Redirect to the login page when not authenticated from the
                // authorization endpoint
                .exceptionHandling((exceptions) -> exceptions
                        .defaultAuthenticationEntryPointFor(
                                new LoginUrlAuthenticationEntryPoint("/login"),
                                new MediaTypeRequestMatcher(MediaType.TEXT_HTML)
                        )
                );

        return http.build();
    }

    @Bean
    @Order(2)
    public SecurityFilterChain defaultSecurityFilterChain(HttpSecurity http) throws Exception {
        http
                .authorizeHttpRequests((authorize) -> authorize
                        .anyRequest().authenticated()
                )
                .csrf(AbstractHttpConfigurer::disable)
                // Form login handles the redirect to the login page from the
                // authorization server filter chain
                .formLogin(Customizer.withDefaults());

        return http.build();
    }

    @Bean
    public UserDetailsService userDetailsService() {
        UserDetails admin = User.builder()
                .username("admin")
                .password("{noop}123456")
                .roles("USER", "ADMIN")
                .build();

        UserDetails martin = User.builder()
                .username("martin")
                .password("{noop}123456")
                .roles("USER")
                .build();

        return new InMemoryUserDetailsManager(admin, martin);
    }

    @Bean
    public RegisteredClientRepository registeredClientRepository() {
        RegisteredClient oidcClient = RegisteredClient.withId(UUID.randomUUID().toString())
                .clientId("gateway-app")
                .clientSecret("{noop}123456")
                .clientAuthenticationMethod(ClientAuthenticationMethod.CLIENT_SECRET_BASIC)
                .authorizationGrantType(AuthorizationGrantType.AUTHORIZATION_CODE)
                .authorizationGrantType(AuthorizationGrantType.REFRESH_TOKEN)
                .redirectUri("http://127.0.0.1:8090/authorized")
                .redirectUri("https://oauthdebugger.com/debug")
                .postLogoutRedirectUri("http://127.0.0.1:8090/logout")
                .scope(OidcScopes.OPENID)
                .scope(OidcScopes.PROFILE)
                .clientSettings(ClientSettings.builder().requireAuthorizationConsent(false).build())
                .build();

        return new InMemoryRegisteredClientRepository(oidcClient);
    }

    @Bean
    public JWKSource<SecurityContext> jwkSource() {
        KeyPair keyPair = generateRsaKey();
        RSAPublicKey publicKey = (RSAPublicKey) keyPair.getPublic();
        RSAPrivateKey privateKey = (RSAPrivateKey) keyPair.getPrivate();
        RSAKey rsaKey = new RSAKey.Builder(publicKey)
                .privateKey(privateKey)
                .keyID(UUID.randomUUID().toString())
                .build();
        JWKSet jwkSet = new JWKSet(rsaKey);
        return new ImmutableJWKSet<>(jwkSet);
    }

    private static KeyPair generateRsaKey() {
        KeyPair keyPair;
        try {
            KeyPairGenerator keyPairGenerator = KeyPairGenerator.getInstance("RSA");
            keyPairGenerator.initialize(2048);
            keyPair = keyPairGenerator.generateKeyPair();
        } catch (Exception ex) {
            throw new IllegalStateException(ex);
        }
        return keyPair;
    }

    @Bean
    public JwtDecoder jwtDecoder(JWKSource<SecurityContext> jwkSource) {
        return OAuth2AuthorizationServerConfiguration.jwtDecoder(jwkSource);
    }

    @Bean
    public AuthorizationServerSettings authorizationServerSettings() {
        return AuthorizationServerSettings.builder().issuer("http://127.0.0.1:9000").build();
    }

}
````

**Dónde**

1. `SecurityFilterChain authorizationServerSecurityFilterChain(...)`, este filtro es exclusivo para proteger los
   endpoints del `Authorization Server`, como `/oauth2/token`, `/oauth2/authorize`, etc.
    - Se usa `OAuth2AuthorizationServerConfigurer` para configurar los endpoints.
    - Se habilita `OIDC` con `.oidc(Customizer.withDefaults())`.
    - Redirige a `/login` si el usuario no está autenticado.
    - Se asegura que cualquier request a los endpoints esté autenticada.


2. `SecurityFilterChain defaultSecurityFilterChain(...)`, este es el filtro para el resto de las rutas no manejadas por
   el `Authorzation Server`.
    - Simple: cualquier request requiere autenticación.
    - Se activa `formLogin()` (pantalla de login por defecto de Spring Security).


3. `UserDetailsService `, estamos definiendo temporalmente usuarios que estarán almacenados en
   memoria. Estos usuarios serán usuarios de prueba mientras desarrollamos el servidor de autorización. Recordemos que
   tenemos un `user-service`, precisamente ese servicio será el que más adelante usaremos para la gestión de los
   usuarios.


4. `RegisteredClientRepository`, definimos un `cliente OAuth2` registrado. Es el cliente que va a pedir autorización. En
   este `RegisteredClientRepository` vemos urls definidas, de las cuales:
    - `.redirectUri("http://127.0.0.1:8090/authorized")`, es una url personalizada que debemos crear, dado que el tutor
      del curso lo crea para poder recibir el código de autorización. Sin embargo, en mi caso usaré la url de
      `oauthdebugger.com` para obtener dicho código de autorización.
    - `.redirectUri("https://oauthdebugger.com/debug")`, definimos esta página que nos ayudará a realizar el flujo para
      la obtención del código de autorización.
    - `.postLogoutRedirectUri("http://127.0.0.1:8090/logout")`, es una url personalizada que debemos crear.

   Además, colocamos en `false` el `requireAuthorizationConsent()` para que no pida el consentimiento de los scopes.


5. `JWKSource`, este bean genera un par de llaves `RSA (pública y privada)` para firmar `tokens JWT`. Luego, las
   convierte a formato `JWK` para que el `Authorization Server` pueda publicarlas en su endpoint
   `.well-known/jwks.json`.


6. `generateRsaKey()`, genera la llave `RSA` de `2048 bits`. Es puro Java básico para criptografía.


7. `JwtDecoder`, `Spring Authorization Server` necesita un `JwtDecoder` para validar y decodificar los tokens que emite.
   Aquí lo construyes a partir del `JWKSource`.


8. `AuthorizationServerSettings`, en la configuración del servidor de autorización, he agregado una personalización
   para establecer el `issuer URI` (el identificador del emisor del token). El `AuthorizationServerSettings` es un bean
   que define las configuraciones del servidor de autorización, y por defecto,
   `Spring Security OAuth2 Authorization Server` expone los endpoints estándar como `/oauth2/authorize`,
   `/oauth2/token`, etc. En nuestro caso, he personalizado el `issuer URI`, que es un valor importante en el contexto de
   `JWT (JSON Web Tokens)`. El `issuer` es utilizado por los clientes para identificar la autoridad que ha emitido un
   token y es comúnmente parte de los metadatos de configuración en un servidor de autorización.

Ahora, nos vamos al `gateway-server` y configuramos la ruta hacia nuestro servidor de autorización.

````yml
spring:
  application:
    name: gateway-server
  cloud:
    gateway:
      routes:
        - id: authorization-server-route
          uri: lb://authorization-server
          predicates:
            - Path=/api/v1/authorization-server/**
          filters:
            - RewritePath=/api/v1/authorization-server/(?<path>.*), /$\{path}
````

**Dónde**

- `uri: lb://authorization-server`, esto indica que la solicitud se enviará a un servicio llamado `authorization-server`
  registrado en `Eureka` (porque usamos `lb://`, es decir, `load balancer via discovery`). Debemos asegurarnos de que el
  `spring.application.name` del servidor de autorización lo hayamos definido como `authorization-server`
- `Path=/api/v1/authorization-server/**`, solo las rutas que empiecen con `/api/v1/authorization-server/` serán
  redirigidas al `Authorization Server`.
- `RewritePath`, este filtro elimina el prefijo `/api/v1/authorization-server/` antes de enviar la solicitud al
  `Authorization Server`. Por ejemplo:
    - Petición del cliente: `GET /api/v1/authorization-server/oauth2/token`
    - Se reescribe como: `GET /oauth2/token` (que es lo que espera `Spring Authorization Server`)

## Implementando endpoint /authorized y /logout en Gateway Server

Recordemos que en el `SecurityConfig` del `authorization-server` creamos un bean `RegisteredClientRepository`. Dentro
de este bean definimos las siguientes uris que dijimos, debíamos crear:

- http://127.0.0.1:8090/authorized
- http://127.0.0.1:8090/logout

Entonces, en este apartado implementaremos esas uris en nuestro `gateway-server`, dado que el puerto que definimos
es precisamente el puerto del `gateway-server`.

````java

@RestController
public class AppController {

    @GetMapping(path = "/authorized")
    public ResponseEntity<Map<String, String>> authorized(@RequestParam String code) {
        return ResponseEntity.ok(Collections.singletonMap("code", code));
    }

    @PostMapping(path = "/logout")
    public ResponseEntity<Map<String, String>> logout() {
        return ResponseEntity.ok(Collections.singletonMap("logout", "OK"));
    }
}
````

**Importante**

> Hemos agregado un controlador al `gateway-server` con dos uris `/authorized` y `/logout`. Pero recordemos que en el
> `application.yml` de este `gateway-server` tenemos definidas rutas de microservicios a las que `gateway` redirigirá.
> La pregunta es `¿quién responde primero? ¿Spring Cloud Gateway o Spring WebFlux (Spring Web MVC si fuera Servlet)?`
>
> `Spring Cloud Gateway` primero evalúa las rutas configuradas en el `application.yml` mediante el componente
> `RoutePredicateHandlerMapping`.
> - Si una ruta coincide, el `gateway` maneja la solicitud, es decir, la enruta al microservicio correspondiente, aplica
    filtros, etc.
> - Si ninguna ruta coincide, Spring WebFlux continúa buscando coincidencias entre los `@RestController` definidos en el
    `Gateway` usando el `WebFluxHandlerMapping`.

## Configurando Resource Server y Cliente OAuth2 en yml

Nuestro `gateway-server` va a cumplir dos papeles:

1. Será un `cliente OAuth2` del `authorization-server`, para iniciar el flujo de autenticación del usuario (por ejemplo,
   mediante `spring-security-oauth2-client`). El usuario se podrá loguear y obtener un `access token` que le permitirá
   acceder a los distintos microservicios.


2. También actuará como un `resource server`, encargado de validar el `access token` incluido en las peticiones
   (generalmente mediante un encabezado `Authorization: Bearer <token>`). Para esto, utiliza la configuración del
   `authorization-server` (como el `issuer-uri` o las `JWKs`) para validar que el token sea válido y no haya expirado.
   Esto protege las rutas del gateway y evita que usuarios no autorizados accedan a los microservicios.

⚠️ Importante
> El `gateway` no tiene que llamar al `authorization server` en cada solicitud para validar el token. Es decir,
> no necesita preguntar al `authorization server` en cada solicitud si el token es válido. Porque puede verificar la
> firma localmente usando la clave pública del `authorization server`. Es decir, usa una
> `clave pública (JWK)` publicada por el `authorization-server` para validar localmente la `firma del token JWT`. Esto
> es más eficiente.
>
> El authorization server expone un endpoint JWK (JSON Web Key), normalmente accesible en una URL como:
> `http://localhost:9000/.well-known/jwks.json`
>
> Este endpoint contiene la(s) clave(s) pública(s) necesarias para que cualquier `resource server` pueda verificar
> las firmas de los `JWT` emitidos. Entonces el flow es así:
>
> 🔁 Primera vez que el resource server recibe un token → si no tiene la clave pública, consulta el endpoint JWK y la
> guarda en memoria (caché).
>
> 📦 Después → usa la clave en memoria para validar los siguientes tokens sin tener que llamar otra vez al `authorization
> server`.

Así que iniciamos agregando las siguientes dependencias al `pom.xml` del `gateway-server`.

````xml

<dependencies>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-oauth2-client</artifactId>
    </dependency>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-oauth2-resource-server</artifactId>
    </dependency>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-security</artifactId>
    </dependency>
</dependencies>
````

Luego, vamos al `application.yml` del `gateway-server` para configurar nuestro servidor `gateway` como
`cliente de OAuth2` y como `servidor de recursos`.

````yml

spring:
  application:
    name: gateway-server
  security:
    oauth2:
      resourceserver:
        jwt:
          issuer-uri: http://127.0.0.1:9000
      client:
        registration:
          my-oauth2-client:
            provider: my-auth-server
            client-id: gateway-app
            client-secret: 123456
            authorization-grant-type: authorization_code
            redirect-uri: http://127.0.0.1:8090/authorized
            scope: openid, profile
        provider:
          my-auth-server:
            issuer-uri: http://127.0.0.1:9000
````

Las configuraciones anteriores muestran los dos papeles que estaría cumpliendo nuestro `gateway-server`, veamos uno por
uno.

### 1. Como Resource Server

````yml
spring:
  security:
    oauth2:
      resourceserver:
        jwt:
          issuer-uri: http://127.0.0.1:9000
````

- Esto indica que el `gateway-server` usará `JWT` para validar tokens.
- Spring buscará automáticamente el `JWK Set` en el endpoint `http://127.0.0.1:9000/.well-known/openid-configuration`.
- De ese endpoint obtendrá el `jwks_uri`, por ejemplo `http://127.0.0.1:9000/oauth2/jwks`.
- `Spring` descargará la `clave pública` una sola vez y luego la `cacheará` localmente para `validar los JWT` sin tener
  que llamar al `authorization server` en cada solicitud, justo como mencionamos antes.

### 2. Como OAuth2 Client

````yml
      client:
        registration:
          my-oauth2-client:
            provider: my-auth-server
            client-id: gateway-app
            client-secret: 123456
            authorization-grant-type: authorization_code
            redirect-uri: http://127.0.0.1:8090/authorized
            scope: openid, profile
        provider:
          my-auth-server:
            issuer-uri: http://127.0.0.1:9000
````

- Estamos registrando un cliente llamado `my-oauth2-client` que apunta al `authorization-server`.
- La propiedad `issuer-uri` es clave, ya que a partir de ahí Spring podrá autoconfigurar los endpoints necesarios
  `(/authorize, /token, etc.)`.
- No solo hemos configurado correctamente el `redirect-uri` de acuerdo con lo registrado en el `Authorization Server`
  (en la clase `SecurityConfig`), sino que además coinciden todos los valores clave del cliente: `client-id`,
  `client-secret`, `scopes` y el `authorization-grant-type`.

## Configurando clase Resource Server Security Endpoint

Ahora tenemos que implementar la clase `SecurityConfig` pero por el lado del `gateway-server` donde configuraremos la
protección de las rutas, los endpoints, etc.

**Nota**
> Recordar que nuestro `gateway-server` está trabajando con `programación reactiva`, por lo tanto la configuración será
> teniendo en cuenta ese detalle. Por ejemplo:
>
> En este caso usamos el `SecurityWebFilterChain` que se usa en `Spring WebFlux (Reactive stack)`, donde todo es
> reactivo.
>
> Si nuestro `gateway-server` fuera una aplicación `Spring MVC (Servlet stack)`, como en aplicaciones clásicas con
> Spring Boot, entonces usaríamos `SecurityFilterChain`.

A continuación se muestra la configuración inicial de nuestro `SecurityConfig`.

````java

@Configuration
public class SecurityConfig {

    @Bean
    public SecurityWebFilterChain securityWebFilterChain(ServerHttpSecurity http) {
        http
                .authorizeExchange(authorize -> authorize
                        .pathMatchers("/authorized", "/logout").permitAll()
                        .pathMatchers(HttpMethod.GET, "/api/v1/products", "/api/v1/items", "/api/v1/users").permitAll()
                        .pathMatchers(HttpMethod.GET, "/api/v1/products/{productId}", "/api/v1/items/{productId}", "/api/v1/users/{userId}", "/api/v1/users/username/{username}").hasAnyRole("ADMIN", "USER")
                        .pathMatchers("/api/v1/products/**", "/api/v1/items/**", "/api/v1/users/**").hasRole("ADMIN")
                        .anyExchange().authenticated()
                )
                .cors(ServerHttpSecurity.CorsSpec::disable)
                .securityContextRepository(NoOpServerSecurityContextRepository.getInstance())
                .oauth2Login(Customizer.withDefaults())
                .oauth2Client(Customizer.withDefaults())
                .oauth2ResourceServer(oauth2ResourceServer ->
                        oauth2ResourceServer.jwt(Customizer.withDefaults()));
        return http.build();
    }

}
````

1. Uso de `SecurityWebFilterChain`, esto es completamente correcto porque estamos usando `Spring WebFlux` (por eso es
   `SecurityWebFilterChain` y no `SecurityFilterChain` que es para `Spring MVC`).


2. Permitimos el acceso público a endpoints específicos:
    - `/authorized` y `/logout` → acceso público.
    - `GET` a `/api/v1/products`, `/items`, `/users` → acceso público.
    - `GET` a recursos individuales → restringido a `ROLE_ADMIN` o `ROLE_USER`.
    - Otros métodos `(POST, PUT, DELETE, etc.)` a esos endpoints → restringidos a `ROLE_ADMIN`.


3. Autenticación `OAuth2`:
    - `oauth2Login()` y `oauth2Client()` → esto permite que actúe como `cliente OAuth2`.
    - `oauth2ResourceServer()` → protege las rutas con `tokens JWT`.


4. `CORS` deshabilitado (de momento), por ahora podemos mantenerlo deshabilitado si no tenemos frontend aún. Pero cuando
   lo tengamos, asegurarnos de:
    - Habilitar CORS.
    - Especificar el origen del frontend (por ejemplo http://localhost:4200).
    - Probar llamadas desde el navegador para validar que no haya errores CORS.

5. `.securityContextRepository(NoOpServerSecurityContextRepository.getInstance())`, en aplicaciones reactivas con
   `Spring Security`, no se crean sesiones por defecto como sí pasa con `Spring MVC`. Pero si queremos asegurarnos
   explícitamente de que no se almacene nada en el `SecurityContext` de la sesión, podemos deshabilitarlo con esta
   configuración. Entonces, esta configuración le dice a Spring: *"No almacenes el contexto de seguridad en ningún lado,
   ni en memoria ni en una sesión. Todo debe venir con cada petición (por ejemplo, en el JWT)."*

**Importante: ¿Quién se ejecuta primero, el SecurityConfig o las rutas del gateway?**
> La seguridad se evalúa primero, antes de que el `RoutePredicateHandlerMapping` del `Gateway` intente hacer el
> enrutamiento.
>
> En otras palabras, cuando llega una petición al gateway, por ejemplo: `GET http://localhost:8090/api/v1/users/1`:
>
> 1. `Spring Security` (usando el `SecurityWebFilterChain`) intercepta la petición.
> 2. Evalúa los `pathMatchers()`:
> - En nuestro caso, `/api/v1/users/1` es una ruta protegida.
> - Según la configuración, necesita el rol `ADMIN` o `USER`.
> 3. Si el `token JWT` no está presente o no tiene el rol requerido, la petición es bloqueada ahí mismo (con `401` o
     `403`), y nunca se intenta redirigir al microservicio `user-service`.
> 4. Si pasa la validación de seguridad, entonces sí se evalúa la configuración de enrutamiento (`application.yml`) y la
     petición se reenvía al microservicio correspondiente (usando `lb://user-service`).

**Conclusión**

> Primero evalúa lo configurado en el `SecurityConfig`, y solo si pasa, entonces se intenta hacer match con las rutas
> del `application.yml`.

## Probando implementación del tipo de concesión de código de autorización (Authorization Code Grant Type)

Vamos a ejecutar nuestros microservicios para ver que las configuraciones que hemos realizado hasta ahora estén
funcionando sin problemas. Como solo vamos a hacer pruebas, con el `user-service` sería suficiente, luego sí es
necesario hacer uso del `discovery-server`, `authorization-server` y `gateway-server`.

Levantamos las aplicaciones en el siguiente orden.

- discovery-server
- authorization-server
- user-service
- gateway-server

Como tenemos levantado el `authorization-server` podemos ingresar a una ruta que este servidor nos proporciona como
parte de la especificación de `OAuth 2.1 Authorization Server Metadata`. `Spring Authorization Server` la expone
automáticamente si configuramos correctamente nuestro servidor de autorización.

````bash
http://127.0.0.1:9000/.well-known/oauth-authorization-server
````

Podemos observar que nos retorna un `JSON` con metadatos. Este documento permite a los `clientes OAuth` (como una app
`frontend` o `backend`) descubrir los endpoints del `servidor de autorización`.

![01.png](assets/section-10/01.png)

Del resultado anterior, utilizaremos los siguientes endpoints que nos permitirá realizar el flujo del tipo de concesión
`authentication code`.

````bash
http://127.0.0.1:9000/oauth2/authorize
http://127.0.0.1:9000/oauth2/token
````

### Obteniendo código de autorización

El primer paso para el tipo de concesión `Authorization code` es obtener un `código` que luego lo intercambiaremos por
un `access token`. Entonces, para apoyarnos con el inicio de este flujo utilizaremos la siguiente web
`https://oauthdebugger.com/debug`.

A continuación se muestra marcado en un cuadro rojo, los campos que se ingresaron manualmente. Además, es importante
notar que en el campo `Redirect URI (required)` estamos colocando la misma dirección de esta web
`https://oauthdebugger.com/debug` que es la misma que configuramos en el `SecurityConfig` del `authorization-server`.
Esto es relevante, porque cuando hagamos un `Send Request` la solicitud se enviará a
`http://127.0.0.1:9000/oauth2/authorize` (servidor de autorización) donde se generará el código de autorización. Luego,
el servidor de autorización redireccionará a esta web el código generado.

![02.png](assets/section-10/02.png)

Al hacer clic en `Send Request` y al ser la primera vez que hacemos la solicitud al `authorization-server`, nos pide
que nos autentiquemos. En este caso usamos una de las credenciales almacenadas en memoria dentro del servidor de
autorización.

![03.png](assets/section-10/03.png)

Luego de que la autenticación sea exitosa, el servidor de autorización nos retornará el `Authorization Code` solicitado.

![04.png](assets/section-10/04.png)

### Obteniendo token de acceso

Ese código de autorización lo utilizaremos para solicitar el `access token`.

````bash
$ curl -v -X POST -u gateway-app:123456 -d "grant_type=authorization_code&redirect_uri=https://oauthdebugger.com/debug&code=IoMHnjZoEG0K5zdWwUrW1BgDAPmdKGxtbg4eiusFRVf1TSJpMPZm1X3kzLfCN5xrcVS9jjxdjV-AonDqAh-6drejTw25wlqvkQjmVGuYcA7gqjSUXkjW19n-VprDm-1s" http://localhost:9000/oauth2/token | jq
>
< HTTP/1.1 200
< X-Content-Type-Options: nosniff
< X-XSS-Protection: 0
< Cache-Control: no-cache, no-store, max-age=0, must-revalidate
< Pragma: no-cache
< Expires: 0
< X-Frame-Options: DENY
< Content-Type: application/json;charset=UTF-8
< Transfer-Encoding: chunked
< Date: Mon, 21 Apr 2025 01:39:58 GMT
<
{
  "access_token": "eyJraWQiOiJmYmRhYWNjMC04ZjhkLTRmNDAtODVkYS1kZDU0MGY0OTdkMGQiLCJhbGciOiJSUzI1NiJ9.eyJzdWIiOiJhZG1pbiIsImF1ZCI6ImdhdGV3YXktYXBwIiwibmJmIjoxNzQ1MTk5NTk4LCJzY29wZSI6WyJvcGVuaWQiLCJwcm9maWxlIl0sImlzcyI6Imh0dHA6Ly8xMjcuMC4wLjE6OTAwMCIsImV4cCI6MTc0NTE5OTg5OCwiaWF0IjoxNzQ1MTk5NTk4LCJqdGkiOiJiMGZlMWIwZC0yODAxLTRmMzMtYWZiNi1lMDBmYTEwMWRkMGUifQ.Vq-I9fW5sGBQ_dfdPuNmyruZ96v9-KhUEjHtKdGrtzom8Fz_dQxE5hgUB6CCXREO8zH3arslvxvMRkSARpw4cN0Jz8DY7-s9-tCqcJ7RKhF8s0jcw_KlRcUAQ4X6qlbmZk52taxekF1emsNnq2yMqhQRBWJlZiJA0LMA7sLLHfRRbhNHJBBx7aM0eCJAs9Hy3_OuOGtX-0IfuqjFaaJOGsc1Q34C9Jt4zCtYIoVZ8O82jiNI9qmSxnNzCPWCGDOcs3-zPFYiUpWn64BqkJnhhvplI5RXaYeh9EYq-U66veEg-d5wt3c8ZQRWylOeEbNoWwwQtkYnUOnBbIH_xbEqog",
  "refresh_token": "dVcOL4LjKuFUF3j0SByescHRFjYtH9XOM3eDroiJR-JTtnFEreqW6CkzPqQM2xbcbd1FdzXMEtsr73qzKyxCqvYbnfwAGYJu-rX1uJcH3nQFG2rLDszJ1I7MsqgQZhoO",
  "scope": "openid profile",
  "id_token": "eyJraWQiOiJmYmRhYWNjMC04ZjhkLTRmNDAtODVkYS1kZDU0MGY0OTdkMGQiLCJhbGciOiJSUzI1NiJ9.eyJzdWIiOiJhZG1pbiIsImF1ZCI6ImdhdGV3YXktYXBwIiwiYXpwIjoiZ2F0ZXdheS1hcHAiLCJhdXRoX3RpbWUiOjE3NDUxOTk1NzcsImlzcyI6Imh0dHA6Ly8xMjcuMC4wLjE6OTAwMCIsImV4cCI6MTc0NTIwMTM5OCwiaWF0IjoxNzQ1MTk5NTk4LCJub25jZSI6Imsxa2k1OGVtYWFmIiwianRpIjoiZTM5NGMwMDAtNzZkOC00ZTBiLWE2ODMtNjNjNGQyZjI1ZjE1Iiwic2lkIjoiNWV1Ym51THVvbHlMbWRTM0ZIeHBuZHNyXzJ0Nmw1UFdxb1FfeWY5Y01HcyJ9.LM4heL-I2mR8KF_2nFX-eGs2utgT9p7hJ0Dtld3vaH2mCQgRiEEBSZFYyPz0pU7D1Vz68M6m5wPKCs7F009D48_s8N7v805YC-q_s3TzDbvANesxLAxrU8eM9PrQp3akLo3PzikoDSB9UT70aEXbVj4rj22u0pXbDqabrmuvKoRipvcd5RcSqWGVWZFACm4t-deE7RRtee3A8trZVWbnp_7XNcaFIbFXY2CYcybsZnjPkMoQuk9Emvx72GrOZqT3zgC1jbY4ZVGOrjPxbDhBXe5VH9NF5gMLNA0To10SxNSSI9uZtOTYs7qZQJ7LvgqVWCGbSCpfu8HD2Z1uMH652w",
  "token_type": "Bearer",
  "expires_in": 300
}
````

Si decodificamos el `access token` podemos observar que se corresponde con el usuario con el que iniciamos sesión.

![05.png](assets/section-10/05.png)

Si quisiéramos obtener un `access token` para otro usuario, debemos cerrar sesión ingresando a la siguiente url
`http://127.0.0.1:9000/logout`. Como vemos nos aparece el mensaje `se ha cerrado la sesión`, ahora sí podemos volver a
iniciar sesión con otro usuario.

![06.png](assets/section-10/06.png)
