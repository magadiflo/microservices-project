# Sección 10: Spring Authorization Server (OAuth 2.1)

---

## Creando microservicio Spring Authorization Server (OAuth 2.1)

Creamos el nuevo microservicio desde
[Spring Initializr](https://start.spring.io/#!type=maven-project&language=java&platformVersion=3.4.4&packaging=jar&jvmVersion=21&groupId=dev.magadiflo&artifactId=authorization-server&name=authorization-server&description=Authorization%20Server&packageName=dev.magadiflo.authorization.server.app&dependencies=web,lombok,cloud-eureka,security,oauth2-authorization-server)
donde definiremos las siguientes dependencias.

Al ser `Spring Authorization Server` una capa construida por encima de `Spring Security`, necesitamos añadir
también esta dependencia, al igual que `Spring Web` para el manejo de solicitudes y respuestas HTTP que utiliza
`Spring Authorization Server` para realizar las tareas de autenticación y autorización.

````xml
<!--Spring Boot 3.4.4-->
<!--Spring Cloud 2024.0.1-->
<!--Java 21-->
<dependencies>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-oauth2-authorization-server</artifactId>
    </dependency>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-security</artifactId>
    </dependency>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-web</artifactId>
    </dependency>
    <dependency>
        <groupId>org.springframework.cloud</groupId>
        <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>
    </dependency>

    <dependency>
        <groupId>org.projectlombok</groupId>
        <artifactId>lombok</artifactId>
        <optional>true</optional>
    </dependency>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-test</artifactId>
        <scope>test</scope>
    </dependency>
    <dependency>
        <groupId>org.springframework.security</groupId>
        <artifactId>spring-security-test</artifactId>
        <scope>test</scope>
    </dependency>
</dependencies>
````

En el `application.yml` del `authorization-server` agregamos las siguientes configuraciones iniciales.

````yml
server:
  port: 9000
  error:
    include-message: always

spring:
  application:
    name: authorization-server

eureka:
  instance:
    prefer-ip-address: true
    instance-id: ${spring.cloud.client.hostname}:${spring.application.name}:${random.value}
  client:
    service-url:
      defaultZone: http://localhost:8761/eureka/
````

## Configurando el Servidor de Autorización

En este apartado utilizaremos la
[guía de la documentación de Spring Authorization Server](https://docs.spring.io/spring-authorization-server/reference/getting-started.html)
para definir los componentes requeridos en la configuración de nuestro servidor de autorización.

El código siguiente es tal cual se muestra en la documentación, con algunos pequeños cambios para ajustar al proyecto de
microservicios que venimos realizando. Este es el típico ejemplo que muestra cómo levantar un `Authorization Server`
básico con `OAuth 2.1` y soporte `OIDC (OpenID Connect)`.

**Nota**
> La anotación `@EnableWebSecurity` sobre nuestra clase de configuración `SecurityConfig` no es necesario (aunque en el
> código de la documentación sí lo usa).
>
> `¿Por qué no es necesaria?`, `Spring Boot auto-configura Spring Security` si encuentra uno o más `SecurityFilterChain`
> definidos como `@Bean`.
>
> A partir de `Spring Security 5.7` (usado en `Spring Boot 3`), se recomienda usar el enfoque basado en beans,
> es decir: `@Bean public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {}`.
>
> Con este enfoque moderno, `Spring Security` se registra automáticamente sin necesidad de `@EnableWebSecurity`.
>
> Antes (`Spring Boot 2.x` y versiones anteriores), la anotación `@EnableWebSecurity` era necesaria para habilitar la
> configuración de seguridad web en `Spring Security`. Si no la usábamos, Spring no aplicaba la configuración de
> seguridad correctamente.
>
> Ahora, en `Spring Boot 3.x`, `Spring Boot` se encarga de habilitar la configuración de seguridad automáticamente si
> detecta `SecurityFilterChain` como beans en el contexto de la aplicación, y si no la necesitas explícitamente, Spring
> Boot se encarga de la configuración por debajo.
>
> Esto significa que podemos prescindir de la anotación `@EnableWebSecurity` y `Spring Security` funciona bien solo con
> la definición de los `SecurityFilterChain` como beans.

````java

@Configuration
public class SecurityConfig {

    @Bean
    @Order(1)
    public SecurityFilterChain authorizationServerSecurityFilterChain(HttpSecurity http) throws Exception {
        OAuth2AuthorizationServerConfigurer authorizationServerConfigurer =
                OAuth2AuthorizationServerConfigurer.authorizationServer();

        http
                .securityMatcher(authorizationServerConfigurer.getEndpointsMatcher())
                .with(authorizationServerConfigurer, (authorizationServer) ->
                        authorizationServer
                                .oidc(Customizer.withDefaults())    // Enable OpenID Connect 1.0
                )
                .authorizeHttpRequests((authorize) ->
                        authorize
                                .anyRequest().authenticated()
                )
                // Redirect to the login page when not authenticated from the
                // authorization endpoint
                .exceptionHandling((exceptions) -> exceptions
                        .defaultAuthenticationEntryPointFor(
                                new LoginUrlAuthenticationEntryPoint("/login"),
                                new MediaTypeRequestMatcher(MediaType.TEXT_HTML)
                        )
                );

        return http.build();
    }

    @Bean
    @Order(2)
    public SecurityFilterChain defaultSecurityFilterChain(HttpSecurity http) throws Exception {
        http
                .authorizeHttpRequests((authorize) -> authorize
                        .anyRequest().authenticated()
                )
                .csrf(AbstractHttpConfigurer::disable)
                // Form login handles the redirect to the login page from the
                // authorization server filter chain
                .formLogin(Customizer.withDefaults());

        return http.build();
    }

    @Bean
    public UserDetailsService userDetailsService() {
        UserDetails admin = User.builder()
                .username("admin")
                .password("{noop}123456")
                .roles("USER", "ADMIN")
                .build();

        UserDetails martin = User.builder()
                .username("martin")
                .password("{noop}123456")
                .roles("USER")
                .build();

        return new InMemoryUserDetailsManager(admin, martin);
    }

    @Bean
    public RegisteredClientRepository registeredClientRepository() {
        RegisteredClient oidcClient = RegisteredClient.withId(UUID.randomUUID().toString())
                .clientId("gateway-app")
                .clientSecret("{noop}123456")
                .clientAuthenticationMethod(ClientAuthenticationMethod.CLIENT_SECRET_BASIC)
                .authorizationGrantType(AuthorizationGrantType.AUTHORIZATION_CODE)
                .authorizationGrantType(AuthorizationGrantType.REFRESH_TOKEN)
                .redirectUri("http://127.0.0.1:8090/authorized")
                .redirectUri("https://oauthdebugger.com/debug")
                .postLogoutRedirectUri("http://127.0.0.1:8090/logout")
                .scope(OidcScopes.OPENID)
                .scope(OidcScopes.PROFILE)
                .clientSettings(ClientSettings.builder().requireAuthorizationConsent(false).build())
                .build();

        return new InMemoryRegisteredClientRepository(oidcClient);
    }

    @Bean
    public JWKSource<SecurityContext> jwkSource() {
        KeyPair keyPair = generateRsaKey();
        RSAPublicKey publicKey = (RSAPublicKey) keyPair.getPublic();
        RSAPrivateKey privateKey = (RSAPrivateKey) keyPair.getPrivate();
        RSAKey rsaKey = new RSAKey.Builder(publicKey)
                .privateKey(privateKey)
                .keyID(UUID.randomUUID().toString())
                .build();
        JWKSet jwkSet = new JWKSet(rsaKey);
        return new ImmutableJWKSet<>(jwkSet);
    }

    private static KeyPair generateRsaKey() {
        KeyPair keyPair;
        try {
            KeyPairGenerator keyPairGenerator = KeyPairGenerator.getInstance("RSA");
            keyPairGenerator.initialize(2048);
            keyPair = keyPairGenerator.generateKeyPair();
        } catch (Exception ex) {
            throw new IllegalStateException(ex);
        }
        return keyPair;
    }

    @Bean
    public JwtDecoder jwtDecoder(JWKSource<SecurityContext> jwkSource) {
        return OAuth2AuthorizationServerConfiguration.jwtDecoder(jwkSource);
    }

    @Bean
    public AuthorizationServerSettings authorizationServerSettings() {
        return AuthorizationServerSettings.builder().issuer("http://127.0.0.1:9000").build();
    }

}
````

**Dónde**

1. `SecurityFilterChain authorizationServerSecurityFilterChain(...)`, este filtro es exclusivo para proteger los
   endpoints del `Authorization Server`, como `/oauth2/token`, `/oauth2/authorize`, etc.
    - Se usa `OAuth2AuthorizationServerConfigurer` para configurar los endpoints.
    - Se habilita `OIDC` con `.oidc(Customizer.withDefaults())`.
    - Redirige a `/login` si el usuario no está autenticado.
    - Se asegura que cualquier request a los endpoints esté autenticada.


2. `SecurityFilterChain defaultSecurityFilterChain(...)`, este es el filtro para el resto de las rutas no manejadas por
   el `Authorzation Server`.
    - Simple: cualquier request requiere autenticación.
    - Se activa `formLogin()` (pantalla de login por defecto de Spring Security).


3. `UserDetailsService `, estamos definiendo temporalmente usuarios que estarán almacenados en
   memoria. Estos usuarios serán usuarios de prueba mientras desarrollamos el servidor de autorización. Recordemos que
   tenemos un `user-service`, precisamente ese servicio será el que más adelante usaremos para la gestión de los
   usuarios.


4. `RegisteredClientRepository`, definimos un `cliente OAuth2` registrado. Es el cliente que va a pedir autorización. En
   este `RegisteredClientRepository` vemos urls definidas, de las cuales:
    - `.redirectUri("http://127.0.0.1:8090/authorized")`, es una url personalizada que debemos crear, dado que el tutor
      del curso lo crea para poder recibir el código de autorización. Sin embargo, en mi caso usaré la url de
      `oauthdebugger.com` para obtener dicho código de autorización.
    - `.redirectUri("https://oauthdebugger.com/debug")`, definimos esta página que nos ayudará a realizar el flujo para
      la obtención del código de autorización.
    - `.postLogoutRedirectUri("http://127.0.0.1:8090/logout")`, es una url personalizada que debemos crear.

   Además, colocamos en `false` el `requireAuthorizationConsent()` para que no pida el consentimiento de los scopes.


5. `JWKSource`, este bean genera un par de llaves `RSA (pública y privada)` para firmar `tokens JWT`. Luego, las
   convierte a formato `JWK` para que el `Authorization Server` pueda publicarlas en su endpoint
   `.well-known/jwks.json`.


6. `generateRsaKey()`, genera la llave `RSA` de `2048 bits`. Es puro Java básico para criptografía.


7. `JwtDecoder`, `Spring Authorization Server` necesita un `JwtDecoder` para validar y decodificar los tokens que emite.
   Aquí lo construyes a partir del `JWKSource`.


8. `AuthorizationServerSettings`, en la configuración del servidor de autorización, he agregado una personalización
   para establecer el `issuer URI` (el identificador del emisor del token). El `AuthorizationServerSettings` es un bean
   que define las configuraciones del servidor de autorización, y por defecto,
   `Spring Security OAuth2 Authorization Server` expone los endpoints estándar como `/oauth2/authorize`,
   `/oauth2/token`, etc. En nuestro caso, he personalizado el `issuer URI`, que es un valor importante en el contexto de
   `JWT (JSON Web Tokens)`. El `issuer` es utilizado por los clientes para identificar la autoridad que ha emitido un
   token y es comúnmente parte de los metadatos de configuración en un servidor de autorización.

Ahora, nos vamos al `gateway-server` y configuramos la ruta hacia nuestro servidor de autorización.

````yml
spring:
  application:
    name: gateway-server
  cloud:
    gateway:
      routes:
        - id: authorization-server-route
          uri: lb://authorization-server
          predicates:
            - Path=/api/v1/authorization-server/**
          filters:
            - RewritePath=/api/v1/authorization-server/(?<path>.*), /$\{path}
````

**Dónde**

- `uri: lb://authorization-server`, esto indica que la solicitud se enviará a un servicio llamado `authorization-server`
  registrado en `Eureka` (porque usamos `lb://`, es decir, `load balancer via discovery`). Debemos asegurarnos de que el
  `spring.application.name` del servidor de autorización lo hayamos definido como `authorization-server`
- `Path=/api/v1/authorization-server/**`, solo las rutas que empiecen con `/api/v1/authorization-server/` serán
  redirigidas al `Authorization Server`.
- `RewritePath`, este filtro elimina el prefijo `/api/v1/authorization-server/` antes de enviar la solicitud al
  `Authorization Server`. Por ejemplo:
    - Petición del cliente: `GET /api/v1/authorization-server/oauth2/token`
    - Se reescribe como: `GET /oauth2/token` (que es lo que espera `Spring Authorization Server`)

## Implementando endpoint /authorized y /logout en Gateway Server

Recordemos que en el `SecurityConfig` del `authorization-server` creamos un bean `RegisteredClientRepository`. Dentro
de este bean definimos las siguientes uris que dijimos, debíamos crear:

- http://127.0.0.1:8090/authorized
- http://127.0.0.1:8090/logout

Entonces, en este apartado implementaremos esas uris en nuestro `gateway-server`, dado que el puerto que definimos
es precisamente el puerto del `gateway-server`.

````java

@RestController
public class AppController {

    @GetMapping(path = "/authorized")
    public ResponseEntity<Map<String, String>> authorized(@RequestParam String code) {
        return ResponseEntity.ok(Collections.singletonMap("code", code));
    }

    @PostMapping(path = "/logout")
    public ResponseEntity<Map<String, String>> logout() {
        return ResponseEntity.ok(Collections.singletonMap("logout", "OK"));
    }
}
````

**Importante**

> Hemos agregado un controlador al `gateway-server` con dos uris `/authorized` y `/logout`. Pero recordemos que en el
> `application.yml` de este `gateway-server` tenemos definidas rutas de microservicios a las que `gateway` redirigirá.
> La pregunta es `¿quién responde primero? ¿Spring Cloud Gateway o Spring WebFlux (Spring Web MVC si fuera Servlet)?`
>
> `Spring Cloud Gateway` primero evalúa las rutas configuradas en el `application.yml` mediante el componente
> `RoutePredicateHandlerMapping`.
> - Si una ruta coincide, el `gateway` maneja la solicitud, es decir, la enruta al microservicio correspondiente, aplica
    filtros, etc.
> - Si ninguna ruta coincide, Spring WebFlux continúa buscando coincidencias entre los `@RestController` definidos en el
    `Gateway` usando el `WebFluxHandlerMapping`.

## Configurando Resource Server y Cliente OAuth2 en yml

Nuestro `gateway-server` va a cumplir dos papeles:

1. Será un `cliente OAuth2` del `authorization-server`, para iniciar el flujo de autenticación del usuario (por ejemplo,
   mediante `spring-security-oauth2-client`). El usuario se podrá loguear y obtener un `access token` que le permitirá
   acceder a los distintos microservicios.


2. También actuará como un `resource server`, encargado de validar el `access token` incluido en las peticiones
   (generalmente mediante un encabezado `Authorization: Bearer <token>`). Para esto, utiliza la configuración del
   `authorization-server` (como el `issuer-uri` o las `JWKs`) para validar que el token sea válido y no haya expirado.
   Esto protege las rutas del gateway y evita que usuarios no autorizados accedan a los microservicios.

⚠️ Importante
> El `gateway` no tiene que llamar al `authorization server` en cada solicitud para validar el token. Es decir,
> no necesita preguntar al `authorization server` en cada solicitud si el token es válido. Porque puede verificar la
> firma localmente usando la clave pública del `authorization server`. Es decir, usa una
> `clave pública (JWK)` publicada por el `authorization-server` para validar localmente la `firma del token JWT`. Esto
> es más eficiente.
>
> El authorization server expone un endpoint JWK (JSON Web Key), normalmente accesible en una URL como:
> `http://localhost:9000/.well-known/jwks.json`
>
> Este endpoint contiene la(s) clave(s) pública(s) necesarias para que cualquier `resource server` pueda verificar
> las firmas de los `JWT` emitidos. Entonces el flow es así:
>
> 🔁 Primera vez que el resource server recibe un token → si no tiene la clave pública, consulta el endpoint JWK y la
> guarda en memoria (caché).
>
> 📦 Después → usa la clave en memoria para validar los siguientes tokens sin tener que llamar otra vez al `authorization
> server`.

Así que iniciamos agregando las siguientes dependencias al `pom.xml` del `gateway-server`.

````xml

<dependencies>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-oauth2-client</artifactId>
    </dependency>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-oauth2-resource-server</artifactId>
    </dependency>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-security</artifactId>
    </dependency>
</dependencies>
````

Luego, vamos al `application.yml` del `gateway-server` para configurar nuestro servidor `gateway` como
`cliente de OAuth2` y como `servidor de recursos`.

````yml

spring:
  application:
    name: gateway-server
  security:
    oauth2:
      resourceserver:
        jwt:
          issuer-uri: http://127.0.0.1:9000
      client:
        registration:
          my-oauth2-client:
            provider: my-auth-server
            client-id: gateway-app
            client-secret: 123456
            authorization-grant-type: authorization_code
            redirect-uri: http://127.0.0.1:8090/authorized
            scope: openid, profile
        provider:
          my-auth-server:
            issuer-uri: http://127.0.0.1:9000
````

Las configuraciones anteriores muestran los dos papeles que estaría cumpliendo nuestro `gateway-server`, veamos uno por
uno.

### 1. Como Resource Server

````yml
spring:
  security:
    oauth2:
      resourceserver:
        jwt:
          issuer-uri: http://127.0.0.1:9000
````

- Esto indica que el `gateway-server` usará `JWT` para validar tokens.
- Spring buscará automáticamente el `JWK Set` en el endpoint `http://127.0.0.1:9000/.well-known/openid-configuration`.
- De ese endpoint obtendrá el `jwks_uri`, por ejemplo `http://127.0.0.1:9000/oauth2/jwks`.
- `Spring` descargará la `clave pública` una sola vez y luego la `cacheará` localmente para `validar los JWT` sin tener
  que llamar al `authorization server` en cada solicitud, justo como mencionamos antes.

### 2. Como OAuth2 Client

````yml
      client:
        registration:
          my-oauth2-client:
            provider: my-auth-server
            client-id: gateway-app
            client-secret: 123456
            authorization-grant-type: authorization_code
            redirect-uri: http://127.0.0.1:8090/authorized
            scope: openid, profile
        provider:
          my-auth-server:
            issuer-uri: http://127.0.0.1:9000
````

- Estamos registrando un cliente llamado `my-oauth2-client` que apunta al `authorization-server`.
- La propiedad `issuer-uri` es clave, ya que a partir de ahí Spring podrá autoconfigurar los endpoints necesarios
  `(/authorize, /token, etc.)`.
- No solo hemos configurado correctamente el `redirect-uri` de acuerdo con lo registrado en el `Authorization Server`
  (en la clase `SecurityConfig`), sino que además coinciden todos los valores clave del cliente: `client-id`,
  `client-secret`, `scopes` y el `authorization-grant-type`.

## Configurando clase Resource Server Security Endpoint

Ahora tenemos que implementar la clase `SecurityConfig` pero por el lado del `gateway-server` donde configuraremos la
protección de las rutas, los endpoints, etc.

**Nota**
> Recordar que nuestro `gateway-server` está trabajando con `programación reactiva`, por lo tanto la configuración será
> teniendo en cuenta ese detalle. Por ejemplo:
>
> En este caso usamos el `SecurityWebFilterChain` que se usa en `Spring WebFlux (Reactive stack)`, donde todo es
> reactivo.
>
> Si nuestro `gateway-server` fuera una aplicación `Spring MVC (Servlet stack)`, como en aplicaciones clásicas con
> Spring Boot, entonces usaríamos `SecurityFilterChain`.

A continuación se muestra la configuración inicial de nuestro `SecurityConfig`.

````java

@Configuration
public class SecurityConfig {

    @Bean
    public SecurityWebFilterChain securityWebFilterChain(ServerHttpSecurity http) {
        http
                .authorizeExchange(authorize -> authorize
                        .pathMatchers("/authorized", "/logout").permitAll()
                        .pathMatchers(HttpMethod.GET, "/api/v1/products", "/api/v1/items", "/api/v1/users").permitAll()
                        .pathMatchers(HttpMethod.GET, "/api/v1/products/{productId}", "/api/v1/items/{productId}", "/api/v1/users/{userId}", "/api/v1/users/username/{username}").hasAnyRole("ADMIN", "USER")
                        .pathMatchers("/api/v1/products/**", "/api/v1/items/**", "/api/v1/users/**").hasRole("ADMIN")
                        .anyExchange().authenticated()
                )
                .cors(ServerHttpSecurity.CorsSpec::disable)
                .securityContextRepository(NoOpServerSecurityContextRepository.getInstance())
                .oauth2Login(Customizer.withDefaults())
                .oauth2Client(Customizer.withDefaults())
                .oauth2ResourceServer(oauth2ResourceServer ->
                        oauth2ResourceServer.jwt(Customizer.withDefaults()));
        return http.build();
    }

}
````

1. Uso de `SecurityWebFilterChain`, esto es completamente correcto porque estamos usando `Spring WebFlux` (por eso es
   `SecurityWebFilterChain` y no `SecurityFilterChain` que es para `Spring MVC`).


2. Permitimos el acceso público a endpoints específicos:
    - `/authorized` y `/logout` → acceso público.
    - `GET` a `/api/v1/products`, `/items`, `/users` → acceso público.
    - `GET` a recursos individuales → restringido a `ROLE_ADMIN` o `ROLE_USER`.
    - Otros métodos `(POST, PUT, DELETE, etc.)` a esos endpoints → restringidos a `ROLE_ADMIN`.


3. Autenticación `OAuth2`:
    - `oauth2Login()` y `oauth2Client()` → esto permite que actúe como `cliente OAuth2`.
    - `oauth2ResourceServer()` → protege las rutas con `tokens JWT`.


4. `CORS` deshabilitado (de momento), por ahora podemos mantenerlo deshabilitado si no tenemos frontend aún. Pero cuando
   lo tengamos, asegurarnos de:
    - Habilitar CORS.
    - Especificar el origen del frontend (por ejemplo http://localhost:4200).
    - Probar llamadas desde el navegador para validar que no haya errores CORS.

5. `.securityContextRepository(NoOpServerSecurityContextRepository.getInstance())`, en aplicaciones reactivas con
   `Spring Security`, no se crean sesiones por defecto como sí pasa con `Spring MVC`. Pero si queremos asegurarnos
   explícitamente de que no se almacene nada en el `SecurityContext` de la sesión, podemos deshabilitarlo con esta
   configuración. Entonces, esta configuración le dice a Spring: *"No almacenes el contexto de seguridad en ningún lado,
   ni en memoria ni en una sesión. Todo debe venir con cada petición (por ejemplo, en el JWT)."*

**Importante: ¿Quién se ejecuta primero, el SecurityConfig o las rutas del gateway?**
> La seguridad se evalúa primero, antes de que el `RoutePredicateHandlerMapping` del `Gateway` intente hacer el
> enrutamiento.
>
> En otras palabras, cuando llega una petición al gateway, por ejemplo: `GET http://localhost:8090/api/v1/users/1`:
>
> 1. `Spring Security` (usando el `SecurityWebFilterChain`) intercepta la petición.
> 2. Evalúa los `pathMatchers()`:
> - En nuestro caso, `/api/v1/users/1` es una ruta protegida.
> - Según la configuración, necesita el rol `ADMIN` o `USER`.
> 3. Si el `token JWT` no está presente o no tiene el rol requerido, la petición es bloqueada ahí mismo (con `401` o
     `403`), y nunca se intenta redirigir al microservicio `user-service`.
> 4. Si pasa la validación de seguridad, entonces sí se evalúa la configuración de enrutamiento (`application.yml`) y la
     petición se reenvía al microservicio correspondiente (usando `lb://user-service`).

**Conclusión**

> Primero evalúa lo configurado en el `SecurityConfig`, y solo si pasa, entonces se intenta hacer match con las rutas
> del `application.yml`.

## Probando implementación del tipo de concesión de código de autorización (Authorization Code Grant Type)

Vamos a ejecutar nuestros microservicios para ver que las configuraciones que hemos realizado hasta ahora estén
funcionando sin problemas. Como solo vamos a hacer pruebas, con el `user-service` sería suficiente, luego sí es
necesario hacer uso del `discovery-server`, `authorization-server` y `gateway-server`.

Levantamos las aplicaciones en el siguiente orden.

- discovery-server
- authorization-server
- user-service
- gateway-server

Como tenemos levantado el `authorization-server` podemos ingresar a una ruta que este servidor nos proporciona como
parte de la especificación de `OAuth 2.1 Authorization Server Metadata`. `Spring Authorization Server` la expone
automáticamente si configuramos correctamente nuestro servidor de autorización.

````bash
http://127.0.0.1:9000/.well-known/oauth-authorization-server
````

Podemos observar que nos retorna un `JSON` con metadatos. Este documento permite a los `clientes OAuth` (como una app
`frontend` o `backend`) descubrir los endpoints del `servidor de autorización`.

![01.png](assets/section-10/01.png)

Del resultado anterior, utilizaremos los siguientes endpoints que nos permitirá realizar el flujo del tipo de concesión
`authentication code`.

````bash
http://127.0.0.1:9000/oauth2/authorize
http://127.0.0.1:9000/oauth2/token
````

### Obteniendo código de autorización

El primer paso para el tipo de concesión `Authorization code` es obtener un `código` que luego lo intercambiaremos por
un `access token`. Entonces, para apoyarnos con el inicio de este flujo utilizaremos la siguiente web
`https://oauthdebugger.com/debug`.

A continuación se muestra marcado en un cuadro rojo, los campos que se ingresaron manualmente. Además, es importante
notar que en el campo `Redirect URI (required)` estamos colocando la misma dirección de esta web
`https://oauthdebugger.com/debug` que es la misma que configuramos en el `SecurityConfig` del `authorization-server`.
Esto es relevante, porque cuando hagamos un `Send Request` la solicitud se enviará a
`http://127.0.0.1:9000/oauth2/authorize` (servidor de autorización) donde se generará el código de autorización. Luego,
el servidor de autorización redireccionará a esta web el código generado.

![02.png](assets/section-10/02.png)

Al hacer clic en `Send Request` y al ser la primera vez que hacemos la solicitud al `authorization-server`, nos pide
que nos autentiquemos. En este caso usamos una de las credenciales almacenadas en memoria dentro del servidor de
autorización.

![03.png](assets/section-10/03.png)

Luego de que la autenticación sea exitosa, el servidor de autorización nos retornará el `Authorization Code` solicitado.

![04.png](assets/section-10/04.png)

### Obteniendo token de acceso

Ese código de autorización lo utilizaremos para solicitar el `access token`.

````bash
$ curl -v -X POST -u gateway-app:123456 -d "grant_type=authorization_code&redirect_uri=https://oauthdebugger.com/debug&code=IoMHnjZoEG0K5zdWwUrW1BgDAPmdKGxtbg4eiusFRVf1TSJpMPZm1X3kzLfCN5xrcVS9jjxdjV-AonDqAh-6drejTw25wlqvkQjmVGuYcA7gqjSUXkjW19n-VprDm-1s" http://localhost:9000/oauth2/token | jq
>
< HTTP/1.1 200
< X-Content-Type-Options: nosniff
< X-XSS-Protection: 0
< Cache-Control: no-cache, no-store, max-age=0, must-revalidate
< Pragma: no-cache
< Expires: 0
< X-Frame-Options: DENY
< Content-Type: application/json;charset=UTF-8
< Transfer-Encoding: chunked
< Date: Mon, 21 Apr 2025 01:39:58 GMT
<
{
  "access_token": "eyJraWQiOiJmYmRhYWNjMC04ZjhkLTRmNDAtODVkYS1kZDU0MGY0OTdkMGQiLCJhbGciOiJSUzI1NiJ9.eyJzdWIiOiJhZG1pbiIsImF1ZCI6ImdhdGV3YXktYXBwIiwibmJmIjoxNzQ1MTk5NTk4LCJzY29wZSI6WyJvcGVuaWQiLCJwcm9maWxlIl0sImlzcyI6Imh0dHA6Ly8xMjcuMC4wLjE6OTAwMCIsImV4cCI6MTc0NTE5OTg5OCwiaWF0IjoxNzQ1MTk5NTk4LCJqdGkiOiJiMGZlMWIwZC0yODAxLTRmMzMtYWZiNi1lMDBmYTEwMWRkMGUifQ.Vq-I9fW5sGBQ_dfdPuNmyruZ96v9-KhUEjHtKdGrtzom8Fz_dQxE5hgUB6CCXREO8zH3arslvxvMRkSARpw4cN0Jz8DY7-s9-tCqcJ7RKhF8s0jcw_KlRcUAQ4X6qlbmZk52taxekF1emsNnq2yMqhQRBWJlZiJA0LMA7sLLHfRRbhNHJBBx7aM0eCJAs9Hy3_OuOGtX-0IfuqjFaaJOGsc1Q34C9Jt4zCtYIoVZ8O82jiNI9qmSxnNzCPWCGDOcs3-zPFYiUpWn64BqkJnhhvplI5RXaYeh9EYq-U66veEg-d5wt3c8ZQRWylOeEbNoWwwQtkYnUOnBbIH_xbEqog",
  "refresh_token": "dVcOL4LjKuFUF3j0SByescHRFjYtH9XOM3eDroiJR-JTtnFEreqW6CkzPqQM2xbcbd1FdzXMEtsr73qzKyxCqvYbnfwAGYJu-rX1uJcH3nQFG2rLDszJ1I7MsqgQZhoO",
  "scope": "openid profile",
  "id_token": "eyJraWQiOiJmYmRhYWNjMC04ZjhkLTRmNDAtODVkYS1kZDU0MGY0OTdkMGQiLCJhbGciOiJSUzI1NiJ9.eyJzdWIiOiJhZG1pbiIsImF1ZCI6ImdhdGV3YXktYXBwIiwiYXpwIjoiZ2F0ZXdheS1hcHAiLCJhdXRoX3RpbWUiOjE3NDUxOTk1NzcsImlzcyI6Imh0dHA6Ly8xMjcuMC4wLjE6OTAwMCIsImV4cCI6MTc0NTIwMTM5OCwiaWF0IjoxNzQ1MTk5NTk4LCJub25jZSI6Imsxa2k1OGVtYWFmIiwianRpIjoiZTM5NGMwMDAtNzZkOC00ZTBiLWE2ODMtNjNjNGQyZjI1ZjE1Iiwic2lkIjoiNWV1Ym51THVvbHlMbWRTM0ZIeHBuZHNyXzJ0Nmw1UFdxb1FfeWY5Y01HcyJ9.LM4heL-I2mR8KF_2nFX-eGs2utgT9p7hJ0Dtld3vaH2mCQgRiEEBSZFYyPz0pU7D1Vz68M6m5wPKCs7F009D48_s8N7v805YC-q_s3TzDbvANesxLAxrU8eM9PrQp3akLo3PzikoDSB9UT70aEXbVj4rj22u0pXbDqabrmuvKoRipvcd5RcSqWGVWZFACm4t-deE7RRtee3A8trZVWbnp_7XNcaFIbFXY2CYcybsZnjPkMoQuk9Emvx72GrOZqT3zgC1jbY4ZVGOrjPxbDhBXe5VH9NF5gMLNA0To10SxNSSI9uZtOTYs7qZQJ7LvgqVWCGbSCpfu8HD2Z1uMH652w",
  "token_type": "Bearer",
  "expires_in": 300
}
````

Si decodificamos el `access token` podemos observar que se corresponde con el usuario con el que iniciamos sesión.

![05.png](assets/section-10/05.png)

Si quisiéramos obtener un `access token` para otro usuario, debemos cerrar sesión ingresando a la siguiente url
`http://127.0.0.1:9000/logout`. Como vemos nos aparece el mensaje `se ha cerrado la sesión`, ahora sí podemos volver a
iniciar sesión con otro usuario.

![06.png](assets/section-10/06.png)

## Autorización basada en Scopes en Spring Security con OAuth2

En una arquitectura basada en microservicios, el uso de `OAuth2` como mecanismo de autenticación y autorización es una
práctica común. Dentro de este contexto, los `scopes` permiten definir granularmente qué recursos o acciones puede
acceder un cliente autenticado. En este apartado explicamos cómo usar `scopes` como autoridades (`SCOPE_x`) en
`Spring Security` dentro de un `gateway reactivo`, siguiendo una implementación real con un servidor de autorización
personalizado.

### ¿Qué son los scopes?

Un `scope` en `OAuth2` representa un nivel de acceso o un permiso que una aplicación cliente puede solicitar durante el
proceso de autorización. Por ejemplo:

1. `Scopes estándar (OpenID Connect)`
    - `openid`, este scope es obligatorio para indicar que la aplicación cliente desea autenticarse mediante
      `OpenID Connect`. Su inclusión permite que se genere un `ID Token`, que contiene información del usuario
      autenticado.
    - `profile`, permite acceder a información básica del perfil del usuario, como name, email, preferred_username, etc.
      Esto depende de cómo configuremos el servidor de autorización y qué claims se devuelvan.

   > Estos scopes están definidos por el estándar OpenID Connect y no deben ser modificados.

2. `Scopes personalizados`
    - `write`, define que el cliente tiene permisos para crear, actualizar o eliminar recursos.
    - `read`, permite al cliente consultar o leer recursos protegidos.

   > Estos scopes no están definidos por el estándar y los creamos nosotros según las necesidades de nuestra aplicación.
   > En este caso, se usan para controlar el acceso a endpoints del gateway con `hasAuthority("SCOPE_write")` o
   > `hasAuthority("SCOPE_read")`.

### ¿De dónde sale el prefijo SCOPE_?

Cuando se utiliza `Spring Security` con un `Resource Server JWT`, los scopes incluidos en el token se mapean
automáticamente como autoridades con el prefijo `SCOPE_`.

`Ejemplo`: Si el token JWT contiene:
> "scope": ["read", "write"]

`Spring Security` los convierte en autoridades:
> SCOPE_read, SCOPE_write

Este comportamiento es interno de `Spring Security` cuando se configura como `oauth2ResourceServer().jwt()`. No
necesitamos hacerlo manualmente.

### [Authorization Server] Modificando nuestro proyecto para trabajar con SCOPE_

En la clase `SecurityConfig` del `authorization-server` vamos a agregar nuestros scopes personalizados `write` y `read`.
Estos scopes estarán en el bean `RegisteredClientRepository`, exactamente definidos en el `RegisteredClient` para el
cliente `gateway-app`. Esto indica que el cliente (`gateway-app`) puede solicitar esos permisos.

````java

@Configuration
public class SecurityConfig {

    /* code */

    @Bean
    public RegisteredClientRepository registeredClientRepository() {
        RegisteredClient oidcClient = RegisteredClient.withId(UUID.randomUUID().toString())
                .clientId("gateway-app")
                .clientSecret("{noop}123456")
                .clientAuthenticationMethod(ClientAuthenticationMethod.CLIENT_SECRET_BASIC)
                .authorizationGrantType(AuthorizationGrantType.AUTHORIZATION_CODE)
                .authorizationGrantType(AuthorizationGrantType.REFRESH_TOKEN)
                .redirectUri("http://127.0.0.1:8090/authorized")
                .redirectUri("https://oauthdebugger.com/debug")
                .postLogoutRedirectUri("http://127.0.0.1:8090/logout")
                .scope(OidcScopes.OPENID)
                .scope(OidcScopes.PROFILE)
                .scope("write")
                .scope("read")
                .clientSettings(ClientSettings.builder().requireAuthorizationConsent(false).build())
                .build();

        return new InMemoryRegisteredClientRepository(oidcClient);
    }

    /* code */
}
````

### [Gateway Server] Modificando nuestro proyecto para trabajar con SCOPE_

En el `application.yml` del `gateway-server` tenemos definido los datos del cliente que está registrado en el servidor
de autorización, por lo que debemos agregar los dos scopes personalizados que definimos (`write` y `read`).
Esto permitirá que, al autenticarnos desde el navegador, el token incluya los scopes `read` y `write`.

````yml
spring:
  application:
    name: gateway-server
  security:
    oauth2:
      resourceserver:
        jwt:
          issuer-uri: http://127.0.0.1:9000
      client:
        registration:
          my-oauth2-client:
            provider: my-auth-server
            client-id: gateway-app
            client-secret: 123456
            authorization-grant-type: authorization_code
            redirect-uri: http://127.0.0.1:8090/authorized
            scope: openid, profile, write, read
        provider:
          my-auth-server:
            issuer-uri: http://127.0.0.1:9000
````

Así mismo, en el `SecurityConfig` del `gateway-server` vamos a modificar los permisos asignados a los endpoints, por lo
que reemplazaremos el uso de `hasRole` / `hasAnyRole` por `hasAuthority` / `hasAnyAuthority` con el prefijo `SCOPE_`, ya
que ahora el control se basa en `scopes` del `token JWT`:

````java

@Configuration
public class SecurityConfig {

    @Bean
    public SecurityWebFilterChain securityWebFilterChain(ServerHttpSecurity http) {
        http
                .authorizeExchange(authorize -> authorize
                        .pathMatchers("/authorized", "/logout").permitAll()
                        .pathMatchers(HttpMethod.GET, "/api/v1/products", "/api/v1/items", "/api/v1/users").permitAll()
                        .pathMatchers(HttpMethod.GET, "/api/v1/products/{productId}", "/api/v1/items/{productId}", "/api/v1/users/{userId}", "/api/v1/users/username/{username}").hasAnyAuthority("SCOPE_write", "SCOPE_read")
                        .pathMatchers("/api/v1/products/**", "/api/v1/items/**", "/api/v1/users/**").hasAuthority("SCOPE_write")
                        .anyExchange().authenticated()
                )
                .cors(ServerHttpSecurity.CorsSpec::disable)
                .securityContextRepository(NoOpServerSecurityContextRepository.getInstance())
                .oauth2Login(Customizer.withDefaults())
                .oauth2Client(Customizer.withDefaults())
                .oauth2ResourceServer(oauth2ResourceServer ->
                        oauth2ResourceServer.jwt(Customizer.withDefaults()));
        return http.build();
    }

}
````

Esto permite que:

- Usuarios con token que tenga `scope: read` puedan acceder a consultas.
- Solo usuarios con `scope: write` puedan realizar modificaciones.

## Probando la autorización basada en Scopes

Levantamos las aplicaciones en el siguiente orden.

- discovery-server
- authorization-server
- user-service
- gateway-server

Ahora, realizamos el mismo flujo que hicimos para obtener un código de autorización. Teniendo en cuenta que debemos
agregar los scopes personalizados tal como se muestra en la imagen.

![07.png](assets/section-10/07.png)

Con el código de autorización solicitamos un `access token`.

````bash
$ curl -v -X POST -u gateway-app:123456 -d "grant_type=authorization_code&redirect_uri=https://oauthdebugger.com/debug&code=GxHdtiGaDFQ8eH_TmAXKAyYNAyoMYTLk7dKdIVDEvO8Uw6qz1UQ8-_cqBT7zJnNvgljWbYhuZoG_aTgWH4XiWlRhcJ7a2FZ1VmchBdpHqT7kf2MSsUJGZzDgROUf9b-n" http://localhost:9000/oauth2/token | jq
>
< HTTP/1.1 200
< X-Content-Type-Options: nosniff
< X-XSS-Protection: 0
< Cache-Control: no-cache, no-store, max-age=0, must-revalidate
< Pragma: no-cache
< Expires: 0
< X-Frame-Options: DENY
< Content-Type: application/json;charset=UTF-8
< Transfer-Encoding: chunked
< Date: Mon, 21 Apr 2025 01:59:18 GMT
<
{
  "access_token": "eyJraWQiOiJiZWVhYzg1Yy0zZjZjLTRhMTAtOTBlYy01ZjRmNDZjZDZmNjAiLCJhbGciOiJSUzI1NiJ9.eyJzdWIiOiJhZG1pbiIsImF1ZCI6ImdhdGV3YXktYXBwIiwibmJmIjoxNzQ1MjAwNzU4LCJzY29wZSI6WyJyZWFkIiwib3BlbmlkIiwicHJvZmlsZSIsIndyaXRlIl0sImlzcyI6Imh0dHA6Ly8xMjcuMC4wLjE6OTAwMCIsImV4cCI6MTc0NTIwMTA1OCwiaWF0IjoxNzQ1MjAwNzU4LCJqdGkiOiIyYWQyMWZjZi02NDFiLTQ4MzctYjlhZi1iMWMzY2JkN2IyZGMifQ.fiZLnzC0pTEQkc0BGiuyS1TQFeE44SgTI8On6wT5Xbw0ds8IA1z4t62vEVFJq3NMLnHrAKKvCfW-jFGVB0GGWH8RzfKlxZwPFknCNBT5QLTFJO_PBG1Dt-06DMvQPkC2qvTk23AlsfArANlp1z-_UYHzAzHlwMXZx9id31XPeL53KxVvL1sVtMzurnK2xoZEZC8smHkhXpASjwsDDseRUrti1CK0m1WhiVbFsp3aaUAXIUt4dGJ1XBHo-LiYuHOo76DSdPd99VBg3QOPLMmvQBfEuNXHhuwPQYYvdU5q2oT-ZgMs8MAVqMH66QSkgPWiuOSIlyScQeWDoMPj0rAuDA",
  "refresh_token": "uCKo3LyxYXLnQQPBWxumICITfBb5VZxCRph4mrwvHJjFW3VjBEhQpT8HUFx7Ww6lDA4mSPA0S8IXWe-07OUGu2cnGxot-JU8DaQqJwHY1QgmXb_rmRlt5_a5HKusZMza",
  "scope": "read openid profile write",
  "id_token": "eyJraWQiOiJiZWVhYzg1Yy0zZjZjLTRhMTAtOTBlYy01ZjRmNDZjZDZmNjAiLCJhbGciOiJSUzI1NiJ9.eyJzdWIiOiJhZG1pbiIsImF1ZCI6ImdhdGV3YXktYXBwIiwiYXpwIjoiZ2F0ZXdheS1hcHAiLCJhdXRoX3RpbWUiOjE3NDUyMDA3NTIsImlzcyI6Imh0dHA6Ly8xMjcuMC4wLjE6OTAwMCIsImV4cCI6MTc0NTIwMjU1OCwiaWF0IjoxNzQ1MjAwNzU4LCJub25jZSI6ImRuajZramVjbThoIiwianRpIjoiZWYxM2ExOWMtMzk0YS00OGZmLWFjNDMtYjYzZDg4NDQyNTYxIiwic2lkIjoiTV9hbzhvczFYN0F5akgzTGRTN1cyOWlmLUVnLU10T04tSHE0NVBtLW5iRSJ9.ejJAVw_HzzxVXaU5HM2Dt3sSVG-O9ZhoXnG0hf2Y0QNqKOtwiSgOTGkC4VwZjUrgq8rdQRKx2_5NXLzVdn4Bevxj2oBgFLeefvIasmcM0aSsQhTdoaeWm_NyHWFeO8fYAZu1oNjvmTiVMX7uFGEv7_qVImn9tcyUKv4Phr3ziY43uFwaePRrcgVIIK8zK4PdURNnrnIiQKxv0SFHmZvV2shPQjj4nY9dwGeDP1nnt0cD9M_Ua6lMiA5JFhpl4qI-MrGhpePDbNQptd3bOqoFmFf2aaHsYmc3-PXp6qW0FXiCe93CVrovCQEsQDXT3q9c0KugTXxlqixe15OukQxntg",
  "token_type": "Bearer",
  "expires_in": 300
}
````

Si decodificamos el `access token`, vemos que nuestros scopes personalizados fueron agregados.

![08.png](assets/section-10/08.png)

Ahora, realizamos una petición a un endpoint protegido por el `SCOPE_write` enviándole el `access token` en las
cabeceras.

````bash
$ curl -v -H "Authorization: Bearer eyJraWQiOiJiZWVhYzg1Yy0zZjZjLTRhMTAtOTBlYy01ZjRmNDZjZDZmNjAiLCJhbGciOiJSUzI1NiJ9.eyJzdWIiOiJhZG1pbiIsImF1ZCI6ImdhdGV3YXktYXBwIiwibmJmIjoxNzQ1MjAwNzU4LCJzY29wZSI6WyJyZWFkIiwib3BlbmlkIiwicHJvZmlsZSIsIndyaXRlIl0sImlzcyI6Imh0dHA6Ly8xMjcuMC4wLjE6OTAwMCIsImV4cCI6MTc0NTIwMTA1OCwiaWF0IjoxNzQ1MjAwNzU4LCJqdGkiOiIyYWQyMWZjZi02NDFiLTQ4MzctYjlhZi1iMWMzY2JkN2IyZGMifQ.fiZLnzC0pTEQkc0BGiuyS1TQFeE44SgTI8On6wT5Xbw0ds8IA1z4t62vEVFJq3NMLnHrAKKvCfW-jFGVB0GGWH8RzfKlxZwPFknCNBT5QLTFJO_PBG1Dt-06DMvQPkC2qvTk23AlsfArANlp1z-_UYHzAzHlwMXZx9id31XPeL53KxVvL1sVtMzurnK2xoZEZC8smHkhXpASjwsDDseRUrti1CK0m1WhiVbFsp3aaUAXIUt4dGJ1XBHo-LiYuHOo76DSdPd99VBg3QOPLMmvQBfEuNXHhuwPQYYvdU5q2oT-ZgMs8MAVqMH66QSkgPWiuOSIlyScQeWDoMPj0rAuDA" http://localhost:8090/api/v1/users/1 | jq
>
< HTTP/1.1 200 OK
< transfer-encoding: chunked
< Content-Type: application/json
< Date: Mon, 21 Apr 2025 02:01:01 GMT
< token-response: 123456
< Cache-Control: no-cache, no-store, max-age=0, must-revalidate
< Pragma: no-cache
< Expires: 0
< X-Content-Type-Options: nosniff
< X-Frame-Options: DENY
< X-XSS-Protection: 0
< Referrer-Policy: no-referrer
< set-cookie: color=red
<
{
  "id": 1,
  "username": "admin",
  "enabled": true,
  "email": "admin@gmail.com",
  "roles": [
    {
      "id": 2,
      "name": "ROLE_USER"
    },
    {
      "id": 1,
      "name": "ROLE_ADMIN"
    }
  ]
}
````

## Eliminando scopes personalizados

En el apartado anterior *Autorización basada en Scopes en Spring Security con OAuth2* realizamos algunos cambios para
trabajar con el `SCOPE_`, pero ese apartado fue solo para ver cómo trabajar con `scopes`. Ahora, en los siguientes
apartados continuaremos trabajando con roles, pero para eso dejaremos limpio los cambios que realizamos anteriormente.

En primer lugar, en el `SecurityConfig` del `authorization-server` vamos a quitar los scopes personalizados que
agregamos dejando únicamente los scopes que vienen por defecto `openid` y `profile`.

````java

@Configuration
public class SecurityConfig {
    /* code */
    @Bean
    public RegisteredClientRepository registeredClientRepository() {
        RegisteredClient oidcClient = RegisteredClient.withId(UUID.randomUUID().toString())
                .clientId("gateway-app")
                .clientSecret("{noop}123456")
                .clientAuthenticationMethod(ClientAuthenticationMethod.CLIENT_SECRET_BASIC)
                .authorizationGrantType(AuthorizationGrantType.AUTHORIZATION_CODE)
                .authorizationGrantType(AuthorizationGrantType.REFRESH_TOKEN)
                .redirectUri("http://127.0.0.1:8090/authorized")
                .redirectUri("https://oauthdebugger.com/debug")
                .postLogoutRedirectUri("http://127.0.0.1:8090/logout")
                .scope(OidcScopes.OPENID)
                .scope(OidcScopes.PROFILE)
                .clientSettings(ClientSettings.builder().requireAuthorizationConsent(false).build())
                .build();

        return new InMemoryRegisteredClientRepository(oidcClient);
    }
    /* code */
}
````

Luego, en el `application.yml` del `gateway-server` haremos lo mismo.

````yml
spring:
  application:
    name: gateway-server
  security:
    oauth2:
      resourceserver:
        jwt:
          issuer-uri: http://127.0.0.1:9000
      client:
        registration:
          my-oauth2-client:
            provider: my-auth-server
            client-id: gateway-app
            client-secret: 123456
            authorization-grant-type: authorization_code
            redirect-uri: http://127.0.0.1:8090/authorized
            scope: openid, profile
        provider:
          my-auth-server:
            issuer-uri: http://127.0.0.1:9000
````

## Registrando los claims roles al JWT

En este apartado implementaremos los `roles` en `Spring Security`, los cuales utilizan el prefijo `ROLE_`. Recordemos
que en los apartados anteriores trabajamos con los scopes (`SCOPE_`) del servidor de autorización, los cuales están más
orientados al `cliente OAuth`, en nuestro caso al `client-id: gateway-app`. En cambio, los roles (`ROLE_`) están más
relacionados con los permisos asignados a los usuarios, definiendo qué recursos pueden acceder según su rol dentro
del sistema.

Como primer paso, realizaremos una modificación en el `SecurityConfig` del `authorization-server`. En esta
etapa, personalizamos el `JWT` emitido por el `Authorization Server` para incluir los `roles del usuario` como `claims`
personalizados. Esto nos permitirá luego usar `hasRole("...")` o `hasAnyRole("...")` en el `Gateway Server`
para aplicar reglas de seguridad basadas en `roles`, no solo en scopes.

Entonces, como cambio, agregamos el siguiente `@Bean` en la clase `SecurityConfig` del `Authorization Server`:

````java

@Configuration
public class SecurityConfig {

    /* code */

    @Bean
    public OAuth2TokenCustomizer<JwtEncodingContext> tokenCustomizer() {
        return context -> {
            Authentication principal = context.getPrincipal();
            Set<String> roles = principal.getAuthorities().stream()
                    .map(GrantedAuthority::getAuthority)
                    .collect(Collectors.toSet());

            if (context.getTokenType().getValue().equals("access_token")) {
                context.getClaims()
                        .claim("roles", roles)
                        .claim("token_type", "Access Token")
                        .build();
            }

            if (context.getTokenType().getValue().equals("id_token")) {
                context.getClaims()
                        .claim("roles", roles)
                        .claim("token_type", "Id Token")
                        .build();
            }
        };
    }

}
````

### ¿Qué hace este bean?

- Este `OAuth2TokenCustomizer<JwtEncodingContext>` permite modificar el contenido del `JWT` antes de que se firme y
  entregue al cliente.
- Extrae los roles del usuario autenticado (`GrantedAuthority`) y los inserta como un claim llamado `roles` en el
  `access_token` y el `id_token`.
- También agrega un `claim adicional` llamado `token_type` solo con fines informativos.

### Resultado

Una vez emitido el token, el `payload` de por ejemplo el `access_token` incluiría algo así.

````json
{
  "sub": "admin",
  "roles": [
    "ROLE_ADMIN",
    "ROLE_USER"
  ],
  "token_type": "Access Token"
}
````

Como segundo paso, en el `SecurityConfig` del `gateway-server` realizamos modificaciones al `SecurityWebFilterChain`.
Este cambio es clave para que el `Gateway Server` pueda interpretar correctamente los `roles` enviados en el `JWT`, y
así aplicar seguridad con `hasRole(...)` / `hasAnyRole(...)`.

Luego de haber agregado el `claim "roles"` en el `JWT` desde el `Authorization Server`, ahora debemos configurar el
`Gateway Server` para:

1. Leer ese claim `roles` del `JWT` recibido.
2. Convertir cada rol en una `GrantedAuthority` válida.
3. Usar `hasRole(...)` o `hasAnyRole(...)` en la configuración de seguridad.

En el `SecurityConfig` del `Gateway Server`, personalizamos el comportamiento del `JwtAuthenticationConverter` dentro
del `oauth2ResourceServer`.

````java

@Configuration
public class SecurityConfig {

    @Bean
    public SecurityWebFilterChain securityWebFilterChain(ServerHttpSecurity http) {
        http
                .authorizeExchange(authorize -> authorize
                        .pathMatchers("/authorized", "/logout").permitAll()
                        .pathMatchers(HttpMethod.GET, "/api/v1/products", "/api/v1/items", "/api/v1/users").permitAll()
                        .pathMatchers(HttpMethod.GET, "/api/v1/products/{productId}", "/api/v1/items/{productId}", "/api/v1/users/{userId}", "/api/v1/users/username/{username}").hasAnyRole("ADMIN", "USER")
                        .pathMatchers("/api/v1/products/**", "/api/v1/items/**", "/api/v1/users/**").hasRole("ADMIN")
                        .anyExchange().authenticated()
                )
                .cors(ServerHttpSecurity.CorsSpec::disable)
                .securityContextRepository(NoOpServerSecurityContextRepository.getInstance())
                .oauth2Login(Customizer.withDefaults())
                .oauth2Client(Customizer.withDefaults())
                .oauth2ResourceServer(oauth2ResourceServer ->
                        oauth2ResourceServer.jwt(jwt -> {
                            jwt.jwtAuthenticationConverter(source -> {
                                Collection<String> roles = source.getClaimAsStringList("roles");

                                Collection<GrantedAuthority> authorities = roles.stream()
                                        .map(SimpleGrantedAuthority::new)
                                        .collect(Collectors.toSet());

                                return Mono.just(new JwtAuthenticationToken(source, authorities));
                            });
                        }));
        return http.build();
    }

}
````

Lo que hace esta modificación es:

- Lee el claim `roles` que viene en el JWT (por ejemplo: `["ROLE_USER", "ROLE_ADMIN"]`).
- Convierte cada rol en una `SimpleGrantedAuthority`.
- Asocia esas autoridades al `JwtAuthenticationToken` para que puedan ser usadas con `hasRole(...)` o `hasAnyRole(...)`.

Ahora, gracias a esa conversión de roles, se puede proteger rutas usando `hasRole` y `hasAnyRole`, tal como lo hicimos
anteriormente.

````bash
.pathMatchers(HttpMethod.GET, "/api/v1/products/{productId}", ...).hasAnyRole("ADMIN", "USER")
.pathMatchers("/api/v1/products/**", ...).hasRole("ADMIN")
````

> `⚠️ Importante`: No es necesario anteponer `ROLE_` en el `hasRole(...)`, ya que `Spring Security` internamente lo
> añade. Por ejemplo, `hasRole("ADMIN")` busca la autoridad `ROLE_ADMIN`.

### ¿Qué pasaría si no personalizamos el `jwtAuthenticationConverter` en el `Gateway Server`?

Aunque el `Authorization Server` agregue correctamente el claim `roles` al `token JWT`, `Spring Security` no sabrá cómo
interpretar ese claim a menos que tú se lo indiques explícitamente.

Por defecto:

- `Spring Security` espera que las autoridades (roles o scopes) vengan en el `claim "scope"` (como `SCOPE_read`,
  `SCOPE_write`), o en `authorities` si es una aplicación personalizada.
- No analiza automáticamente un claim llamado "roles" a menos que lo configures.

🔴 Sin el `jwtAuthenticationConverter` personalizado:

- El Gateway no extraerá los roles desde el claim `roles`.
- El `Authentication` generado no tendrá ninguna `GrantedAuthority` como `ROLE_ADMIN` o `ROLE_USER`.
- Como consecuencia, todas las rutas que dependan de `.hasRole(...)` o `.hasAnyRole(...)` fallarán con un
  `403 Forbidden`, incluso si el token tiene correctamente el claim `roles`.

🟢 Con el `jwtAuthenticationConverter` personalizado:

- Se extraen los valores del claim `roles` y se convierten en `GrantedAuthority` (por ejemplo, `ROLE_ADMIN`).
- Entonces, las verificaciones con `.hasRole("ADMIN")` funcionan correctamente.

## Probando roles en jwt

Levantamos las aplicaciones en el siguiente orden.

- discovery-server
- authorization-server
- user-service
- gateway-server

Ahora, realizamos el mismo flujo que hicimos para obtener un código de autorización utilizando la página
[OAuth 2.0 Debugger](https://oauthdebugger.com/debug). Teniendo en cuenta que los scopes volverán a ser únicamente
`openid` y `profile`.

![09.png](assets/section-10/09.png)

Con el código de autorización obtenido, realizamos una petición para obtener el `access token`. Es importante precisar
que al momento de obtener el código de autorización nos logueamos con el usuario `ADMIN`.

````bash
$ curl -v -X POST -u gateway-app:123456 -d "grant_type=authorization_code&redirect_uri=https://oauthdebugger.com/debug&code=xv6kAg_WgHiATsJ5LDHnnAzLp8ExLUOfMBck1kXOOTqydp52c94qCyUYOCBCyAzioF_AqxXfju48RGCiJzYk0JCHrkZnxoRtKykTl4sPsJgmhh3tc0-a9t4zcj8DVCs1" http://localhost:9000/oauth2/token | jq
>
< HTTP/1.1 200
< X-Content-Type-Options: nosniff
< X-XSS-Protection: 0
< Cache-Control: no-cache, no-store, max-age=0, must-revalidate
< Pragma: no-cache
< Expires: 0
< X-Frame-Options: DENY
< Content-Type: application/json;charset=UTF-8
< Transfer-Encoding: chunked
< Date: Mon, 21 Apr 2025 16:33:56 GMT
<
{
  "access_token": "eyJraWQiOiJjZWIxNDNjOS03OTJhLTRkMTctOTI3OC04MGM0ZDY0MjVhNWIiLCJhbGciOiJSUzI1NiJ9.eyJzdWIiOiJhZG1pbiIsImF1ZCI6ImdhdGV3YXktYXBwIiwibmJmIjoxNzQ1MjUzMjM2LCJzY29wZSI6WyJvcGVuaWQiLCJwcm9maWxlIl0sInJvbGVzIjpbIlJPTEVfVVNFUiIsIlJPTEVfQURNSU4iXSwiaXNzIjoiaHR0cDovLzEyNy4wLjAuMTo5MDAwIiwiZXhwIjoxNzQ1MjUzNTM2LCJ0b2tlbl90eXBlIjoiQWNjZXNzIFRva2VuIiwiaWF0IjoxNzQ1MjUzMjM2LCJqdGkiOiJlZWRmNDA4Ny03YWU2LTQyMGYtYWI0NS0yNDM1NDFiZmJlN2QifQ.GIIiXrdRDv9yATtlygoZGK_-6CGat-LAxx58lrehUpRX7OtllVxFy1iORkKPHypDTc81fs-unB4lSiafsxT8rT2KfBg_JQ5Hk7pCcHKd5scC0wx88VAVjzv66yNYpGGNVu9OySDdjTJ9ATjm-pplnRFq9Ay6qk7mb8cpw9LPHYymAJPawjXO5bcaHvaIhm6CLyFnnTHKvknd9wW5ZIh_YOTEg62oCokkRXepoCuIrw_QG2XBqfEoDFYOKx_isxKD0URCoOJsI57qUK-vyOBPUKdqPshscT-MjJkeEh_QyIPFmzhA75wnfEeK5OhcZ8JNVgy6dDRQ_FVkpOWqhg89Pg",
  "refresh_token": "EpfBqhhi_jFpbQI_sIQjqrHuKUBMiVGSYSJ3dtiQmkdjyfk-Ua4mMuWZH8_YYnXJvyDHZFMFISTuFGHT3_DThBmK9aWFFUlDOEp104GHoQGEgTn1rKmxyhJ5XhEI4K6H",
  "scope": "openid profile",
  "id_token": "eyJraWQiOiJjZWIxNDNjOS03OTJhLTRkMTctOTI3OC04MGM0ZDY0MjVhNWIiLCJhbGciOiJSUzI1NiJ9.eyJzdWIiOiJhZG1pbiIsImF1ZCI6ImdhdGV3YXktYXBwIiwiYXpwIjoiZ2F0ZXdheS1hcHAiLCJhdXRoX3RpbWUiOjE3NDUyNTMyMzIsInJvbGVzIjpbIlJPTEVfVVNFUiIsIlJPTEVfQURNSU4iXSwiaXNzIjoiaHR0cDovLzEyNy4wLjAuMTo5MDAwIiwiZXhwIjoxNzQ1MjU1MDM2LCJ0b2tlbl90eXBlIjoiSWQgVG9rZW4iLCJpYXQiOjE3NDUyNTMyMzYsIm5vbmNlIjoia2YwMG02bzI0eGEiLCJqdGkiOiJmZTlmMmY4Mi1lOGRhLTQ1YzMtYTkxYi0wOTUzMzg0MmZlMmUiLCJzaWQiOiI2NFF2TnMtbGJIQlhjTFl6N0VMcmNGZ1U3MWp6OF9ldi15UENFbzFYOTU4In0.B4nOOKMX__DkFx-rHoUnIBSS2roU6UTdA_qaHzhlBkRgmaaMGzblRCvrN72c_qQeXCMLH0IcJUGlnXoss-LjPhMkp-gqZLL4esFnDYQUgBuy4KYXMLdZ6qgm_FZPu8G1OCU55GSZPMVGoEyaUivO1I8EGA9nBnjuFNIrOYO0GeX_PLx9NQsZjsP5TPoZgQZ734ZxqOCQNI6TUPyCZNlHUNWaT9Zv9ZDwf5BNeyt264jnaIIWkbNm1dipukMoIpsc0kvF__YQ8ahaI-zBn4Fg8NBkje1wUxntbakGJuaX2-8p3rGQLPInSEzav_w04Um9_5smcL2StQC-PrgWKxFW0A",
  "token_type": "Bearer",
  "expires_in": 300
}
````

Si decodificamos el `access_token` podemos ver que nuestros roles se han agregado correctamente.

![10.png](assets/section-10/10.png)

Con el access token podemos realizar una petición a uno de nuestros endpoints protegidos.

````bash
$ curl -v -H "Authorization: Bearer eyJraWQiOiJjZWIxNDNjOS03OTJhLTRkMTctOTI3OC04MGM0ZDY0MjVhNWIiLCJhbGciOiJSUzI1NiJ9.eyJzdWIiOiJhZG1pbiIsImF1ZCI6ImdhdGV3YXktYXBwIiwibmJmIjoxNzQ1MjUzMjM2LCJzY29wZSI6WyJvcGVuaWQiLCJwcm9maWxlIl0sInJvbGVzIjpbIlJPTEVfVVNFUiIsIlJPTEVfQURNSU4iXSwiaXNzIjoiaHR0cDovLzEyNy4wLjAuMTo5MDAwIiwiZXhwIjoxNzQ1MjUzNTM2LCJ0b2tlbl90eXBlIjoiQWNjZXNzIFRva2VuIiwiaWF0IjoxNzQ1MjUzMjM2LCJqdGkiOiJlZWRmNDA4Ny03YWU2LTQyMGYtYWI0NS0yNDM1NDFiZmJlN2QifQ.GIIiXrdRDv9yATtlygoZGK_-6CGat-LAxx58lrehUpRX7OtllVxFy1iORkKPHypDTc81fs-unB4lSiafsxT8rT2KfBg_JQ5Hk7pCcHKd5scC0wx88VAVjzv66yNYpGGNVu9OySDdjTJ9ATjm-pplnRFq9Ay6qk7mb8cpw9LPHYymAJPawjXO5bcaHvaIhm6CLyFnnTHKvknd9wW5ZIh_YOTEg62oCokkRXepoCuIrw_QG2XBqfEoDFYOKx_isxKD0URCoOJsI57qUK-vyOBPUKdqPshscT-MjJkeEh_QyIPFmzhA75wnfEeK5OhcZ8JNVgy6dDRQ_FVkpOWqhg89Pg" http://localhost:8090/api/v1/users/1 | jq
>
< HTTP/1.1 200 OK
< transfer-encoding: chunked
< Content-Type: application/json
< Date: Mon, 21 Apr 2025 16:34:18 GMT
< token-response: 123456
< Cache-Control: no-cache, no-store, max-age=0, must-revalidate
< Pragma: no-cache
< Expires: 0
< X-Content-Type-Options: nosniff
< X-Frame-Options: DENY
< X-XSS-Protection: 0
< Referrer-Policy: no-referrer
< set-cookie: color=red
<
{
  "id": 1,
  "username": "admin",
  "enabled": true,
  "email": "admin@gmail.com",
  "roles": [
    {
      "id": 2,
      "name": "ROLE_USER"
    },
    {
      "id": 1,
      "name": "ROLE_ADMIN"
    }
  ]
}
````

## Configurando PasswordEncoder y RestClient

Iniciaremos agregando una configuración personalizada al `application.yml` del `authorization-server`. Esa configuración
lo utilizaremos en el `RestClient` para poder comunicarnos con el `user-service`.

````yml
custom:
  base-url:
    user-service: lb://user-service/api/v1/users
````

En este mismo servidor agregaremos una clase de configuración donde inyectamos la configuración anterior y además,
definimos dos beans.

````java

@Configuration
public class AuthConfig {

    @Value("${custom.base-url.user-service}")
    private String userServiceBaseUrl;

    @LoadBalanced
    @Bean(name = "userRestClient")
    public RestClient.Builder restClientBuilder() {
        return RestClient.builder().baseUrl(this.userServiceBaseUrl);
    }

    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }
}
````

Hasta este punto hemos estado trabajando con dos usuarios registrados en memoria dentro del `authorization-server`,
esto lo podemos ver en el `SecurityConfig` en el siguiente bean.

````java

@Bean
public UserDetailsService userDetailsService() {
    UserDetails admin = User.builder()
            .username("admin")
            .password("{noop}123456")
            .roles("USER", "ADMIN")
            .build();

    UserDetails martin = User.builder()
            .username("martin")
            .password("{noop}123456")
            .roles("USER")
            .build();

    return new InMemoryUserDetailsManager(admin, martin);
}
````

En los siguientes apartados estaremos trabajando con los usuarios que tenemos registrados en el `user-service`, así que
el código anterior lo podemos eliminar.

Por otro lado, en este mismo archivo `SecurityConfig` del `authorization-server` inyectamos el `PasswordEncoder` para
hashear la contraseña del cliente que registremos en OAuth.

````java

@RequiredArgsConstructor
@Configuration
public class SecurityConfig {

    private final PasswordEncoder passwordEncoder;

    /* code */

    @Bean
    public RegisteredClientRepository registeredClientRepository() {
        RegisteredClient oidcClient = RegisteredClient.withId(UUID.randomUUID().toString())
                .clientId("gateway-app")
                .clientSecret(this.passwordEncoder.encode("123456"))
                .clientAuthenticationMethod(ClientAuthenticationMethod.CLIENT_SECRET_BASIC)
                .authorizationGrantType(AuthorizationGrantType.AUTHORIZATION_CODE)
                .authorizationGrantType(AuthorizationGrantType.REFRESH_TOKEN)
                .redirectUri("http://127.0.0.1:8090/authorized")
                .redirectUri("https://oauthdebugger.com/debug")
                .postLogoutRedirectUri("http://127.0.0.1:8090/logout")
                .scope(OidcScopes.OPENID)
                .scope(OidcScopes.PROFILE)
                .clientSettings(ClientSettings.builder().requireAuthorizationConsent(false).build())
                .build();

        return new InMemoryRegisteredClientRepository(oidcClient);
    }

    /* code */
}
````

Finalmente, como adelanto de lo que veremos en el siguiente apartado vamos a crear una clase de servicio que implemente
el `UserDetailsService` de `Spring Security`.

````java

@Slf4j
@Service
public class UserServiceImpl implements UserDetailsService {

    private final RestClient userRestClient;

    public UserServiceImpl(@Qualifier("userRestClient") RestClient.Builder restClientBuilder) {
        this.userRestClient = restClientBuilder.build();
    }

    @Override
    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {
        return null;
    }
}
````

## Implementando UserDetailsService para login con el microservicio user

Lo primero que haremos será agregar el `password` como parte de la respuesta que nos brinda el endpoint que
consultaremos en el `user-service`.

````java
public record UserResponse(Long id,
                           String username,
                           String password,
                           boolean enabled,
                           String email,
                           Set<RoleResponse> roles) {
}
````

Luego, en el mapper del `user-service` también debemos realizar la modificación para agregar el password proveniente
de la entidad User.

````java

@RequiredArgsConstructor
@Component
public class UserMapper {

    private final PasswordEncoder passwordEncoder;

    public UserResponse toUserResponse(User user) {
        Set<RoleResponse> rolesResponse = user.getRoles().stream()
                .map(role -> new RoleResponse(role.getId(), role.getName()))
                .collect(Collectors.toSet());
        return new UserResponse(user.getId(), user.getUsername(), user.getPassword(), user.isEnabled(), user.getEmail(), rolesResponse);
    }
    /* code */
}
````

Antes de realizar la implementación del `UserDetailsService` en el `authorization-service`, necesitamos agregar algunas
clases de utilidad, modelos, constantes, etc. adicionales.

````java

@UtilityClass
public class AuthConstant {
    public static final String NO_FOUND_MESSAGE = "Login error. The user with id %s does not exist in user-service";
    public static final String COMMUNICATION_MESSAGE = "An error occurred in the user-service: %s";
}
````

````java
public class CommunicationException extends RuntimeException {
    public CommunicationException(String message) {
        super(message);
    }
}
````

````java
public record ErrorResponse(int status,
                            String error,
                            String message,
                            String path) {
    @JsonProperty
    public LocalDateTime timestamp() {
        return LocalDateTime.now().truncatedTo(ChronoUnit.SECONDS);
    }
}
````

````java

@RestControllerAdvice
public class GlobalExceptionHandler {

    @ExceptionHandler({NoSuchElementException.class, UsernameNotFoundException.class})
    public ResponseEntity<ErrorResponse> apiException(NoSuchElementException exception, HttpServletRequest request) {
        ErrorResponse error = new ErrorResponse(HttpStatus.NOT_FOUND.value(), HttpStatus.NOT_FOUND.getReasonPhrase(), exception.getMessage(), request.getRequestURI());
        return new ResponseEntity<>(error, HttpStatus.NOT_FOUND);
    }

    @ExceptionHandler(CommunicationException.class)
    public ResponseEntity<ErrorResponse> apiException(CommunicationException exception, HttpServletRequest request) {
        ErrorResponse error = new ErrorResponse(HttpStatus.INTERNAL_SERVER_ERROR.value(), HttpStatus.INTERNAL_SERVER_ERROR.getReasonPhrase(), exception.getMessage(), request.getRequestURI());
        return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(error);
    }

    @ExceptionHandler(Exception.class)
    public ResponseEntity<ErrorResponse> apiException(Exception exception, HttpServletRequest request) {
        ErrorResponse error = new ErrorResponse(HttpStatus.INTERNAL_SERVER_ERROR.value(), HttpStatus.INTERNAL_SERVER_ERROR.getReasonPhrase(), exception.getMessage(), request.getRequestURI());
        return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(error);
    }
}
````

````java

@UtilityClass
public class Util {
    public static String readInputStream(InputStream inputStream) throws IOException {
        try (BufferedReader reader = new BufferedReader(new InputStreamReader(inputStream))) {
            StringBuilder stringBuilder = new StringBuilder();
            String line;
            while ((line = reader.readLine()) != null) {
                stringBuilder.append(line);
            }
            return stringBuilder.toString();
        }
    }
}
````

Finalmente, definimos nuestras clases dtos `Role` y `User` que nos permitirá mapear la respuesta que nos retorna el
`user-service`.

````java
public record Role(Long id,
                   String name) {
}
````

````java
public record User(Long id,
                   String username,
                   String password,
                   boolean enabled,
                   String email,
                   Set<Role> roles) {
}
````

Finalizaremos este apartado realizando la implementación del `UserDetailsService`.

````java

@Service
public class UserServiceImpl implements UserDetailsService {

    private final RestClient userRestClient;

    public UserServiceImpl(@Qualifier("userRestClient") RestClient.Builder restClientBuilder) {
        this.userRestClient = restClientBuilder.build();
    }

    @Override
    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {
        User user = this.userRestClient.get()
                .uri("/username/{username}", username)
                .exchange((request, response) -> {
                    HttpStatusCode statusCode = response.getStatusCode();
                    if (statusCode == HttpStatus.OK) {
                        return response.bodyTo(User.class);
                    }

                    if (statusCode == HttpStatus.NOT_FOUND) {
                        throw new UsernameNotFoundException(AuthConstant.NO_FOUND_MESSAGE.formatted(username));
                    }

                    String bodyMessage = Util.readInputStream(response.getBody());
                    throw new CommunicationException(AuthConstant.COMMUNICATION_MESSAGE.formatted(bodyMessage));
                });

        Set<GrantedAuthority> authorities = user.roles().stream()
                .map(role -> new SimpleGrantedAuthority(role.name()))
                .collect(Collectors.toSet());

        return new org.springframework.security.core.userdetails.User(user.username(), user.password(), user.enabled(), true, true, true, authorities);
    }
}
````

## Probando implementación del UserDetailsService

Levantamos las aplicaciones en el siguiente orden.

- discovery-server
- authorization-server
- user-service
- gateway-server

Ahora, realizamos el mismo flujo que hicimos para obtener un código de autorización utilizando la página
[OAuth 2.0 Debugger](https://oauthdebugger.com/debug). En este punto, seremos redireccionados al servidor de
autorización para loguearnos. Aquí utilizaremos uno de los usuarios registrados en la base de datos del `user-service`,
en nuestro caso usaremos el usuario `admin`.

Con el código de autorización obtenido, realizamos una petición para obtener el `access token`.

````bash
$ curl -v -X POST -u gateway-app:123456 -d "grant_type=authorization_code&redirect_uri=https://oauthdebugger.com/debug&code=yQWwmHS9Kisc8EjDo-GRPQw1AxfX9LTsT3gvVb-5nGYy9qUgAIGFMDBo-tKNRiX8inowW0p0ZNTJT4qBt-FanQriTZwSyvcg4LD4NWDBEbKip2DaurJbjtP8AjQ6zsXy" http://localhost:9000/oauth2/token | jq
>
< HTTP/1.1 200
< X-Content-Type-Options: nosniff
< X-XSS-Protection: 0
< Cache-Control: no-cache, no-store, max-age=0, must-revalidate
< Pragma: no-cache
< Expires: 0
< X-Frame-Options: DENY
< Content-Type: application/json;charset=UTF-8
< Transfer-Encoding: chunked
< Date: Mon, 21 Apr 2025 20:11:43 GMT
<
{
  "access_token": "eyJraWQiOiJlODEwZDMwYi0wMTUwLTQ5MjUtYmE4YS1lNDIyMGY0Y2IwMDQiLCJhbGciOiJSUzI1NiJ9.eyJzdWIiOiJhZG1pbiIsImF1ZCI6ImdhdGV3YXktYXBwIiwibmJmIjoxNzQ1MjY2MzAzLCJzY29wZSI6WyJvcGVuaWQiLCJwcm9maWxlIl0sInJvbGVzIjpbIlJPTEVfVVNFUiIsIlJPTEVfQURNSU4iXSwiaXNzIjoiaHR0cDovLzEyNy4wLjAuMTo5MDAwIiwiZXhwIjoxNzQ1MjY2NjAzLCJ0b2tlbl90eXBlIjoiQWNjZXNzIFRva2VuIiwiaWF0IjoxNzQ1MjY2MzAzLCJqdGkiOiIyNjU1NjczNi02Nzc3LTQ2OTktYjY0ZC02MTZjZDc0MzQ0YTIifQ.AH-1J4m-wsiZwzbNqg3Idm_Zk6UE99WhSbe8C-vDDDBL5-zY_lfTJe8thUey1sid6ej-z0h0AxGNQp0vmNB_IFLj0V9oIvKBqlU6758qYiBvt_eb9jOk-O46I5KZdLDP8zMqs3P20H_Dr7oaMbp9BYR8Jal-hPpgrfNrg9v-tACLslMA1wdk6DQgeS53tbASqOLU4KJFbcUed0FspB5jeXzHoKL89FoCDuS-B0A_bPLagm7-AnFifIypfvygLgJmu2CcyM_e7B53MFNcIOemzMOaLW7mP3TYA0wqDUQjFS4HaJmtbsYtOKxiYzgnDQdx-wQEWpqbBHscyXou46AheQ",
  "refresh_token": "XUDY9AM6a8TMij62Vd0RcjqxX3IzvqiFNi-mDUreToRxYpzQk0XvSm4OmnHCCBegxjXVia98DktVOYBkskH7A4SrUU7ppgS23Dt-UW9BpI8ojtOw_FPHkuyc1GEZFU_z",
  "scope": "openid profile",
  "id_token": "eyJraWQiOiJlODEwZDMwYi0wMTUwLTQ5MjUtYmE4YS1lNDIyMGY0Y2IwMDQiLCJhbGciOiJSUzI1NiJ9.eyJzdWIiOiJhZG1pbiIsImF1ZCI6ImdhdGV3YXktYXBwIiwiYXpwIjoiZ2F0ZXdheS1hcHAiLCJhdXRoX3RpbWUiOjE3NDUyNjYwNjAsInJvbGVzIjpbIlJPTEVfVVNFUiIsIlJPTEVfQURNSU4iXSwiaXNzIjoiaHR0cDovLzEyNy4wLjAuMTo5MDAwIiwiZXhwIjoxNzQ1MjY4MTAzLCJ0b2tlbl90eXBlIjoiSWQgVG9rZW4iLCJpYXQiOjE3NDUyNjYzMDMsIm5vbmNlIjoiNjM1NHN3ZWh4MWIiLCJqdGkiOiI1NjY0NTgwNi1lOTgyLTRiODctODE5Zi1iYjBkMzk1NGYxMjgiLCJzaWQiOiIxN0l1SlFQQk4zcmlWTGVmeTcwT2FBOW53SFo0MU1JSzZ3RGJTdGpMMzFZIn0.Lgh5Mugs__L8u8XcK4mtturixuPDIt7x7YR89zjcISfSni8LhOJOuZhhubWHfgEfmdj3JgOWin6E0hmtz2Fu_qRxwd-oKWB5F_KHx56Shu-jsxyS8E50FenOnQfmvQOrQrGHWxxWZr9wLmQcljb7W6VNmu1vtQJNFpOxcfgWN23VsZHggMJo4s0li-UGSvWvcbvO0dUr8IxhERaxW4m8Q-yPy3Dq2dwpgcXSthoCoRIURuzjMN-YbErOYbCJWIf5Ldk9MgMikt1aUrlxECMk55mkkx2hZKywS1neflSj98sZQZcBVeS8TyDrVc2aR7eKo44AjzJzUPUzCB0QV251Vg",
  "token_type": "Bearer",
  "expires_in": 299
}
````

Con el `access token` obtenido ya podemos realizar peticiones a endpoints que se encuentran protegidos como en el
siguiente ejemplo.

````bash
$ curl -v -X POST -H "Authorization: Bearer eyJraWQiOiJlODEwZDMwYi0wMTUwLTQ5MjUtYmE4YS1lNDIyMGY0Y2IwMDQiLCJhbGciOiJSUzI1NiJ9.eyJzdWIiOiJhZG1pbiIsImF1ZCI6ImdhdGV3YXktYXBwIiwibmJmIjoxNzQ1MjY2MzAzLCJzY29wZSI6WyJvcGVuaWQiLCJwcm9maWxlIl0sInJvbGVzIjpbIlJPTEVfVVNFUiIsIlJPTEVfQURNSU4iXSwiaXNzIjoiaHR0cDovLzEyNy4wLjAuMTo5MDAwIiwiZXhwIjoxNzQ1MjY2NjAzLCJ0b2tlbl90eXBlIjoiQWNjZXNzIFRva2VuIiwiaWF0IjoxNzQ1MjY2MzAzLCJqdGkiOiIyNjU1NjczNi02Nzc3LTQ2OTktYjY0ZC02MTZjZDc0MzQ0YTIifQ.AH-1J4m-wsiZwzbNqg3Idm_Zk6UE99WhSbe8C-vDDDBL5-zY_lfTJe8thUey1sid6ej-z0h0AxGNQp0vmNB_IFLj0V9oIvKBqlU6758qYiBvt_eb9jOk-O46I5KZdLDP8zMqs3P20H_Dr7oaMbp9BYR8Jal-hPpgrfNrg9v-tACLslMA1wdk6DQgeS53tbASqOLU4KJFbcUed0FspB5jeXzHoKL89FoCDuS-B0A_bPLagm7-AnFifIypfvygLgJmu2CcyM_e7B53MFNcIOemzMOaLW7mP3TYA0wqDUQjFS4HaJmtbsYtOKxiYzgnDQdx-wQEWpqbBHscyXou46AheQ" -H "Content-type: application/json" -d "{\"username\": \"userAa\", \"password\": \"123456\", \"email\": \"userAa@gmail.com\"}" http://localhost:8090/api/v1/users | jq
>
< HTTP/1.1 201 Created
< transfer-encoding: chunked
< Location: /api/v1/users/3
< Content-Type: application/json
< Date: Mon, 21 Apr 2025 20:12:04 GMT
< token-response: 123456
< Cache-Control: no-cache, no-store, max-age=0, must-revalidate
< Pragma: no-cache
< Expires: 0
< X-Content-Type-Options: nosniff
< X-Frame-Options: DENY
< X-XSS-Protection: 0
< Referrer-Policy: no-referrer
< set-cookie: color=red
<
{
  "id": 3,
  "username": "userAa",
  "password": "$2a$10$y1fYtXnVqI06tLWFhTsBL.HkTnK5UKYr.S378a02S99jv1.J5M47C",
  "enabled": true,
  "email": "userAa@gmail.com",
  "roles": [
    {
      "id": 2,
      "name": "ROLE_USER"
    }
  ]
}
````

## Configurar el tiempo de expiración del token

Para modificar el tiempo de vida del `access_token` y del `refresh_token` tenemos que agregar código adicional al
cliente registrado en el `RegisteredClientRepository` del `SecurityConfig` del `authorization-server`. Estas
modificaciones serán agregadas en el método concatenado `.tokenSettings(...)`.

````java

@RequiredArgsConstructor
@Configuration
public class SecurityConfig {

    /* code */

    @Bean
    public RegisteredClientRepository registeredClientRepository() {
        RegisteredClient oidcClient = RegisteredClient.withId(UUID.randomUUID().toString())
                .clientId("gateway-app")
                .clientSecret(this.passwordEncoder.encode("123456"))
                .clientAuthenticationMethod(ClientAuthenticationMethod.CLIENT_SECRET_BASIC)
                .authorizationGrantType(AuthorizationGrantType.AUTHORIZATION_CODE)
                .authorizationGrantType(AuthorizationGrantType.REFRESH_TOKEN)
                .redirectUri("http://127.0.0.1:8090/authorized")
                .redirectUri("https://oauthdebugger.com/debug")
                .postLogoutRedirectUri("http://127.0.0.1:8090/logout")
                .scope(OidcScopes.OPENID)
                .scope(OidcScopes.PROFILE)
                .tokenSettings(TokenSettings.builder()
                        .accessTokenTimeToLive(Duration.ofHours(1L))
                        .refreshTokenTimeToLive(Duration.ofDays(1L))
                        .build())
                .clientSettings(ClientSettings.builder().requireAuthorizationConsent(false).build())
                .build();

        return new InMemoryRegisteredClientRepository(oidcClient);
    }

}
````

Si luego de haber realizado estos cambios obtenemos un `access token` y lo decodificamos, veremos que el tiempo de
expiración ha cambiado a 1 hora, esto lo podemos observar en el payload `exp`.

![11.png](assets/section-10/11.png)

