# Sección 12: Desplegando Microservicios en Contenedores Docker

---

## [Creando archivo Dockerfile eficiente para el Config Server](https://github.com/magadiflo/spring-microservices-in-action-2021/blob/main/04.welcome-to-docker.md#creando-imagen-de-docker-eficiente)

En la raíz del `config-server` creamos un archivo sin extensión llamado `Dockerfile`. Este archivo nos permitirá crear
la imagen de nuestro servidor de configuraciones.

Si bien es posible convertir un `jar` de `Spring Boot` en una imagen de `Docker` con solo unas pocas líneas en el
`Dockerfile`, usaremos la `función de capas` para crear una imagen de `Docker optimizada`. El comando `extract` se puede
utilizar para dividir fácilmente la aplicación en capas que se agregarán al `dockerfile`.

Agregamos el archivo `Dockerfile` en la raíz de nuestro microservicio para crear la `imagen docker optimizada` que
utiliza un `jarmode`.

El siguiente `Dockerfile` es un archivo `multi-stage` de tres etapas(`dependencies`, `builder`, `runner`).

````dockerfile
FROM eclipse-temurin:21-jdk-alpine AS dependencies
WORKDIR /app
COPY ./mvnw ./
COPY ./.mvn ./.mvn
COPY ./pom.xml ./

RUN sed -i -e 's/\r$//' ./mvnw
RUN ./mvnw dependency:go-offline

COPY ./src ./src
RUN ./mvnw clean package -DskipTests
#-----------------------------------------------------------------
FROM eclipse-temurin:21-jre-alpine AS builder
WORKDIR /app
COPY --from=dependencies /app/target/*.jar ./app.jar
RUN java -Djarmode=layertools -jar app.jar extract
#-----------------------------------------------------------------
FROM eclipse-temurin:21-jre-alpine AS runner
WORKDIR /app
COPY --from=builder /app/dependencies ./
COPY --from=builder /app/spring-boot-loader ./
COPY --from=builder /app/snapshot-dependencies ./
COPY --from=builder /app/application ./

EXPOSE 8888
CMD ["java", "org.springframework.boot.loader.launch.JarLauncher"]
````

**Dónde**

- En la primera etapa estamos usando la imagen base del `eclipse-temurin:21-jdk-alpine` de java, esto es importante
  porque en esta etapa vamos a descargar las dependencias y compilar el `jar`, por eso necesitamos que sea un `JDK`.


- En las dos últimas etapas usamos como imagen base `eclipse-temurin:21-jre-alpine`, es decir, únicamente el entorno
  para ejecutar una aplicación java, aquí ya no necesitamos el `JDK`, sino solo el `JRE`, además que es más liviano.


- `RUN sed -i -e 's/\r$//' ./mvnw`, es un comando de `Linux` que utiliza `sed`, el editor de flujo, para eliminar los
  caracteres
  de retorno de carro `(\r)` al final de cada línea en el archivo `mvnw`.


- `RUN ./mvnw dependency:go-offline`, iniciamos la descarga de las dependencias de maven.


- `RUN java -Djarmode=layertools -jar app.jar extract`:
    - `Spring Boot 2.3` introdujo un modo especial para manejar los archivos `jar`, llamado `Layertools`. Esto permite
      que el `jar` se estructure en capas lógicas como `dependencies`, `spring-boot-loader`, `snapshot-dependencies`,
      y `application`.
    - `El objetivo de estas capas es optimizar la reconstrucción de imágenes Docker`. Al tener una estructura de capas,
      si una parte del código cambia, solo se necesita reconstruir las capas afectadas en lugar de todo el `jar`. Esto
      puede resultar en una construcción de `imágenes Docker` más `rápida` y `eficiente`.
    - Este comando utiliza el modo de herramientas de capa (`layertools`) que permite ejecutar operaciones específicas
      relacionadas con el manejo de capas.
    - El comando `extract` extrae capas del `jar` para la creación de la imagen. Este comando descompone el archivo
      `jar` de la siguiente manera:
        - `Dependencies`: Las dependencias de tiempo de ejecución.
        - `Spring-Boot-Loader`: La parte responsable de iniciar una aplicación Spring Boot.
        - `Snapshot-Dependencies`: Dependencias etiquetadas como "snapshot".
        - `Application`: El código específico de la aplicación, como tus clases y recursos.


- `COPY --from=builder /app/dependencies ./` (y los otros `COPY` de las capas del `jar`), copiamos las distintas
  capas que han sido extraídas por el comando descrito anteriormente. Las copiamos en una nueva etapa del
  `Dockerfile`.


- `EXPOSE 8888`, el comando `EXPOSE` en un `Dockerfile` sirve para `documentar` que un contenedor escucha en un puerto
  específico. No abre ni publica el puerto hacia el exterior por sí mismo, simplemente declara que tu aplicación dentro
  del contenedor usará ese puerto. Es básicamente `una forma de documentar` qué puerto utiliza la aplicación dentro del
  contenedor. Le dice a otros desarrolladores (y a herramientas como Docker Compose) que la app escucha en ese puerto.


- `CMD ["java", "org.springframework.boot.loader.launch.JarLauncher"]`, hasta este punto no estamos trabajando con un
  `jar`, sino más bien con el desempaquetado del `jar`, eso significa que no podemos usar el clásico
  `CMD ["java","-jar","app.jar"]` para ejecutar la aplicación cuando inicie el contenedor. El `JarLauncher` es parte del
  sistema de carga de `Spring Boot`. Este lanzador permite cargar la aplicación desde capas separadas, esencialmente
  emulando el comportamiento de un `jar` ejecutable pero permitiendo el uso de capas para optimizar la reconstrucción
  del contenedor. En resumen, en esta última etapa del `Dockerfile` estamos copiando el desempaquetado del `jar` de la
  etapa `builder` al directorio `/app` de esta última etapa `runner`. Eso significa, que el contenedor final, tendrá en
  el directorio `/app` todos los directorios y archivos del desempaquetado del `jar` y para poder iniciar la aplicación
  utilizaremos el `JarLauncher` ubicado en el directorio `org.springframework.boot.loader.launch`. Más adelante, cuando
  creemos un contendor ingresaremos dentro de él para ver el contenido del directorio `/app`. Nos daremos cuenta que
  este directorio contendrá los directorios y archivos del desempaquetado del `jar`.

## Construyendo imagen Docker del Config Server

Mediante la línea de comandos nos posicionamos en la raíz del `config-server` donde tenemos nuestro `Dockerfile`. Luego,
escribimos el siguiente comando que nos permitirá generar la `imagen docker` de este microservicio.

````bash
D:\programming\spring\01.udemy\02.andres_guzman\06.microservices_netflix_eureka\microservices-project\infrastructure\config-server (feature/section-12)
$ docker image build -t config-server . 
````

**Dónde**

- `docker image build`, comando de Docker para construir una imagen a partir de un `Dockerfile`.


- `-t`, es una bandera que nos permite definir un `tag name` *(nombre y versión)* para la imagen. En nuestro caso, el
  nombre que le daremos a la imagen será `config-server`. Como no especificamos un `tag` explícito, `Docker` usará por
  defecto el tag `latest`. Si quisiéramos agregar un tag personalizado, lo haríamos así: `config-server:mi-version-tag`.


- `.`, el punto al final de la instrucción indica que Docker debe buscar el archivo `Dockerfile` en el directorio
  actual. En este caso, el directorio actual es la raíz del proyecto `/config-server`, donde estamos ubicados en la
  terminal. Justo allí se encuentra nuestro `Dockerfile`, así que le estamos diciendo a `Docker` que use ese contexto
  para construir la imagen.

Una vez explicado cada parte del comando procedemos a ejecutarlo.

````bash
D:\programming\spring\01.udemy\02.andres_guzman\06.microservices_netflix_eureka\microservices-project\infrastructure\config-server (feature/section-12)
$ docker image build -t config-server .                                                                                                                
[+] Building 51.1s (24/24) FINISHED                                                                                                                    
 => [internal] load build definition from Dockerfile                                                                                                   
 => => transferring dockerfile: 782B                                                                                                                   
 => [internal] load metadata for docker.io/library/eclipse-temurin:21-jre-alpine                                                                       
 => [internal] load metadata for docker.io/library/eclipse-temurin:21-jdk-alpine                                                                       
 => [auth] library/eclipse-temurin:pull token for registry-1.docker.io                                                                                 
 => [internal] load .dockerignore                                                                                                                      
 => => transferring context: 2B                                                                                                                        
 => [dependencies 1/9] FROM docker.io/library/eclipse-temurin:21-jdk-alpine@sha256:2f2f553ce09d25e2d2f0f521ab94cd73f70c9b21327a29149c23a2b63b8e29a0    
 => => resolve docker.io/library/eclipse-temurin:21-jdk-alpine@sha256:2f2f553ce09d25e2d2f0f521ab94cd73f70c9b21327a29149c23a2b63b8e29a0                 
 => [builder 1/4] FROM docker.io/library/eclipse-temurin:21-jre-alpine@sha256:8728e354e012e18310faa7f364d00185277dec741f4f6d593af6c61fc0eb15fd         
 => => resolve docker.io/library/eclipse-temurin:21-jre-alpine@sha256:8728e354e012e18310faa7f364d00185277dec741f4f6d593af6c61fc0eb15fd                 
 => => sha256:cda86626eeb372589c3378d030f4522ba1b0c78ec58b1db87960fa4e5fcd3e34 2.28kB / 2.28kB                                                         
 => => sha256:e6744199aa66ab985e37e72924f1568a6751afa2c508c42a1b3b945f3a8850a7 126B / 126B                                                             
 => => sha256:74f6a226ed936757680facf9b217f62a2af16b663a69df8e4b3ece925e27ed2a 53.06MB / 53.06MB                                                       
 => => sha256:f6cd406c8d97cafcb893e824126c17fa19907b2bbc8d759931089e1be1e75750 16.18MB / 16.18MB                                                       
 => => extracting sha256:f6cd406c8d97cafcb893e824126c17fa19907b2bbc8d759931089e1be1e75750                                                              
 => => extracting sha256:74f6a226ed936757680facf9b217f62a2af16b663a69df8e4b3ece925e27ed2a                                                              
 => => extracting sha256:e6744199aa66ab985e37e72924f1568a6751afa2c508c42a1b3b945f3a8850a7                                                              
 => => extracting sha256:cda86626eeb372589c3378d030f4522ba1b0c78ec58b1db87960fa4e5fcd3e34                                                              
 => [internal] load build context                                                                                                                      
 => => transferring context: 13.95kB                                                                                                                   
 => CACHED [dependencies 2/9] WORKDIR /app                                                                                                             
 => [dependencies 3/9] COPY ./mvnw ./                                                                                                                  
 => [dependencies 4/9] COPY ./.mvn ./.mvn                                                                                                              
 => [dependencies 5/9] COPY ./pom.xml ./                                                                                                               
 => [dependencies 6/9] RUN sed -i -e 's/\r$//' ./mvnw                                                                                                  
 => [dependencies 7/9] RUN ./mvnw dependency:go-offline                                                                                                
 => [builder 2/4] WORKDIR /app                                                                                                                         
 => [dependencies 8/9] COPY ./src ./src                                                                                                                
 => [dependencies 9/9] RUN ./mvnw clean package -DskipTests                                                                                            
 => [builder 3/4] COPY --from=dependencies /app/target/*.jar ./app.jar                                                                                 
 => [builder 4/4] RUN java -Djarmode=layertools -jar app.jar extract                                                                                   
 => [runner 3/6] COPY --from=builder /app/dependencies ./                                                                                              
 => [runner 4/6] COPY --from=builder /app/spring-boot-loader ./                                                                                        
 => [runner 5/6] COPY --from=builder /app/snapshot-dependencies ./                                                                                     
 => [runner 6/6] COPY --from=builder /app/application ./                                                                                               
 => exporting to image                                                                                                                                 
 => => exporting layers                                                                                                                                
 => => exporting manifest sha256:ac034572e56e413bb510510d6e5013ef06c3fdcb2451a8d4202c6e45155b78ff                                                      
 => => exporting config sha256:49e50361b329d89f16d543879e5529c9db482271c8aa708184ffa23780ebdb60                                                        
 => => exporting attestation manifest sha256:c14bc17e6104177e6937e649ed3485c948cfd3dfc3e5d614df8eb7a1d6bcc961                                          
 => => exporting manifest list sha256:4deeb21c52dd73d36cb71af8a8d844d91beaf67cd21facc95fdc17c5c4f32439                                                 
 => => naming to docker.io/library/config-server:latest                                                                                                
 => => unpacking to docker.io/library/config-server:latest                                                                                             
                                                                                                                                                       
View build details: docker-desktop://dashboard/build/desktop-linux/desktop-linux/ievhbmkf37mzrg72bqzg54dzm                                             
````

Finalizada la construcción, listamos las imágenes para ver el que acabamos de crear.

````bash
$ docker image ls
REPOSITORY      TAG       IMAGE ID       CREATED          SIZE
config-server   latest    4deeb21c52dd   21 minutes ago   366MB
````

Observamos que la imagen tiene el tag `latest`. Esto ocurre porque al construir la imagen con la opción
`-t config-server` no especificamos un tag explícito (por ejemplo, `config-server:1.0.0`).


> `Docker`, por convención, asigna automáticamente el `tag latest` cuando no se indica uno.
> Es una forma de marcar la versión más reciente por defecto, pero no significa que sea necesariamente la más nueva o
> recomendada — eso depende de la gestión de versiones que nosotros hagamos.

## Creando red en Docker

Creamos una red personalizada que luego asociaremos a los contenedores que forman parte de nuestro ecosistema de
microservicios.

````bash
$ docker network create microservices-project-net
4320f82dad9c8d95cf4e05cc5f6664a51d338df8b5b2c7b63d22e24275c212a6
````

**Dónde**

- `docker network create`, permite crear una nueva red personalizada en `Docker`.
- `microservices-project-net`, es el nombre que le damos a nuestra red.

Al crear una red personalizada:

- `Docker` usará por defecto el `driver bridge`, que permite la comunicación entre contenedores dentro de la misma red.
- Los contenedores conectados a esta red podrán resolverse entre sí por nombre, lo que simplifica mucho la comunicación
  entre microservicios (por ejemplo, `config-server` podrá ser accedido desde `eureka-server` solo usando su nombre de
  contenedor).
- Esta práctica `evita depender` de direcciones `IP dinámicas` y mejora la escalabilidad del proyecto.

> Es una buena práctica usar redes personalizadas en proyectos con múltiples contenedores, como una arquitectura de
> microservicios, ya que te da mayor control, aislamiento y facilidad para escalar.

Si listamos las redes, podemos verificar que está la que acabamos de crear.

````bash
$ docker network ls
NETWORK ID     NAME                        DRIVER    SCOPE
16b8d6f5da55   bridge                      bridge    local
8c77b18a87f1   host                        host      local
4320f82dad9c   microservices-project-net   bridge    local
fe251eccddcc   none                        null      local
````

Como se muestra en el resultado, `Docker` nos lista todas las redes disponibles actualmente:

- `bridge`, red predeterminada que `Docker` crea para permitir la comunicación entre contenedores si no se especifica
  una red personalizada.
- `host`, red especial donde el contenedor comparte directamente el stack de red del host (solo disponible en Linux).
- `none`, aisla completamente la red del contenedor (sin conectividad).
- `microservices-project-net`, es la red personalizada que acabamos de crear, usando el driver bridge.

Al crear redes personalizadas como `microservices-project-net`, ganamos ventajas clave como:

- Resolución de nombres entre contenedores.
- Mejor organización de servicios.
- Mayor seguridad y aislamiento del tráfico de red.

## Levantando contenedor a partir de la imagen Docker del Config Server

Una vez construida la `imagen Docker` del `Config Server`, podemos crear y ejecutar un contenedor a partir de ella
utilizando el siguiente comando.

````bash
$ docker container run -d -p 8888:8888 --name c-config-server --network microservices-project-net config-server
a59c00698b3fb1d3638c32a182e0110b50d3cb9deb1fc2252fc0d89a39031a3f
````

**Dónde**

- `docker container run`, comando para crear y ejecutar un contenedor a partir de una imagen.
- `-d`, ejecuta el contenedor en modo `detached` (segundo plano), permitiéndonos seguir usando la terminal.
- `-p 8888:8888`, especifica el mapeo de puertos en el formato HOST_PORT:CONTAINER_PORT. En este caso:
    - `8888 (izquierda)` es el puerto expuesto en nuestra máquina local.
    - `8888 (derecha)` es el puerto interno del contenedor en el que se ejecuta la aplicación Spring Boot.
- `--name c-config-server`, asigna un nombre identificador al contenedor.
- `--network microservices-project-net`, conecta el contenedor a la red personalizada que creamos anteriormente, lo que
  permite que se comunique fácilmente con otros contenedores de la misma red.
- `config-server`, es el nombre de la imagen `Docker` desde la cual se va a crear el contenedor.
    - Como no se especificó una versión (`tag`), Docker usará por defecto la etiqueta `latest`.
    - Si se desea usar una versión específica, se puede indicar así `config-server:1.0.0`.

Si ahora listamos los contenedores veremos que el contenedor `c-config-server` se está ejecutando correctamente, como lo
indica el estado `Up`. El mapeo de puertos `0.0.0.0:8888->8888/tcp` significa que cualquier solicitud hecha al puerto
`8888` de la máquina local será redirigida al puerto 8888 del contenedor. Esto nos permitirá acceder al `Config Server`
desde el navegador o cualquier cliente HTTP usando http://localhost:8888.

````bash
$ docker container ls -a
CONTAINER ID   IMAGE           COMMAND                  CREATED          STATUS          PORTS                    NAMES
a59c00698b3f   config-server   "/__cacert_entrypoin…"   23 seconds ago   Up 21 seconds   0.0.0.0:8888->8888/tcp   c-config-server
````

## Verificando que el contenedor está en la red docker

Después de levantar el contenedor, podemos `inspeccionar la red` que creamos para asegurarnos de que el contenedor está
efectivamente conectado a ella.

````bash
$ docker network inspect microservices-project-net
[
    {
        "Name": "microservices-project-net",
        "Id": "4320f82dad9c8d95cf4e05cc5f6664a51d338df8b5b2c7b63d22e24275c212a6",
        "Created": "2025-04-25T18:05:20.033232455Z",
        "Scope": "local",
        "Driver": "bridge",
        "EnableIPv4": true,
        "EnableIPv6": false,
        "IPAM": {
            "Driver": "default",
            "Options": {},
            "Config": [
                {
                    "Subnet": "172.18.0.0/16",
                    "Gateway": "172.18.0.1"
                }
            ]
        },
        "Internal": false,
        "Attachable": false,
        "Ingress": false,
        "ConfigFrom": {
            "Network": ""
        },
        "ConfigOnly": false,
        "Containers": {
            "a59c00698b3fb1d3638c32a182e0110b50d3cb9deb1fc2252fc0d89a39031a3f": {
                "Name": "c-config-server",
                "EndpointID": "fa81b04a669bb2440a5c71d275afcd5d5a71cc84fdf22c01ffc2c695e4bb43e8",
                "MacAddress": "c2:3b:21:ff:cb:18",
                "IPv4Address": "172.18.0.2/16",
                "IPv6Address": ""
            }
        },
        "Options": {},
        "Labels": {}
    }
]
````

En la salida del comando, dentro del atributo `Containers`, podemos ver que nuestro contenedor `c-config-server` está
registrado. Aparecen datos como:

- `Name: c-config-server` (el nombre que le dimos al contenedor).
- `IPv4Address: 172.18.0.2/16` (la IP asignada dentro de esta red).
- `MacAddress`, dirección física virtual asignada.

Este paso es útil para:

- Validar la conectividad entre contenedores cuando trabajamos en un entorno de microservicios.
- Usar nombres de contenedores como `hostnames` al momento de comunicar servicios entre sí dentro de la misma red
  Docker.

También podríamos `inspeccionar el contenedor` y verificar que la red a la que estamos conectados sea el que
definimos en la creación.

````bash
$ docker container inspect c-config-server
[
    {
        "HostConfig": {
            "NetworkMode": "microservices-project-net",
            ...
        },
        "NetworkSettings": {
            ...
            "Networks": {
                "microservices-project-net": {...}
            }
        },
        ...
    }
]
````

Como vemos el contenedor `c-config-server` está conectado a la red `microservices-project-net`, como se puede ver en
el resultado anterior.

## Logs del Config Server al iniciar el contenedor

Al iniciar el `contenedor Docker` del `Config Server`, es útil observar los `logs` para verificar que la aplicación se
ha levantado correctamente y que está leyendo los archivos de configuración como se espera.

Entonces, ejecutamos el siguiente comando para ver los logs del contenedor:

````bash
$ docker container logs c-config-server

  .   ____          _            __ _ _
 /\\ / ___'_ __ _ _(_)_ __  __ _ \ \ \ \
( ( )\___ | '_ | '_| | '_ \/ _` | \ \ \ \
 \\/  ___)| |_)| | | | | || (_| |  ) ) ) )
  '  |____| .__|_| |_|_| |_\__, | / / / /
 =========|_|==============|___/=/_/_/_/

 :: Spring Boot ::                (v3.4.4)

2025-04-25T20:35:38.503Z  INFO 1 --- [config-server] [           main] d.m.c.s.app.ConfigServerApplication      : Starting ConfigServerApplication v0.0.1-SNAPSHOT using Java 21.0.7 with PID 1 (/app/BOOT-INF/classes started by root in /app)
2025-04-25T20:35:38.506Z  INFO 1 --- [config-server] [           main] d.m.c.s.app.ConfigServerApplication      : No active profile set, falling back to 1 default profile: "default"
2025-04-25T20:35:39.888Z  INFO 1 --- [config-server] [           main] o.s.cloud.context.scope.GenericScope     : BeanFactory id=209bd33f-ee6e-361d-bc59-b6fdc05076d4
2025-04-25T20:35:40.318Z  INFO 1 --- [config-server] [           main] o.s.b.w.embedded.tomcat.TomcatWebServer  : Tomcat initialized with port 8888 (http)
2025-04-25T20:35:40.338Z  INFO 1 --- [config-server] [           main] o.apache.catalina.core.StandardService   : Starting service [Tomcat]
2025-04-25T20:35:40.339Z  INFO 1 --- [config-server] [           main] o.apache.catalina.core.StandardEngine    : Starting Servlet engine: [Apache Tomcat/10.1.39]
2025-04-25T20:35:40.385Z  INFO 1 --- [config-server] [           main] o.a.c.c.C.[Tomcat].[localhost].[/]       : Initializing Spring embedded WebApplicationContext
2025-04-25T20:35:40.387Z  INFO 1 --- [config-server] [           main] w.s.c.ServletWebServerApplicationContext : Root WebApplicationContext: initialization completed in 1804 ms
2025-04-25T20:35:41.806Z  INFO 1 --- [config-server] [           main] o.s.b.a.e.web.EndpointLinksResolver      : Exposing 1 endpoint beneath base path '/actuator'
2025-04-25T20:35:41.891Z  INFO 1 --- [config-server] [           main] o.s.b.w.embedded.tomcat.TomcatWebServer  : Tomcat started on port 8888 (http) with context path '/'
2025-04-25T20:35:41.913Z  INFO 1 --- [config-server] [           main] d.m.c.s.app.ConfigServerApplication      : Started ConfigServerApplication in 4.054 seconds (process running for 5.082)
2025-04-25T20:39:52.480Z  INFO 1 --- [config-server] [nio-8888-exec-1] o.a.c.c.C.[Tomcat].[localhost].[/]       : Initializing Spring DispatcherServlet 'dispatcherServlet'
2025-04-25T20:39:52.480Z  INFO 1 --- [config-server] [nio-8888-exec-1] o.s.web.servlet.DispatcherServlet        : Initializing Servlet 'dispatcherServlet'
2025-04-25T20:39:52.483Z  INFO 1 --- [config-server] [nio-8888-exec-1] o.s.web.servlet.DispatcherServlet        : Completed initialization in 3 ms
2025-04-25T20:39:58.252Z  INFO 1 --- [config-server] [nio-8888-exec-1] o.s.c.c.s.e.NativeEnvironmentRepository  : Adding property source: Config resource 'file [/tmp/config-repo-10370607234881797303/item-service.yml]' via location 'file:/tmp/config-repo-10370607234881797303/'
2025-04-25T20:40:03.094Z  INFO 1 --- [config-server] [nio-8888-exec-3] o.s.c.c.s.e.NativeEnvironmentRepository  : Adding property source: Config resource 'file [/tmp/config-repo-10370607234881797303/item-service.yml]' via location 'file:/tmp/config-repo-10370607234881797303/'
2025-04-25T20:40:40.633Z  INFO 1 --- [config-server] [nio-8888-exec-5] o.s.c.c.s.e.NativeEnvironmentRepository  : Adding property source: Config resource 'file [/tmp/config-repo-10370607234881797303/item-service-dev.yml]' via location 'file:/tmp/config-repo-10370607234881797303/'
2025-04-25T20:40:40.633Z  INFO 1 --- [config-server] [nio-8888-exec-5] o.s.c.c.s.e.NativeEnvironmentRepository  : Adding property source: Config resource 'file [/tmp/config-repo-10370607234881797303/item-service.yml]' via location 'file:/tmp/config-repo-10370607234881797303/'
2025-04-25T21:34:38.249Z  INFO 1 --- [config-server] [nio-8888-exec-7] o.s.c.c.s.e.NativeEnvironmentRepository  : Adding property source: Config resource 'file [/tmp/config-repo-10370607234881797303/item-service-prod.yml]' via location 'file:/tmp/config-repo-10370607234881797303/'
2025-04-25T21:34:38.249Z  INFO 1 --- [config-server] [nio-8888-exec-7] o.s.c.c.s.e.NativeEnvironmentRepository  : Adding property source: Config resource 'file [/tmp/config-repo-10370607234881797303/item-service.yml]' via location 'file:/tmp/config-repo-10370607234881797303/'
````

Los `logs` del contenedor del `Config Server` confirman que la aplicación se ha iniciado correctamente usando `Java 21`,
desplegada en un contenedor con servidor embebido `Tomcat` escuchando en el puerto `8888`. Además, se evidencia que el
servidor ha cargado exitosamente los archivos de configuración (`item-service.yml`, `item-service-dev.yml` y
`item-service-prod.yml`) a partir de peticiones http realizadas para consultar estos archivos.
Esto indica que el `Config Server` está funcionando correctamente.

## Verificando el funcionamiento del Config Server

Podemos probar que el `Config Server` está corriendo correctamente y que tiene acceso al repositorio remoto de
configuración realizando peticiones http. En el siguiente ejemplo consultaremos por el archivo o perfil `dev`.

````bash
$ curl -v http://localhost:8888/item-service/dev | jq
>
< HTTP/1.1 200
< Content-Type: application/json
< Transfer-Encoding: chunked
< Date: Fri, 25 Apr 2025 20:40:40 GMT
<
{
  "name": "item-service",
  "profiles": [
    "dev"
  ],
  "label": null,
  "version": "6d1fd0fc178a112daa21f5705cd28023c55470f3",
  "state": "",
  "propertySources": [
    {
      "name": "https://github.com/magadiflo/config-server-repo.git/item-service-dev.yml",
      "source": {
        "custom.text": "item-service-dev.yml en config server con perfil dev (desde GitHub)",
        "custom.author.name": "Martín (desde GitHub)",
        "custom.author.email": "magadiflo@gmail.com (desde GitHub)"
      }
    },
    {
      "name": "https://github.com/magadiflo/config-server-repo.git/item-service.yml",
      "source": {
        "server.port": 8085,
        "custom.text": "item-service.yml en config server con perfil por defecto"
      }
    }
  ]
}
````

La petición anterior solicita el archivo de configuración para el servicio llamado `item-service` con el perfil `dev`.
Si todo está funcionando, obtendremos una respuesta `JSON` con las propiedades definidas en los archivos
`item-service.yml` y `item-service-dev.yml` del repositorio remoto, tal como se muestra en el resultado anterior.

## Renombrando una Imagen en Docker

En `Docker`, podemos `renombrar` o `etiquetar` imágenes existentes utilizando el comando `docker image tag`. Este
proceso es útil cuando queremos cambiar el nombre de una imagen o asignarle una nueva versión. A continuación, mostramos
cómo hacerlo:

1. `Listamos las imágenes actuales`. Primero, listamos las imágenes disponibles en la plataforma Docker con el siguiente
   comando.
    ````bash
    $ docker image ls
    REPOSITORY      TAG       IMAGE ID       CREATED       SIZE
    config-server   latest    4deeb21c52dd   4 hours ago   366MB
    ````
   Aquí, podemos ver que tenemos una imagen llamada `config-server` con la etiqueta `latest`.


3. `Renombrando la imagen`. Podemos renombrar la imagen utilizando el comando `docker image tag`. Existen dos maneras
   principales de hacerlo:
    - *Asignar un nombre y etiqueta diferente*
    ````bash
    $ docker image tag config-server:latest servidor-configuraciones:v1
    ````
   En este ejemplo, renombramos la imagen `config-server` con la etiqueta `latest` a `servidor-configuraciones` con la
   etiqueta `v1`.<br><br>

    - *Cambiar la versión de la imagen*
    ````bash
    $ docker image tag config-server:latest config-server:1.0.0
    ````
   Aquí, simplemente cambiamos la versión de `latest` a `1.0.0`.


3. `Verificando las Imágenes Renombradas`. Después de realizar los cambios, podemos listar nuevamente las imágenes para
   verificar que la operación se haya realizado correctamente.
    ````bash
    $ docker image ls
    REPOSITORY                 TAG       IMAGE ID       CREATED       SIZE
    config-server              1.0.0     4deeb21c52dd   4 hours ago   366MB
    config-server              latest    4deeb21c52dd   4 hours ago   366MB
    servidor-configuraciones   v1        4deeb21c52dd   4 hours ago   366MB
    ````

Como se observa, las tres imágenes (`config-server:1.0.0`, `config-server:latest`, y `servidor-configuraciones:v1`)
comparten el mismo `IMAGE ID`, ya que todas son basadas en la misma imagen base y no han sufrido modificaciones en su
contenido, solo han cambiado su nombre o versión.

## Eliminando imagen

Primero listamos las imágenes actuales.

````bash
$ docker image ls
REPOSITORY                 TAG       IMAGE ID       CREATED       SIZE
config-server              1.0.0     4deeb21c52dd   4 hours ago   366MB
config-server              latest    4deeb21c52dd   4 hours ago   366MB
servidor-configuraciones   v1        4deeb21c52dd   4 hours ago   366MB
````

Procedemos a eliminar la imagen `servidor-configuraciones` con tag `v1` utilizando el siguiente comando.

````bash
$ docker image rm servidor-configuraciones:v1
Untagged: servidor-configuraciones:v1
````

Volvemos a listar las imágenes y verificamos que la imagen fue eliminada.

````bash
$ docker image ls
REPOSITORY      TAG       IMAGE ID       CREATED       SIZE
config-server   1.0.0     4deeb21c52dd   4 hours ago   366MB
config-server   latest    4deeb21c52dd   4 hours ago   366MB
````

## Eliminando contenedor

Primero listamos los contenedores actuales.

````bash
$ docker container ls -a
CONTAINER ID   IMAGE           COMMAND                  CREATED       STATUS       PORTS                    NAMES
a59c00698b3f   config-server   "/__cacert_entrypoin…"   2 hours ago   Up 2 hours   0.0.0.0:8888->8888/tcp   c-config-server
````

Como el contenedor se encuentra en ejecución (`Up`) primero debemos detenerlo.

````bash
$ docker container stop c-config-server
c-config-server
````

Ahora sí procedemos a eliminar el contenedor utilizando el siguiente comando.

````bash
$ docker container rm c-config-server
c-config-server
````

Si listamos nuevamente los contenedores veremos que la eliminación ha sido exitosa.

````bash
$ docker container ls -a
CONTAINER ID   IMAGE     COMMAND   CREATED   STATUS    PORTS     NAMES
````

## Explorando el contenido del contenedor del Config Server

Primero, listamos los contenedores que se encuentran en ejecución (o detenidos) en nuestra plataforma Docker. Esto nos
permite identificar el nombre del contenedor que deseamos inspeccionar.

````bash
$ docker container ls -a
CONTAINER ID   IMAGE           COMMAND                  CREATED          STATUS         PORTS                    NAMES
683472a028ac   config-server   "/__cacert_entrypoin…"   11 minutes ago   Up 5 minutes   0.0.0.0:8888->8888/tcp   c-config-server
````

En este caso, el contenedor que nos interesa tiene como nombre `c-config-server`.

A continuación, accedemos de forma interactiva al contenedor utilizando una `shell` mínima (`/bin/sh`).
Una vez dentro del contenedor, nos ubicamos en la ruta `/app`, donde se encuentra desplegada la aplicación. Listamos el
contenido del directorio para verificar los archivos y carpetas disponibles.

````bash
$ docker container exec -it c-config-server /bin/sh
/app # ls -l
total 12
drwxr-xr-x 1 root root 4096 Apr 25 17:35 BOOT-INF
drwxr-xr-x 4 root root 4096 Apr 25 17:35 META-INF
drwxr-xr-x 3 root root 4096 Apr 25 17:35 org
/app #
````

Estos directorios (`BOOT-INF`, `META-INF`, `org`) son característicos de una aplicación `Spring Boot` empacada como
ejecutable `.jar`, lo cual confirma que la aplicación se está ejecutando correctamente dentro del contenedor.

Para aclarar un poco sobre los directorios `BOOT-INF`, `META-INF` y `org`, estos directorios están presentes porque la
imagen `Docker` se ha construido usando el enfoque de capas de `Spring Boot` mediante `layertools`. Este enfoque permite
extraer y copiar de manera explícita las capas internas del `jar`, lo cual favorece la eficiencia en la construcción y
el cacheo de capas.

