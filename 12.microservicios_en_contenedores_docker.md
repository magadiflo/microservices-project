# Sección 12: Desplegando Microservicios en Contenedores Docker

---

## [Creando archivo Dockerfile eficiente para el Config Server](https://github.com/magadiflo/spring-microservices-in-action-2021/blob/main/04.welcome-to-docker.md#creando-imagen-de-docker-eficiente)

En la raíz del `config-server` creamos un archivo sin extensión llamado `Dockerfile`. Este archivo nos permitirá crear
la imagen de nuestro servidor de configuraciones.

Si bien es posible convertir un `jar` de `Spring Boot` en una imagen de `Docker` con solo unas pocas líneas en el
`Dockerfile`, usaremos la `función de capas` para crear una imagen de `Docker optimizada`. El comando `extract` se puede
utilizar para dividir fácilmente la aplicación en capas que se agregarán al `dockerfile`.

Agregamos el archivo `Dockerfile` en la raíz de nuestro microservicio para crear la `imagen docker optimizada` que
utiliza un `jarmode`.

El siguiente `Dockerfile` es un archivo `multi-stage` de tres etapas(`dependencies`, `builder`, `runner`).

````dockerfile
FROM eclipse-temurin:21-jdk-alpine AS dependencies
WORKDIR /app
COPY ./mvnw ./
COPY ./.mvn ./.mvn
COPY ./pom.xml ./

RUN sed -i -e 's/\r$//' ./mvnw
RUN ./mvnw dependency:go-offline

COPY ./src ./src
RUN ./mvnw clean package -DskipTests
#-----------------------------------------------------------------
FROM eclipse-temurin:21-jre-alpine AS builder
WORKDIR /app
COPY --from=dependencies /app/target/*.jar ./app.jar
RUN java -Djarmode=layertools -jar app.jar extract
#-----------------------------------------------------------------
FROM eclipse-temurin:21-jre-alpine AS runner
WORKDIR /app
COPY --from=builder /app/dependencies ./
COPY --from=builder /app/spring-boot-loader ./
COPY --from=builder /app/snapshot-dependencies ./
COPY --from=builder /app/application ./

EXPOSE 8888
CMD ["java", "org.springframework.boot.loader.launch.JarLauncher"]
````

**Dónde**

- En la primera etapa estamos usando la imagen base del `eclipse-temurin:21-jdk-alpine` de java, esto es importante
  porque en esta etapa vamos a descargar las dependencias y compilar el `jar`, por eso necesitamos que sea un `JDK`.


- En las dos últimas etapas usamos como imagen base `eclipse-temurin:21-jre-alpine`, es decir, únicamente el entorno
  para ejecutar una aplicación java, aquí ya no necesitamos el `JDK`, sino solo el `JRE`, además que es más liviano.


- `RUN sed -i -e 's/\r$//' ./mvnw`, es un comando de `Linux` que utiliza `sed`, el editor de flujo, para eliminar los
  caracteres
  de retorno de carro `(\r)` al final de cada línea en el archivo `mvnw`.


- `RUN ./mvnw dependency:go-offline`, iniciamos la descarga de las dependencias de maven.


- `RUN java -Djarmode=layertools -jar app.jar extract`:
    - `Spring Boot 2.3` introdujo un modo especial para manejar los archivos `jar`, llamado `Layertools`. Esto permite
      que el `jar` se estructure en capas lógicas como `dependencies`, `spring-boot-loader`, `snapshot-dependencies`,
      y `application`.
    - `El objetivo de estas capas es optimizar la reconstrucción de imágenes Docker`. Al tener una estructura de capas,
      si una parte del código cambia, solo se necesita reconstruir las capas afectadas en lugar de todo el `jar`. Esto
      puede resultar en una construcción de `imágenes Docker` más `rápida` y `eficiente`.
    - Este comando utiliza el modo de herramientas de capa (`layertools`) que permite ejecutar operaciones específicas
      relacionadas con el manejo de capas.
    - El comando `extract` extrae capas del `jar` para la creación de la imagen. Este comando descompone el archivo
      `jar` de la siguiente manera:
        - `Dependencies`: Las dependencias de tiempo de ejecución.
        - `Spring-Boot-Loader`: La parte responsable de iniciar una aplicación Spring Boot.
        - `Snapshot-Dependencies`: Dependencias etiquetadas como "snapshot".
        - `Application`: El código específico de la aplicación, como tus clases y recursos.


- `COPY --from=builder /app/dependencies ./` (y los otros `COPY` de las capas del `jar`), copiamos las distintas
  capas que han sido extraídas por el comando descrito anteriormente. Las copiamos en una nueva etapa del
  `Dockerfile`.


- `EXPOSE 8888`, el comando `EXPOSE` en un `Dockerfile` sirve para `documentar` que un contenedor escucha en un puerto
  específico. No abre ni publica el puerto hacia el exterior por sí mismo, simplemente declara que tu aplicación dentro
  del contenedor usará ese puerto. Es básicamente `una forma de documentar` qué puerto utiliza la aplicación dentro del
  contenedor. Le dice a otros desarrolladores (y a herramientas como Docker Compose) que la app escucha en ese puerto.


- `CMD ["java", "org.springframework.boot.loader.launch.JarLauncher"]`, hasta este punto no estamos trabajando con un
  `jar`, sino más bien con el desempaquetado del `jar`, eso significa que no podemos usar el clásico
  `CMD ["java","-jar","app.jar"]` para ejecutar la aplicación cuando inicie el contenedor. El `JarLauncher` es parte del
  sistema de carga de `Spring Boot`. Este lanzador permite cargar la aplicación desde capas separadas, esencialmente
  emulando el comportamiento de un `jar` ejecutable pero permitiendo el uso de capas para optimizar la reconstrucción
  del contenedor. En resumen, en esta última etapa del `Dockerfile` estamos copiando el desempaquetado del `jar` de la
  etapa `builder` al directorio `/app` de esta última etapa `runner`. Eso significa, que el contenedor final, tendrá en
  el directorio `/app` todos los directorios y archivos del desempaquetado del `jar` y para poder iniciar la aplicación
  utilizaremos el `JarLauncher` ubicado en el directorio `org.springframework.boot.loader.launch`. Más adelante, cuando
  creemos un contendor ingresaremos dentro de él para ver el contenido del directorio `/app`. Nos daremos cuenta que
  este directorio contendrá los directorios y archivos del desempaquetado del `jar`.

